<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>西伯利亚大尾巴狼</title>
  <icon>https://www.gravatar.com/avatar/7d9cee11c8c05e013b8780c0530e6e5b</icon>
  <subtitle>子非鱼，安知鱼之乐？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.yuanqinglong.cn/"/>
  <updated>2018-05-18T15:18:51.360Z</updated>
  <id>blog.yuanqinglong.cn/</id>
  
  <author>
    <name>袁庆龙</name>
    <email>yuanql96@yeah.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title> 前端提交数据的那些方式</title>
    <link href="blog.yuanqinglong.cn/%E5%89%8D%E7%AB%AF%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E6%96%B9%E5%BC%8F.html"/>
    <id>blog.yuanqinglong.cn/前端提交数据的那些方式.html</id>
    <published>2018-05-18T13:40:11.000Z</published>
    <updated>2018-05-18T15:18:51.360Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明：本篇文章转自<a href="https://blog.csdn.net/dancen/article/details/37572101，" target="_blank" rel="noopener">https://blog.csdn.net/dancen/article/details/37572101，</a><br>相比其他浅显的文章，这篇更让我收获颇多，<br>另外，文章已略作修改，更易于自己理解</p></blockquote><p>Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>。<br><br>另外，关于<code>URL</code>：</p><ul><li>Uniform Resource Location 全称是资源定位符 (暂时不做和URI的区分)</li><li>用于请求获取具体路径上的资源</li></ul><p>HTTP中的<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>，对应的资源操作是————查，改，增，删。<br></p><ul><li><code>GET</code>一般用于获取/查询资源信息，</li><li><code>POST</code>一般用于更新资源信息。</li></ul><h4 id="根据HTTP规范，GET-用于信息获取，而且应该是安全的和幂等的。"><a href="#根据HTTP规范，GET-用于信息获取，而且应该是安全的和幂等的。" class="headerlink" title="根据HTTP规范，GET 用于信息获取，而且应该是安全的和幂等的。"></a>根据HTTP规范，GET 用于信息获取，而且应该是安全的和幂等的。</h4><ul><li>1)所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，<code>GET</code> 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。<br></li></ul><ul><li>注意：这里安全的含义仅仅是指是非修改信息。</li></ul><ul><li>2)幂等，意味着对同一 <code>URL</code> 的多个请求应该返回同样的结果。<ul><li>A. 概念：幂等（idempotent、idempotence)是一个数学或计算机学概念，常见于抽象代数中。</li><li>B. 幂等有一下几种定义：<br>-i. 对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有<code>abs(a)=abs(abs(a))</code>。<br>-ii. 对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。</li><li>C. 看完上述解释后，应该可以理解<code>GET</code>幂等的含义了。</li></ul></li></ul><p>但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回最新的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。</p><h4 id="根据HTTP规范，POST表示可能修改变服务器上的资源的请求。"><a href="#根据HTTP规范，POST表示可能修改变服务器上的资源的请求。" class="headerlink" title="根据HTTP规范，POST表示可能修改变服务器上的资源的请求。"></a>根据HTTP规范，<code>POST</code>表示可能修改变服务器上的资源的请求。</h4><ul><li>继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过<code>POST</code>实现，因为在评论提交后，我们已经将数据库里的数据项进行更新（插入了一天新的评论)操作，站点的资源已经不同了，或者说资源被修改了。</li></ul><p>上面大概说了一下HTTP规范中<code>GET</code>和<code>POST</code>的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，<br>比如说：</p><ul><li><p>1) 很多人贪方便，更新资源时用了<code>GET</code>，举个栗子来讲就是我们在跳转某个链接时可能需要附带相应参数才能跳转到相应的页面<a src="http://localhost:8080/test?name=lisi&age=12">(别试了，链接瞎写的，意思到了就行了)，而<code>POST</code>必须要到FORM（表单)，以及再上传文件时，我们必须表单里添加这样的属性<code>enctype = &quot;multipart/form-data&quot;</code>，相比知悉，简单与否，便知分晓。</a></p></li><li><p>2)对资源的增，删，改，查操作，其实都可以通过<code>GET</code>/<code>POST</code>完成，不需要用到<code>PUT</code>和<code>DELETE</code>（尴尬的PUT,DELETE)。</p></li><li><p>3)另外一个是，早期的Web MVC框架设计者们并没有有意识地将<code>URL</code>当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的Web MVC框架基本上都只支持<code>GET</code>和<code>POST</code>两种HTTP方法，而不支持<code>PUT</code>和<code>DELETE</code>方法。</p><ul><li>A. 简单解释一下MVC：MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。</li></ul></li></ul><p>以上3点典型地描述了老一套的风格（没有严格遵守HTTP规范)，随着架构的发展，现在出现<code>REST</code>(Representational State Transfer)，一套支持HTTP规范的新风格，这里不多说了，可以参考《RESTful Web Services》。</p><h4 id="说完原理性的问题，我们再从表面现像上面看看GET和POST的区别："><a href="#说完原理性的问题，我们再从表面现像上面看看GET和POST的区别：" class="headerlink" title="说完原理性的问题，我们再从表面现像上面看看GET和POST的区别："></a>说完原理性的问题，我们再从表面现像上面看看<code>GET</code>和<code>POST</code>的区别：</h4><ul><li><p>1) <code>GET</code>请求的数据会附在<code>URL</code>之后（就是把数据放置在HTTP协议头中)，以?分割<code>URL</code>和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。<br><code>POST</code>把提交的数据则放置在是HTTP包的包体中。</p></li><li><p>2) “<code>GET</code>方式提交的数据最多只能是1024字节，理论上<code>POST</code>没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！</p></li></ul><p>以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的：</p><ul><li><p>1) 首先是”<code>GET</code>方式提交的数据最多只能是1024字节”，因为<code>GET</code>是通过<code>URL</code>提交数据，那么<code>GET</code>可提交的数据量就跟<code>URL</code>的长度有直接关系了。而实际上，<code>URL</code>不存在参数上限的问题，HTTP协议规范没有对<code>URL</code>长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对<code>URL</code>长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。<br>&gt;<br><strong>注意这是限制是整个<code>URL</code>长度，而不仅仅是你的参数值数据长度。</strong></p></li><li><p>2) 理论上讲，<code>POST</code>是没有大小限制的，HTTP协议规范也没有进行大小限制，说“<code>POST</code>数据量存在80K/100K的大小限制”是不准确的，<code>POST</code>数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。</p><ul><li>A.对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用<code>Request.BinaryRead</code>则没有这个限制。</li><li>B.由这个延伸出去，对于IIS 6.0，微软出于安全考虑，加大了限制。我们还需要注意：<ul><li>i. IIS 6.0默认ASP <code>POST</code>数据量最大为200KB，每个表单域限制是100KB。</li><li>ii. IIS 6.0默认上传文件的最大大小是4MB。</li><li>iii. IIS 6.0默认最大请求头是16KB。</li><li>iv. IIS 6.0之前没有这些限制。</li></ul></li><li>所以上面的80K，100K可能只是默认值而已(注：关于IIS4和IIS5的参数，我还没有确认)，但肯定是可以自己设置的。由于每个版本的IIS对这些参数的默认值都不一样，具体请参考相关的IIS配置文档。</li></ul></li><li><p>3) 在ASP中，服务端获取<code>GET</code>请求参数用<code>Request.QueryString</code>，获取<code>POST</code>请求参数用<code>Request.Form</code>。在JSP中，用<code>request.getParameter(\&quot;XXXX\&quot;)</code>来获取，虽然jsp中也有<code>request.getQueryString()</code>方法，但使用起来比较麻烦，比如：传一个<code>test.jsp?name=hyddd&amp;password=hyddd</code>，用<code>request.getQueryString()</code>得到的是：<code>name=hyddd&amp;password=hyddd</code>。在PHP中，可以用<code>$_GET</code>和<code>$_POST</code>分别获取<code>GET</code>和<code>POST</code>中的数据，而<code>$_REQUEST</code>则可以获取<code>GET</code>和<code>POST</code>两种请求中的数据。值得注意的是，JSP中使用<code>request</code>和PHP中使用<code>$_REQUEST</code>都会有隐患。</p></li><li><p>4) <code>POST</code>的安全性要比<code>GET</code>的安全性高。注意：这里所说的安全性和上面<code>GET</code>提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过<code>GET</code>提交数据，用户名和密码将明文出现在<code>URL</code>上，因为:</p><ul><li>A. 登录页面有可能被浏览器缓存</li><li>B. 其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用<code>GET</code>提交数据还可能会造成Cross-Site Request Forgery(跨站请求伪造)攻击。</li><li>总结一下，<code>Get</code>是向服务器发索取数据的一种请求，而<code>Post</code>是向服务器提交数据的一种请求，在FORM（表单)中，Method默认为”<code>GET</code>“<br><br>实质上，<code>GET</code>和<code>POST</code>只是发送机制不同，并不是一个取一个发！</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;声明：本篇文章转自&lt;a href=&quot;https://blog.csdn.net/dancen/article/details/37572101，&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.ne
      
    
    </summary>
    
      <category term="ES6" scheme="blog.yuanqinglong.cn/categories/ES6/"/>
    
    
      <category term="变量的解构与赋值" scheme="blog.yuanqinglong.cn/tags/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E4%B8%8E%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title> 关于 Restful 接口的二三事</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8E-Restful-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B.html"/>
    <id>blog.yuanqinglong.cn/关于-Restful-接口的二三事.html</id>
    <published>2018-05-18T02:13:58.000Z</published>
    <updated>2018-05-18T15:18:54.487Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Restful" scheme="blog.yuanqinglong.cn/categories/Restful/"/>
    
    
      <category term="Restful" scheme="blog.yuanqinglong.cn/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>关于ES6-变量的解构与赋值</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8EES6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E4%B8%8E%E8%B5%8B%E5%80%BC.html"/>
    <id>blog.yuanqinglong.cn/关于ES6-变量的解构与赋值.html</id>
    <published>2018-05-16T13:53:18.000Z</published>
    <updated>2018-05-18T13:29:52.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》<br>原文链接：<a href="http://es6.ruanyifeng.com/?search=import&amp;x=0&amp;y=0#docs/destructuring" target="_blank" rel="noopener">http://es6.ruanyifeng.com/?search=import&amp;x=0&amp;y=0#docs/destructuring</a><br>关于ES6,很多浏览器都已经实现支持其大部分的语法，以及，在很多框架里，如Vue.js,以及一些基于Node.js的框架，都可以看到类似ES6语法的影子</p></blockquote><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><p>####基本用法</p><ul><li>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</li><li>以前，为变量赋值，只能直接指定值。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 1;</span><br><span class="line"><span class="built_in">let</span> b = 2;</span><br><span class="line"><span class="built_in">let</span> c = 3;</span><br></pre></td></tr></table></figure><ul><li>ES6 允许写成下面这样。<a id="more"></a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [a, b, c] = [1, 2, 3];</span><br></pre></td></tr></table></figure><ul><li><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p></li><li><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class="line">foo // 1</span><br><span class="line">bar // 2</span><br><span class="line">baz // 3</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third // <span class="string">"baz"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x, , y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [head, ...tail] = [1, 2, 3, 4];</span><br><span class="line">head // 1</span><br><span class="line">tail // [2, 3, 4]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x // <span class="string">"a"</span></span><br><span class="line">y // undefined</span><br><span class="line">z // []</span><br></pre></td></tr></table></figure><ul><li>如果解构不成功，变量的值就等于<code>undefined</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [foo] = [];</span><br><span class="line"><span class="built_in">let</span> [bar, foo] = [1];</span><br></pre></td></tr></table></figure><ul><li><p>以上两种情况都属于解构不成功，foo的值都会等于<code>undefined</code>。</p></li><li><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x, y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [a, [b], d] = [1, [2, 3], 4];</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">d // 4</span><br></pre></td></tr></table></figure><ul><li><p>上面两个例子，都属于不完全解构，但是可以成功。</p></li><li><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="built_in">let</span> [foo] = 1;</span><br><span class="line"><span class="built_in">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">let</span> [foo] = NaN;</span><br><span class="line"><span class="built_in">let</span> [foo] = undefined;</span><br><span class="line"><span class="built_in">let</span> [foo] = null;</span><br><span class="line"><span class="built_in">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 <code>Iterator</code> 接口（前五个表达式），要么本身就不具备 <code>Iterator</code> 接口（最后一个表达式）。</p></li></ul><h3 id="对于-Set-结构，也可以使用数组的解构赋值。"><a href="#对于-Set-结构，也可以使用数组的解构赋值。" class="headerlink" title="对于 Set 结构，也可以使用数组的解构赋值。"></a>对于 Set 结构，也可以使用数组的解构赋值。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x, y, z] = new Set([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">x // <span class="string">"a"</span></span><br></pre></td></tr></table></figure><ul><li>事实上，只要某种数据结构具有 <code>Iterator</code> 接口，都可以采用数组形式的解构赋值。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">fibs</span></span>() &#123;</span><br><span class="line"><span class="built_in">let</span> a = 0;</span><br><span class="line"><span class="built_in">let</span> b = 1;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    yield a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth // 5</span><br></pre></td></tr></table></figure><ul><li>上面代码中，fibs是一个 <code>Generator</code> 函数（参见《Generator 函数》一章），原生具有 <code>Iterator</code> 接口。解构赋值会依次从这个接口获取值。</li></ul><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><ul><li>解构赋值允许指定默认值。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; // x=<span class="string">'a'</span>, y=<span class="string">'b'</span></span><br><span class="line"><span class="built_in">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, undefined]; // x=<span class="string">'a'</span>, y=<span class="string">'b'</span></span><br></pre></td></tr></table></figure><ul><li>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</li><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x = 1] = [undefined];</span><br><span class="line">x // 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x = 1] = [null];</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为null不严格等于<code>undefined</code>。</p></li><li><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">console.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x = f()] = [1];</span><br></pre></td></tr></table></figure><ul><li><p>上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([1][0] === undefined) &#123;</span><br><span class="line">x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x = [1][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x = 1, y = x] = [];     // x=1; y=1</span><br><span class="line"><span class="built_in">let</span> [x = 1, y = x] = [2];    // x=2; y=2</span><br><span class="line"><span class="built_in">let</span> [x = 1, y = x] = [1, 2]; // x=1; y=2</span><br><span class="line"><span class="built_in">let</span> [x = y, y = 1] = [];     // ReferenceError: y is not defined</span><br></pre></td></tr></table></figure></li><li><p>上面最后一个表达式之所以会报错，是因为<code>x</code>用<code>y</code>做默认值时，<code>y</code>还没有声明。</p></li></ul><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><ul><li><p>解构不仅可以用于数组，还可以用于对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; foo, bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo // <span class="string">"aaa"</span></span><br><span class="line">bar // <span class="string">"bbb"</span></span><br></pre></td></tr></table></figure></li><li><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，- 变量必须与属性同名，才能取到正确的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; bar, foo &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo // <span class="string">"aaa"</span></span><br><span class="line">bar // <span class="string">"bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz // undefined</span><br></pre></td></tr></table></figure></li><li><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。</p></li><li><p>如果变量名与属性名不一致，必须写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; foo: baz &#125; = &#123; foo: <span class="string">'aaa'</span>, bar: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz // <span class="string">"aaa"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = &#123; first: <span class="string">'hello'</span>, last: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="built_in">let</span> &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f // <span class="string">'hello'</span></span><br><span class="line">l // <span class="string">'world'</span></span><br></pre></td></tr></table></figure></li><li><p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; foo: foo, bar: bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; foo: baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz // <span class="string">"aaa"</span></span><br><span class="line">foo // error: foo is not defined</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p></li><li><p>与数组一样，解构也可以用于嵌套结构的对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; y: <span class="string">'World'</span> &#125;</span><br><span class="line">]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // <span class="string">"Hello"</span></span><br><span class="line">y // <span class="string">"World"</span></span><br></pre></td></tr></table></figure></li><li><p>注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; y: <span class="string">'World'</span> &#125;</span><br><span class="line">]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; p, p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // <span class="string">"Hello"</span></span><br><span class="line">y // <span class="string">"World"</span></span><br><span class="line">p // [<span class="string">"Hello"</span>, &#123;y: <span class="string">"World"</span>&#125;]</span><br></pre></td></tr></table></figure></li><li><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const node = &#123;</span><br><span class="line">loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">    line: 1,</span><br><span class="line">    column: 5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line // 1</span><br><span class="line">loc  // Object &#123;start: Object&#125;</span><br><span class="line">start // Object &#123;line: 1, column: 5&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。</p></li></ul><p>下面是嵌套赋值的例子。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">obj // &#123;prop:123&#125;</span><br><span class="line">arr // [<span class="literal">true</span>]</span><br></pre></td></tr></table></figure><p></p><h3 id="对象的解构也可以指定默认值。"><a href="#对象的解构也可以指定默认值。" class="headerlink" title="对象的解构也可以指定默认值。"></a>对象的解构也可以指定默认值。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var &#123;x = 3&#125; = &#123;&#125;;</span><br><span class="line">x // 3</span><br><span class="line"></span><br><span class="line">var &#123;x, y = 5&#125; = &#123;x: 1&#125;;</span><br><span class="line">x // 1</span><br><span class="line">y // 5</span><br><span class="line"></span><br><span class="line">var &#123;x: y = 3&#125; = &#123;&#125;;</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line">var &#123;x: y = 3&#125; = &#123;x: 5&#125;;</span><br><span class="line">y // 5</span><br><span class="line"></span><br><span class="line">var &#123; message: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</span><br><span class="line">msg // <span class="string">"Something went wrong"</span></span><br></pre></td></tr></table></figure><ul><li>默认值生效的条件是，对象的属性值严格等于undefined。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var &#123;x = 3&#125; = &#123;x: undefined&#125;;</span><br><span class="line">x // 3</span><br><span class="line"></span><br><span class="line">var &#123;x = 3&#125; = &#123;x: null&#125;;</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure><ul><li><p>上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。</p></li><li><p>如果解构失败，变量的值等于undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123;foo&#125; = &#123;bar: <span class="string">'baz'</span>&#125;;</span><br><span class="line">foo // undefined</span><br></pre></td></tr></table></figure></li><li><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="built_in">let</span> &#123;foo: &#123;bar&#125;&#125; = &#123;baz: <span class="string">'baz'</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> _tmp = &#123;baz: <span class="string">'baz'</span>&#125;;</span><br><span class="line">_tmp.foo.bar // 报错</span><br></pre></td></tr></table></figure></li><li><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;x: 1&#125;;</span><br><span class="line">// SyntaxError: syntax error</span><br></pre></td></tr></table></figure></li><li><p>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 正确的写法</span><br><span class="line"><span class="built_in">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;x: 1&#125;);</span><br></pre></td></tr></table></figure></li><li><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p></li><li><p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure></li><li><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p></li><li><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; <span class="built_in">log</span>, sin, cos &#125; = Math;</span><br></pre></td></tr></table></figure></li><li><p>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p></li><li><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1, 2, 3];</span><br><span class="line"><span class="built_in">let</span> &#123;0 : first, [arr.length - 1] : last&#125; = arr;</span><br><span class="line">first // 1</span><br><span class="line">last // 3</span><br></pre></td></tr></table></figure></li><li><p>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。</p></li></ul><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><ul><li><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a // <span class="string">"h"</span></span><br><span class="line">b // <span class="string">"e"</span></span><br><span class="line">c // <span class="string">"l"</span></span><br><span class="line">d // <span class="string">"l"</span></span><br><span class="line">e // <span class="string">"o"</span></span><br></pre></td></tr></table></figure></li><li><p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123;length : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len // 5</span><br></pre></td></tr></table></figure></li></ul><h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><ul><li><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123;toString: s&#125; = 123;</span><br><span class="line">s === Number.prototype.toString // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123;toString: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === Boolean.prototype.toString // <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p></li><li><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; prop: x &#125; = undefined; // TypeError</span><br><span class="line"><span class="built_in">let</span> &#123; prop: y &#125; = null; // TypeError</span><br></pre></td></tr></table></figure><h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><ul><li><p>函数的参数也可以使用解构赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add([x, y])&#123;</span><br><span class="line"><span class="built_in">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([1, 2]); // 3</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p></li><li><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);</span><br><span class="line">// [ 3, 7 ]</span><br><span class="line">函数参数的解构也可以使用默认值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line"><span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, 0]</span><br><span class="line">move(&#123;&#125;); // [0, 0]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</p></li><li><p>注意，下面的写法会得到不一样的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line"><span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, undefined]</span><br><span class="line">move(&#123;&#125;); // [undefined, undefined]</span><br><span class="line">move(); // [0, 0]</span><br><span class="line">上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</span><br><span class="line"></span><br><span class="line">undefined就会触发函数参数的默认值。</span><br><span class="line"></span><br><span class="line">[1, undefined, 3].map((x = <span class="string">'yes'</span>) =&gt; x);</span><br><span class="line">// [ 1, <span class="string">'yes'</span>, 3 ]</span><br></pre></td></tr></table></figure></li></ul><h4 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h4><ul><li><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p></li><li><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。<br>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p></li></ul><h3 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h3><ul><li>以下三种解构赋值不得使用圆括号。</li></ul><h4 id="（1）变量声明语句"><a href="#（1）变量声明语句" class="headerlink" title="（1）变量声明语句"></a>（1）变量声明语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line"><span class="built_in">let</span> [(a)] = [1];</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123;x: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> (&#123;x: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;</span><br></pre></td></tr></table></figure><ul><li>上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</li></ul><h4 id="（2）函数参数"><a href="#（2）函数参数" class="headerlink" title="（2）函数参数"></a>（2）函数参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数参数也属于变量声明，因此不能带有圆括号。</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> f([(z)]) &#123; <span class="built_in">return</span> z; &#125;</span><br><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> f([z,(x)]) &#123; <span class="built_in">return</span> x; &#125;</span><br></pre></td></tr></table></figure><p>####（3）赋值语句的模式<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line">(&#123; p: a &#125;) = &#123; p: 42 &#125;;</span><br><span class="line">([a]) = [5];</span><br></pre></td></tr></table></figure><p></p><ul><li>上面代码将整个模式放在圆括号之中，导致报错。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><ul><li>上面代码将一部分模式放在圆括号之中，导致报错。</li></ul><ul><li>可以使用圆括号的情况</li><li><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [3]; // 正确</span><br><span class="line">(&#123; p: (d) &#125; = &#123;&#125;); // 正确</span><br><span class="line">[(parseInt.prop)] = [3]; // 正确</span><br></pre></td></tr></table></figure></li><li><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p></li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>变量的解构赋值用途很多。</li></ul><p>####（1）交换变量的值<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x = 1;</span><br><span class="line"><span class="built_in">let</span> y = 2;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p></p><ul><li>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</li></ul><h4 id="（2）从函数返回多个值"><a href="#（2）从函数返回多个值" class="headerlink" title="（2）从函数返回多个值"></a>（2）从函数返回多个值</h4><ul><li>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 返回一个数组</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line">// 返回一个对象</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><h4 id="（3）函数参数的定义"><a href="#（3）函数参数的定义" class="headerlink" title="（3）函数参数的定义"></a>（3）函数参数的定义</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 解构赋值可以方便地将一组参数与变量名对应起来。</span><br><span class="line"></span><br><span class="line">    // 参数是一组有次序的值</span><br><span class="line">    <span class="keyword">function</span> f([x, y, z]) &#123; ... &#125;</span><br><span class="line">    f([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">    // 参数是一组无次序的值</span><br><span class="line">    <span class="keyword">function</span> f(&#123;x, y, z&#125;) &#123; ... &#125;</span><br><span class="line">    f(&#123;z: 3, y: 2, x: 1&#125;);</span><br></pre></td></tr></table></figure><h4 id="（4）提取-JSON-数据"><a href="#（4）提取-JSON-数据" class="headerlink" title="（4）提取 JSON 数据"></a>（4）提取 JSON 数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">解构赋值对提取 JSON 对象中的数据，尤其有用。</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> jsonData = &#123;</span><br><span class="line">id: 42,</span><br><span class="line">status: <span class="string">"OK"</span>,</span><br><span class="line">data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.log(id, status, number);</span><br><span class="line">// 42, <span class="string">"OK"</span>, [867, 5309]</span><br><span class="line">上面代码可以快速提取 JSON 数据的值。</span><br></pre></td></tr></table></figure><p>####（5）函数参数的默认值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    jQuery.ajax = <span class="keyword">function</span> (url, &#123;</span><br><span class="line">    async = <span class="literal">true</span>,</span><br><span class="line">    beforeSend = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">    cache = <span class="literal">true</span>,</span><br><span class="line">    complete = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">    crossDomain = <span class="literal">false</span>,</span><br><span class="line">    global = <span class="literal">true</span>,</span><br><span class="line">    // ... more config</span><br><span class="line">    &#125; = &#123;&#125;) &#123;</span><br><span class="line">    // ... <span class="keyword">do</span> stuff</span><br><span class="line">&#125;;</span><br><span class="line">指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || <span class="string">'default foo'</span>;这样的语句。</span><br></pre></td></tr></table></figure><h4 id="（6）遍历-Map-结构"><a href="#（6）遍历-Map-结构" class="headerlink" title="（6）遍历 Map 结构"></a>（6）遍历 Map 结构</h4><ul><li>任何部署了 <code>Iterator</code> 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 <code>Iterator</code> 接口，配合变量的解构赋值，获取键名和键值就非常方便。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of map) &#123;</span><br><span class="line">console.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br></pre></td></tr></table></figure><ul><li>如果只想获取键名，或者只想获取键值，可以写成下面这样。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取键名</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key] of map) &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取键值</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [,value] of map) &#123;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>}</p><h4 id="（7）输入模块的指定方法"><a href="#（7）输入模块的指定方法" class="headerlink" title="（7）输入模块的指定方法"></a>（7）输入模块的指定方法</h4><ul><li>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》&lt;br&gt;原文链接：&lt;a href=&quot;http://es6.ruanyifeng.com/?search=import&amp;amp;x=0&amp;amp;y=0#docs/destructuring&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://es6.ruanyifeng.com/?search=import&amp;amp;x=0&amp;amp;y=0#docs/destructuring&lt;/a&gt;&lt;br&gt;关于ES6,很多浏览器都已经实现支持其大部分的语法，以及，在很多框架里，如Vue.js,以及一些基于Node.js的框架，都可以看到类似ES6语法的影子&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;数组的解构赋值&quot;&gt;&lt;a href=&quot;#数组的解构赋值&quot; class=&quot;headerlink&quot; title=&quot;数组的解构赋值&quot;&gt;&lt;/a&gt;数组的解构赋值&lt;/h3&gt;&lt;p&gt;####基本用法&lt;/p&gt;&lt;ul&gt;&lt;li&gt;ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。&lt;/li&gt;&lt;li&gt;以前，为变量赋值，只能直接指定值。&lt;/li&gt;&lt;/ul&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; a = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; b = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; c = 3;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;ES6 允许写成下面这样。
    
    </summary>
    
      <category term="ES6" scheme="blog.yuanqinglong.cn/categories/ES6/"/>
    
    
      <category term="变量的解构与赋值" scheme="blog.yuanqinglong.cn/tags/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E4%B8%8E%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>算法基础———选择排序 </title>
    <link href="blog.yuanqinglong.cn/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html"/>
    <id>blog.yuanqinglong.cn/算法基础———选择排序.html</id>
    <published>2018-05-05T15:08:58.000Z</published>
    <updated>2018-05-05T15:47:02.099Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日积跬步，以期千里。<br>《算法基础·打开算法之门》小札</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>首先声明<code>array[i]</code>是目前所看到的子数组中最小的元素，然后扫描数组的剩余部分，每当发现一个有一个元素小于当前最小的元素时，我们就更新最小元素的索引</li></ul><hr><a id="more"></a><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ul><li>1.令i从0到n-1依次取值<ul><li>A. 将<code>smallest</code>赋值为 <code>i</code>.</li><li>B. 令<code>j</code>从<code>i+1</code>到n依次取值：<ul><li>i. 如果<code>A[j] &lt; A[smallest]</code>,那么将<code>smallest</code>赋值为j。</li></ul></li><li>C. 交换 <code>A[i]</code> 与 <code>A[smallest]</code>的值</li></ul></li></ul><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>选择排序的时间复杂度取决于外层循环的索引i。</p><ul><li>时间复杂度<code>O(n^2)</code></li><li>空间复杂度<code>O（1）</code></li></ul><h3 id="js程序代码"><a href="#js程序代码" class="headerlink" title="js程序代码"></a>js程序代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> selectionSort(arr) &#123;</span><br><span class="line">　　var len = arr.length;</span><br><span class="line">　　var smallest, temp;</span><br><span class="line">　　console.time(<span class="string">'选择排序耗时'</span>);</span><br><span class="line">　　<span class="keyword">for</span> (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">　　　　smallest = i;</span><br><span class="line">　　　　<span class="keyword">for</span> (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">　　　　　　<span class="keyword">if</span> (arr[j] &lt; arr[smallest]) &#123; //寻找最小的数</span><br><span class="line">　　　　　　　　smallest = j; //将最小数的索引保存</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　temp = arr[i];</span><br><span class="line">　　　　arr[i] = arr[smallest];</span><br><span class="line">　　　　arr[smallest] = temp;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(<span class="string">'选择排序耗时'</span>);</span><br><span class="line">　　<span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(selectionSort(arr));</span><br></pre></td></tr></table></figure><p>其实选择排序适合小数据排序，具体这个小数据有多小呢，简单的测试了一下，在1000条以内的数据，选择排序更胜冒泡排序。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;日积跬步，以期千里。&lt;br&gt;《算法基础·打开算法之门》小札&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;首先声明&lt;code&gt;array[i]&lt;/code&gt;是目前所看到的子数组中最小的元素，然后扫描数组的剩余部分，每当发现一个有一个元素小于当前最小的元素时，我们就更新最小元素的索引&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="算法基础" scheme="blog.yuanqinglong.cn/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="选择排序" scheme="blog.yuanqinglong.cn/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法基础之二分查找 </title>
    <link href="blog.yuanqinglong.cn/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"/>
    <id>blog.yuanqinglong.cn/算法基础之二分查找.html</id>
    <published>2018-05-04T13:24:14.000Z</published>
    <updated>2018-05-04T14:49:18.025Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在看《算法基础·打开算法之门》（毕竟程序猿的算法不能太差…）<br>人总是健忘的，所以我决定将我收获的东西记录下来<br>那么，首先，就是你了，最基础的二分查找！</p></blockquote><h3 id="关于二分查找，可以拥有如下叙述"><a href="#关于二分查找，可以拥有如下叙述" class="headerlink" title="关于二分查找，可以拥有如下叙述:"></a>关于二分查找，可以拥有如下叙述:</h3><ul><li>任意情况下，我们仅仅考虑某个子数组，也就是说，介于某两个索引之间的部分数组，将这两个索引依次记为p和r。初始时，p=1,r=n，因此开始时，子数组为整个完整数组，我们反复地将数组规模减半，直到一下任意一种情况发生：要么找到了要查找的元素，要么当前子数组为空（p&gt;r）。</li><li>反复对子数组执行减半操作需要的时间花费是<code>O(lgn)</code></li></ul><hr><a id="more"></a><h3 id="case-1"><a href="#case-1" class="headerlink" title="case-1"></a>case-1</h3><h4 id="逻辑："><a href="#逻辑：" class="headerlink" title="逻辑："></a>逻辑：</h4><h5 id="程序：binary-search-arr-n-x"><a href="#程序：binary-search-arr-n-x" class="headerlink" title="程序：binary-search(arr,n,x)"></a>程序：<code>binary-search(arr,n,x)</code></h5><h5 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h5><ul><li>arr:一个数组</li><li>n:数组中元素的个数</li><li>x要查找的值</li></ul><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><ul><li>满足条件的arr[i]的索引i，</li><li>特殊值‘not found’（相对于数组的任意无效索引值）</li></ul><h5 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h5><ul><li>1）将p赋值为1,r赋值为n</li><li>2）只要p &lt; = r,执行如下操作：<ul><li>A.将q赋值为(p + r) / 2 ———— ps:向下取整</li><li>B.如果A[q] = x,那么返回q。</li><li>C.否则（A[q] ! = x）,如果A[q]&gt;x,那么将r赋值为为q-1</li><li>D.否则（A[q] &lt; x），那么将p赋值为q+1</li></ul></li><li>3）返回“not found”</li></ul><h3 id="js代码实现"><a href="#js代码实现" class="headerlink" title="js代码实现"></a>js代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//默认由小到大排列数据</span><br><span class="line"><span class="keyword">function</span> binary-search(arr,n,x)&#123;</span><br><span class="line">    var p = 0;</span><br><span class="line">    var r = n-1;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; = r)&#123;</span><br><span class="line">        var q = Math.floor((p+r)/2);</span><br><span class="line">        <span class="keyword">if</span>(arr[q] == x)&#123;</span><br><span class="line">            <span class="built_in">return</span> q;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[q]&gt;x)&#123;</span><br><span class="line">                r = q - 1;       //真实上限索引要比x索引小，所以需要对数组上限重新取半赋值；</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = q + 1        //真实下限索引要比x索引大，所以需要对数组上限重新取半赋值；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'NOT FOUND !'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="case-2-递归的方式"><a href="#case-2-递归的方式" class="headerlink" title="case-2 (递归的方式)"></a>case-2 (递归的方式)</h3><h4 id="逻辑：-1"><a href="#逻辑：-1" class="headerlink" title="逻辑："></a>逻辑：</h4><h5 id="程序：recursive-binary-search-arr-p-r-x"><a href="#程序：recursive-binary-search-arr-p-r-x" class="headerlink" title="程序：recursive-binary-search(arr,p,r,x)"></a>程序：<code>recursive-binary-search(arr,p,r,x)</code></h5><h5 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h5><ul><li>相关变量同上文</li><li>增加p ,r 为数组arr的开头结尾索引</li></ul><h5 id="具体步骤-1"><a href="#具体步骤-1" class="headerlink" title="具体步骤"></a>具体步骤</h5><ul><li>1）如果p &gt; r,那么返回“not found”</li><li>2）否则(p &lt; = r),执行如下操作：<ul><li>A.将q赋值为(p + r) / 2  ———— ps:向下取整</li><li>B.如果A[q] = x,那么返回q。</li><li>C.否则（A[q] ! = x）,如果A[q] &gt; x,那么返回一个 recursive-binary-search(arr,p,q-1,x)</li><li>D.否则（A[q] &lt; x），那么返回一个 recursive-binary-search(arr,q+1,r,x)</li></ul></li></ul><h3 id="js代码实现-1"><a href="#js代码实现-1" class="headerlink" title="js代码实现"></a>js代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//默认由小到大排列数据</span><br><span class="line"><span class="keyword">function</span> recursive-binary-search(arr,p,r,x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &gt; r)&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'NOT FOUND !'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                      //p &lt; = r</span><br><span class="line">         var q = Math.floor((p + r) /  2);</span><br><span class="line">        <span class="keyword">if</span>(arr[q] == x)&#123;</span><br><span class="line">            <span class="built_in">return</span> q;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[q] &gt; x)&#123;</span><br><span class="line">               <span class="built_in">return</span> recursive-binary-search(arr,p,q-1,x);       //真实上限索引要比x索引小，所以需要对数组上限重新取半赋值；</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;               </span><br><span class="line">               <span class="built_in">return</span> recursive-binary-search(arr,q+1,r,x);       //真实下限索引要比x索引大，所以需要对数组上限重新取半赋值；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，以上的代码也许会有错误（好像没有…），因为只是单纯根据逻辑撸码，具体事件具体分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;最近在看《算法基础·打开算法之门》（毕竟程序猿的算法不能太差…）&lt;br&gt;人总是健忘的，所以我决定将我收获的东西记录下来&lt;br&gt;那么，首先，就是你了，最基础的二分查找！&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;关于二分查找，可以拥有如下叙述&quot;&gt;&lt;a href=&quot;#关于二分查找，可以拥有如下叙述&quot; class=&quot;headerlink&quot; title=&quot;关于二分查找，可以拥有如下叙述:&quot;&gt;&lt;/a&gt;关于二分查找，可以拥有如下叙述:&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;任意情况下，我们仅仅考虑某个子数组，也就是说，介于某两个索引之间的部分数组，将这两个索引依次记为p和r。初始时，p=1,r=n，因此开始时，子数组为整个完整数组，我们反复地将数组规模减半，直到一下任意一种情况发生：要么找到了要查找的元素，要么当前子数组为空（p&amp;gt;r）。&lt;/li&gt;&lt;li&gt;反复对子数组执行减半操作需要的时间花费是&lt;code&gt;O(lgn)&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="算法基础" scheme="blog.yuanqinglong.cn/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="二分查找" scheme="blog.yuanqinglong.cn/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>解决输入框长度maxLength的兼容性问题</title>
    <link href="blog.yuanqinglong.cn/%E8%A7%A3%E5%86%B3%E8%BE%93%E5%85%A5%E6%A1%86%E9%95%BF%E5%BA%A6maxLength%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98.html"/>
    <id>blog.yuanqinglong.cn/解决输入框长度maxLength的兼容性问题.html</id>
    <published>2018-04-11T12:18:30.000Z</published>
    <updated>2018-04-11T12:48:02.579Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在忙着做些东西，差点荒废了我的博客，随便写点什么吧</p></blockquote><p>在input标签中，只需要设置maxlength=”<em>*</em>”即可，但是在textarea标签中，IE9及IE9以下浏览器是不支持的，IE10、IE11则支持，估计后续的版本应该都会支持<br><a id="more"></a><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea id=<span class="string">"taContent"</span> rows=<span class="string">"3"</span>  maxlength=<span class="string">"20"</span> </span><br><span class="line">onchange=<span class="string">"this.value=this.value.substring(0, 20)"</span></span><br><span class="line">onkeydown=<span class="string">"this.value=this.value.substring(0, 20)"</span> </span><br><span class="line">onkeyup=<span class="string">"this.value=this.value.substring(0, 20)"</span> &gt;</span><br><span class="line">&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p></p><p>备注：<code>onchange</code>、<code>onkeydown</code>、<code>onkeyup</code>三者缺一不可。</p><p>如省略<code>onchange</code>，当你用负责功能，此时一直按着ctrl不松开，鼠标去点击其他地方（焦点移出textarea）时，不会自动取消超出部分；</p><p>如省略<code>onkeydown</code>，猛敲的时候会有很多个字符突然不见了；</p><p>如省略<code>onkeyup</code>，原想预计20的情况下，会变成21，并且最后一个字符是最后敲进去的。</p><p><code>Maxlength</code> 也不可省略，加上<code>maxlength</code> 当碰到IE10及以上版本时，可以完美的实现限制输入框字数的功能。不想其他低版本的IE浏览器还可以出现一个字母后消失。</p><blockquote><p>本方法参考自： <a href="http://www.thylx.net/newsdetail.aspx?id=37" target="_blank" rel="noopener">http://www.thylx.net/newsdetail.aspx?id=37</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;最近在忙着做些东西，差点荒废了我的博客，随便写点什么吧&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在input标签中，只需要设置maxlength=”&lt;em&gt;*&lt;/em&gt;”即可，但是在textarea标签中，IE9及IE9以下浏览器是不支持的，IE10、IE11则支持，估计后续的版本应该都会支持&lt;br&gt;
    
    </summary>
    
      <category term="HTML" scheme="blog.yuanqinglong.cn/categories/HTML/"/>
    
    
      <category term="maxLength" scheme="blog.yuanqinglong.cn/tags/maxLength/"/>
    
  </entry>
  
  <entry>
    <title>改变浏览器位置</title>
    <link href="blog.yuanqinglong.cn/%E6%94%B9%E5%8F%98%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%8D%E7%BD%AE.html"/>
    <id>blog.yuanqinglong.cn/改变浏览器位置.html</id>
    <published>2018-03-20T13:45:40.000Z</published>
    <updated>2018-03-20T14:27:49.721Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。</p></blockquote><p>实际上，就是改变浏览器的url，so，有哪些方法呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) location.assign(<span class="string">"http://www.wrox.com"</span>)</span><br><span class="line">2) window.location = <span class="string">"http://www.wrox.com"</span></span><br><span class="line">3) location.href = <span class="string">"http://www.wrox.com"</span></span><br></pre></td></tr></table></figure><p>当然，2）、3）其实都是调用了assign()方法的，只不过是形式不一样而已，</p><a id="more"></a><p> 另外，每次修改location的属性时，如<code>hostname</code>,<code>path</code>,<code>port</code>等时(<code>hash</code>除外)，页面都会以新的URL载入，<br> 注：<strong>无论以何种方式修改URL。都会在历史记录中生成一条新的纪录</strong> </p><p> 若要禁止这种行为（即生成一条新的纪录），可以使用replace()方法，该方法接受一个参数，即<strong>要导航到的URL</strong>。<br> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">location.replace(<span class="string">"http://www.wrox.com"</span>);</span><br></pre></td></tr></table></figure><p></p><p> 结果就是，同样会导致浏览器的位置改变，但是不会在历史记录生成新的纪录</p><p>最后一种改变浏览器位置的方法：<code>reload</code> </p><pre><code class="bash">reload //重新加载，可能是从个缓存中加载reload(<span class="literal">true</span>); //强制加载，即从服务器端加载</code></pre><p>注意：reload()调用后，也有可能不会立即执行，它取决于网络资源或系统延迟等，所以最好将<code>reload()</code>放在代码的最后一行</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;实际上，就是改变浏览器的url，so，有哪些方法呢？&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1) location.assign(&lt;span class=&quot;string&quot;&gt;&quot;http://www.wrox.com&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2) window.location = &lt;span class=&quot;string&quot;&gt;&quot;http://www.wrox.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3) location.href = &lt;span class=&quot;string&quot;&gt;&quot;http://www.wrox.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然，2）、3）其实都是调用了assign()方法的，只不过是形式不一样而已，&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="blog.yuanqinglong.cn/categories/javascript/"/>
    
    
      <category term="loaction" scheme="blog.yuanqinglong.cn/tags/loaction/"/>
    
  </entry>
  
  <entry>
    <title>找到数组的最值 </title>
    <link href="blog.yuanqinglong.cn/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%80%BC.html"/>
    <id>blog.yuanqinglong.cn/找到数组的最值.html</id>
    <published>2018-03-15T14:20:42.000Z</published>
    <updated>2018-03-15T16:01:23.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。</p></blockquote><p>在一个数组中找到最值，书中给了我们这样的一个方法（以最大值为例）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Values = [1,2,3];</span><br><span class="line">var max = Math.max.apply(Math,Values);</span><br><span class="line">var max = Math.max.apply(null,Values);</span><br></pre></td></tr></table></figure><a id="more"></a><p> <br></p><p>那么：<br>1）问题一，为什么是 <strong><code>Math.max.apply()</code></strong> ,而非 <strong><code>Math.max()</code></strong>?<br>答：  <code>max()</code>方法本身需要大于等于2个的纯数字参数<br>比如：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Math.max(10,20,30))//<span class="string">"30"</span></span><br><span class="line">console.log(Math.max(10,20))//<span class="string">"20"</span> </span><br><span class="line">console.log(Math.max(a,b));//ReferenceError: a is not defined</span><br></pre></td></tr></table></figure><p>很明显，<strong><code>Math.max()</code></strong> 的Values，只是一个变量，无法满足大于等于2，以及纯数字的两个条件，所以为满足要求（求数组里的最值），<strong><code>Math.max.apply()</code></strong>无疑是非常好的方法：</p><p>2）问题二，为什么是 <strong><code>Math.max.apply()</code></strong>,而非是 <strong><code>Math.max().apply()</code></strong><br>答：我们要明白两个知识点<br>     【1】 <strong><code>max()</code></strong> 与 <strong><code>max</code></strong> 的区别，函数名本质上是一个指向存储函数代码的内存地址的指针，单纯的写函数名并不会而函数名后面加括号如： <strong><code>max()</code></strong> ，则是对函数的调用执行。<br>     【2】 <strong><code>apply()</code></strong>  、 <strong><code>call()</code></strong> 是每个函数都包含的非继承的方法。作用是在 <strong>特定的作用域</strong> 中 <strong>调用函数</strong>。<br>     前者可以接受两个参数，后者可以接受两个及两个以上的参数。二者的第一个参数都是设置函数体内的 <strong><code>This</code></strong> 指向，即 <strong>“ 特定的作用域 ”</strong>。只写一个参数的情况下，默认设置的是 <strong><code>This</code></strong> 指向。<br>     而 <strong>调用函数</strong>，等价于函数名后面加括号的效果。<br>3）问题三， <strong><code>Math.max.apply(null,Values)</code></strong> 与 <strong><code>Math.max.apply(Math,Values)</code></strong> 区别？<br>答：没区别。<br>    因为第一个参数是 <strong>特定的作用域</strong> （也就是this指向），又因为，null，默认是前面的对象。而在本题中，前面的对象是Math，所以显而易见，二者结果并无区别。<br>，</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在一个数组中找到最值，书中给了我们这样的一个方法（以最大值为例）：&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var Values = [1,2,3];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var max = Math.max.apply(Math,Values);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var max = Math.max.apply(null,Values);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="blog.yuanqinglong.cn/categories/javascript/"/>
    
    
      <category term="apply、call" scheme="blog.yuanqinglong.cn/tags/apply%E3%80%81call/"/>
    
  </entry>
  
  <entry>
    <title>charAt与 indexOf与lastIndexOf </title>
    <link href="blog.yuanqinglong.cn/charAt%E4%B8%8E-indexOf%E4%B8%8ElastIndexOf.html"/>
    <id>blog.yuanqinglong.cn/charAt与-indexOf与lastIndexOf.html</id>
    <published>2018-03-13T14:12:38.000Z</published>
    <updated>2018-03-14T15:46:21.055Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。</p></blockquote><ul><li><h5 id="访问字符串中特定字符的方法是：charAt-amp-charCodeAt"><a href="#访问字符串中特定字符的方法是：charAt-amp-charCodeAt" class="headerlink" title="访问字符串中特定字符的方法是：charAt() &amp; charCodeAt()"></a>访问字符串中特定字符的方法是：<code>charAt()</code> &amp; <code>charCodeAt()</code></h5><a id="more"></a><pre><code class="bash">var stringValue = <span class="string">"hello world"</span>;alert(stringValue.charAt(1));//<span class="string">"e"</span>alert(stringValue.charCodeAt(1));//<span class="string">"101"</span></code></pre><p>上述代码中<br>1)前者<code>charAt()</code>输出的是指定位置的 <strong>字符</strong><br>2)后者<code>charCodeAt()</code>输出的是指定位置的<strong>字符串的编码</strong></p></li><li><h5 id="从字符串中查找子字符串的方法是：indexOf-amp-lastIndexOf"><a href="#从字符串中查找子字符串的方法是：indexOf-amp-lastIndexOf" class="headerlink" title="从字符串中查找子字符串的方法是：indexOf() &amp; lastIndexOf()"></a>从字符串中查找子字符串的方法是：<code>indexOf()</code> &amp; <code>lastIndexOf()</code></h5><pre><code class="bash">var stringValue = <span class="string">"hello world"</span>;alert(stringValue.indexOf(<span class="string">"o"</span>));//<span class="string">"4"</span>alert(stringValue.lastIndexOf(<span class="string">"o"</span>));//<span class="string">"7"</span></code></pre><p>上述代码中<br>无论是<code>indexOf()</code>还是<code>lastIndexOf()</code>，<br>返回的子字符串位置都是基于<strong>正向查询</strong> (始于0) 。<br>由此可知，<br>若子字符串在源字符串中<code>只出现过一次</code>，则两种方法返回相同的结果。<br>若<code>未找到</code>该字符串，则都返回<code>-1</code><br>而区别在于：<br>1）前者<code>indexOf()</code>方法，是从开头向后搜索字符串<br>2）后者<code>lastIndexOf()</code>方法，是从末尾向开头搜索字符串</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;h5 id=&quot;访问字符串中特定字符的方法是：charAt-amp-charCodeAt&quot;&gt;&lt;a href=&quot;#访问字符串中特定字符的方法是：charAt-amp-charCodeAt&quot; class=&quot;headerlink&quot; title=&quot;访问字符串中特定字符的方法是：charAt() &amp;amp; charCodeAt()&quot;&gt;&lt;/a&gt;访问字符串中特定字符的方法是：&lt;code&gt;charAt()&lt;/code&gt; &amp;amp; &lt;code&gt;charCodeAt()&lt;/code&gt;&lt;/h5&gt;
    
    </summary>
    
      <category term="javascript" scheme="blog.yuanqinglong.cn/categories/javascript/"/>
    
    
      <category term="字符串位置" scheme="blog.yuanqinglong.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>关于 ‘ + ’ 与 new Date</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8E-%E2%80%99-%E2%80%98-%E4%B8%8E-new-Date.html"/>
    <id>blog.yuanqinglong.cn/关于-’-‘-与-new-Date.html</id>
    <published>2018-03-09T13:35:49.000Z</published>
    <updated>2018-03-13T14:11:54.870Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在读《javascript高级程序设计（第三版）》时，遇到的一行代码<br><code>var start = +new Date()</code>;<br>那么，<code>+new Date()</code>是什么意思？虽然大概有些猜测,但，我还是决定查一查。</p></blockquote><p>Javascript中可以在某个元素前使用<code>+</code>号,<br>这个操作是将该元素转换成<code>Number</code>类型，如果转换失败，会得到<code>NAN</code>.<br><strong>注</strong>：<em>（适当的使用 运算符 可以简化 Number类型的转化过程）</em></p><a id="more"></a><p>所以 <code>+newDate</code>将会调用<code>Data.prototype</code>上的<code>valueOf</code>,<br>而且，查一查MDN，我们也可以知道，<br><code>Data.prototype.valueOf()</code>等价于<code>Date.prototype.getTime()</code>.</p><p>所以下列代码的效果是相同的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(+new Date);</span><br><span class="line">console.log(new Date().getTime());</span><br><span class="line">console.log(new Date().valueOf());</span><br><span class="line">console.log(new Date()*1);</span><br></pre></td></tr></table></figure><p>经过实际测试，以上所有代码都会返回当前时间的总毫秒数,（单纯的 <code>new Date</code>或<code>new Date()</code>会输出GMT时间， 如：Fri Mar 09 2018 22:17:43 GMT+0800 (中国标准时间)）</p><p>实际上，在上述代码中，<br>不止<code>+</code>号，在代码后面加上<code>*1</code>或者<code>/1</code>达到相同的输出效果</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;在读《javascript高级程序设计（第三版）》时，遇到的一行代码&lt;br&gt;&lt;code&gt;var start = +new Date()&lt;/code&gt;;&lt;br&gt;那么，&lt;code&gt;+new Date()&lt;/code&gt;是什么意思？虽然大概有些猜测,但，我还是决定查一查。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Javascript中可以在某个元素前使用&lt;code&gt;+&lt;/code&gt;号,&lt;br&gt;这个操作是将该元素转换成&lt;code&gt;Number&lt;/code&gt;类型，如果转换失败，会得到&lt;code&gt;NAN&lt;/code&gt;.&lt;br&gt;&lt;strong&gt;注&lt;/strong&gt;：&lt;em&gt;（适当的使用 运算符 可以简化 Number类型的转化过程）&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="blog.yuanqinglong.cn/categories/javascript/"/>
    
    
      <category term="逻辑运算符" scheme="blog.yuanqinglong.cn/tags/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>关于ajax，大概需要了解哪些基础性的东西？</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8Eajax%EF%BC%8C%E5%A4%A7%E6%A6%82%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%80%A7%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%9F.html"/>
    <id>blog.yuanqinglong.cn/关于ajax，大概需要了解哪些基础性的东西？.html</id>
    <published>2018-03-03T13:43:07.000Z</published>
    <updated>2018-03-04T12:31:16.586Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人总是健忘的，那么为什么不多动动手呢？比如说把知识记下来。<br>我们总会或有或无的接触ajax技术，那么作为一名学习者，就有必要了解相关的知识</p></blockquote><h3 id="ajax-客户端与服务器端异步的通信的技术-原理"><a href="#ajax-客户端与服务器端异步的通信的技术-原理" class="headerlink" title="ajax(客户端与服务器端异步的通信的技术)原理:"></a>ajax(客户端与服务器端异步的通信的技术)原理:</h3><p>相当于在用户和服务器之间加了—个中间层(AJAX引擎),<br>通过创建一个XmlHttpRequest对象来向服务器发异步请求,<br>通过回调在回调函数里进行dom操作.</p><ul><li><p>代码原理：</p><p>1.第一步：创建XMLHttpRequest 对象</p><pre><code>xmlhttp=new XMLHttpRequest();（它有兼容性问题，在ie中用的是new ActiveXObject）</code></pre><p>2.第二步：向服务器发送请求</p><pre><code>xmlhttp.open(&quot;GET/POST&quot;,url,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//POST时要加这句话xmlhttp.send();</code></pre><a id="more"></a><p>3.第三步：执行回调，在回调函数中进行相应的dom操作</p><pre><code>xmlhttp.onreadystatechange=function()  {  if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)//判断状态码    {    //就可以执行相应的dom操作    document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;    }  }</code></pre></li><li><p>readyState有5种值：</p><pre><code>0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪</code></pre></li><li><p>status状态码常见的有：</p><pre><code>200 服务器成功返回301 永久重定向302 临时重定向304 缓存403 服务器拒绝访问404 资源找不到500 服务器错误</code></pre><h3 id="优与劣"><a href="#优与劣" class="headerlink" title="优与劣"></a>优与劣</h3></li><li><h5 id="ajax的优点"><a href="#ajax的优点" class="headerlink" title="ajax的优点:"></a>ajax的优点:</h5><pre><code>&lt;1&gt;.无刷新更新数据。&lt;2&gt;.异步与服务器通信。&lt;3&gt;.前端和后端负载平衡。(减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担)&lt;4&gt;.基于标准被广泛支持。&lt;5&gt;.界面与应用分离。</code></pre></li><li><h5 id="ajax的缺点"><a href="#ajax的缺点" class="headerlink" title="ajax的缺点:"></a>ajax的缺点:</h5><pre><code>&lt;1&gt;.AJAX干掉了Back和History功能，即对浏览器机制的破坏。&lt;2&gt;.AJAX的安全问题。&lt;3&gt;.违背URL和资源定位的初衷。&lt;4&gt;.客户端过肥，太多客户端代码造成开发上的成本。</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;人总是健忘的，那么为什么不多动动手呢？比如说把知识记下来。&lt;br&gt;我们总会或有或无的接触ajax技术，那么作为一名学习者，就有必要了解相关的知识&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;ajax-客户端与服务器端异步的通信的技术-原理&quot;&gt;&lt;a href=&quot;#ajax-客户端与服务器端异步的通信的技术-原理&quot; class=&quot;headerlink&quot; title=&quot;ajax(客户端与服务器端异步的通信的技术)原理:&quot;&gt;&lt;/a&gt;ajax(客户端与服务器端异步的通信的技术)原理:&lt;/h3&gt;&lt;p&gt;相当于在用户和服务器之间加了—个中间层(AJAX引擎),&lt;br&gt;通过创建一个XmlHttpRequest对象来向服务器发异步请求,&lt;br&gt;通过回调在回调函数里进行dom操作.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;代码原理：&lt;/p&gt;&lt;p&gt;1.第一步：创建XMLHttpRequest 对象&lt;/p&gt;&lt;pre&gt;&lt;code&gt;xmlhttp=new XMLHttpRequest();（它有兼容性问题，在ie中用的是new ActiveXObject）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.第二步：向服务器发送请求&lt;/p&gt;&lt;pre&gt;&lt;code&gt;xmlhttp.open(&amp;quot;GET/POST&amp;quot;,url,true);
xmlhttp.setRequestHeader(&amp;quot;Content-type&amp;quot;,&amp;quot;application/x-www-form-urlencoded&amp;quot;);//POST时要加这句话
xmlhttp.send();
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="javascript" scheme="blog.yuanqinglong.cn/categories/javascript/"/>
    
    
      <category term="ajax" scheme="blog.yuanqinglong.cn/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>对CommonJS规范的一些理解</title>
    <link href="blog.yuanqinglong.cn/%E5%AF%B9CommonJS%E8%A7%84%E8%8C%83%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3.html"/>
    <id>blog.yuanqinglong.cn/对CommonJS规范的一些理解.html</id>
    <published>2018-02-28T11:03:21.000Z</published>
    <updated>2018-03-02T02:44:21.336Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>咸鱼了一个寒假，不能再这样了。。。<br>学海无涯啊0.0</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">example.js</span><br><span class="line">var x = 5;</span><br><span class="line">var addX = <span class="keyword">function</span> (value) &#123;</span><br><span class="line"><span class="built_in">return</span> value + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。</p></li><li><p>如果想在多个文件分享变量，必须定义为global对象的属性。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global.warning = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p> 上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。</p></li></ul><a id="more"></a><ul><li><p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 5;</span><br><span class="line">var addX = <span class="keyword">function</span> (value) &#123;</span><br><span class="line"><span class="built_in">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.x = x;</span><br><span class="line">module.exports.addX = addX;</span><br></pre></td></tr></table></figure><p> 上面代码通过module.exports输出变量x和函数addX。</p></li><li><p>require方法用于加载模块。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var example = require(<span class="string">'./example.js'</span>);</span><br><span class="line">console.log(example.x); // 5</span><br><span class="line">console.log(example.addX(1)); // 6</span><br></pre></td></tr></table></figure><p> require方法的详细解释参见《Require命令》一节。</p></li></ul><h4 id="CommonJS模块的特点如下"><a href="#CommonJS模块的特点如下" class="headerlink" title="CommonJS模块的特点如下:"></a>CommonJS模块的特点如下:</h4><blockquote><p>1.所有代码都运行在模块作用域，不会污染全局作用域。<br>2.模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了,以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。<br>3.模块加载的顺序，按照其在代码中出现的顺序。</p></blockquote><h3 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h3><ul><li><p>Node内部提供一个Module构建函数。所有模块都是Module的实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Module(id, parent) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">this.exports = &#123;&#125;;</span><br><span class="line">this.parent = parent;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure></li></ul><p>每个模块内部，都有一个module对象，代表当前模块。它有以下属性。</p><blockquote><p>module.id 模块的识别符，通常是带有绝对路径的模块文件名。<br>module.filename 模块的文件名，带有绝对路径。<br>module.loaded 返回一个布尔值，表示模块是否已经完成加载。<br>module.parent 返回一个对象，表示调用该模块的模块。<br>module.children 返回一个数组，表示该模块要用到的其他模    块。<br>module.exports 表示模块对外输出的值。</p></blockquote><ul><li><p>下面是一个示例文件，最后一行输出module变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var jquery = require(<span class="string">'jquery'</span>);</span><br><span class="line">exports.$ = jquery;</span><br><span class="line">console.log(module);</span><br></pre></td></tr></table></figure><p>执行这个文件，命令行会输出如下信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; id: <span class="string">'.'</span>,</span><br><span class="line">exports: &#123; <span class="string">'$'</span>: [Function] &#125;,</span><br><span class="line">parent: null,</span><br><span class="line">filename: <span class="string">'/path/to/example.js'</span>,</span><br><span class="line">loaded: <span class="literal">false</span>,</span><br><span class="line">children:</span><br><span class="line">[ &#123; id: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">    exports: [Function],</span><br><span class="line">    parent: [Circular],</span><br><span class="line">    filename: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">    loaded: <span class="literal">true</span>,</span><br><span class="line">    children: [],</span><br><span class="line">    paths: [Object] &#125; ],</span><br><span class="line">paths:</span><br><span class="line">[ <span class="string">'/home/user/deleted/node_modules'</span>,</span><br><span class="line">    <span class="string">'/home/user/node_modules'</span>,</span><br><span class="line">    <span class="string">'/home/node_modules'</span>,</span><br><span class="line">    <span class="string">'/node_modules'</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果在命令行下调用某个模块，比如node something.js，那么module.parent就是null。如果是在脚本之中调用，比如require(‘./something.js’)，那么module.parent就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!module.parent) &#123;</span><br><span class="line">      // ran with `node something.js`</span><br><span class="line">      app.listen(8088, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          console.log(<span class="string">'app listening on port 8088'</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      // used with `require(<span class="string">'/.something.js'</span>)`</span><br><span class="line">      module.exports = app;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="module-exports属性"><a href="#module-exports属性" class="headerlink" title="module.exports属性"></a>module.exports属性</h4><ul><li><p>module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var EventEmitter = require(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line">module.exports = new EventEmitter();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">module.exports.emit(<span class="string">'ready'</span>);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><p> 上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = require(<span class="string">'./a'</span>);</span><br><span class="line">a.on(<span class="string">'ready'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">console.log(<span class="string">'module a is ready'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="exports变量"><a href="#exports变量" class="headerlink" title="exports变量"></a>exports变量</h4><ul><li><p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var exports = module.exports;</span><br></pre></td></tr></table></figure><p>  造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports.area = <span class="keyword">function</span> (r) &#123;</span><br><span class="line"><span class="built_in">return</span> Math.PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.circumference = <span class="keyword">function</span> (r) &#123;</span><br><span class="line"><span class="built_in">return</span> 2 * Math.PI * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = <span class="keyword">function</span>(x) &#123;console.log(x)&#125;;</span><br></pre></td></tr></table></figure><p>  上面这样的写法是无效的，因为exports不再指向module.exports了。<br>  下面的写法也是无效的。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.hello = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">'hello'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = <span class="string">'Hello world'</span>;</span><br></pre></td></tr></table></figure><p>  上面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了。<br>  这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = <span class="keyword">function</span> (x)&#123; console.log(x);&#125;;</span><br></pre></td></tr></table></figure><p>  如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。</p></li></ul><h3 id="AMD规范与CommonJS规范的兼容性"><a href="#AMD规范与CommonJS规范的兼容性" class="headerlink" title="AMD规范与CommonJS规范的兼容性"></a>AMD规范与CommonJS规范的兼容性</h3><ul><li><p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。</p><p>  AMD规范使用define方法定义模块，下面就是一个例子：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'package/lib'</span>], <span class="keyword">function</span>(lib)&#123;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>()&#123;</span><br><span class="line">    lib.log(<span class="string">'hello world!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> &#123;</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  AMD规范允许输出的模块兼容CommonJS规范，这时define方法需要写成下面这样：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span> (require, exports, module)&#123;</span><br><span class="line">var someModule = require(<span class="string">"someModule"</span>);</span><br><span class="line">var anotherModule = require(<span class="string">"anotherModule"</span>);</span><br><span class="line"></span><br><span class="line">someModule.doTehAwesome();</span><br><span class="line">anotherModule.doMoarAwesome();</span><br><span class="line"></span><br><span class="line">exports.asplode = <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">    someModule.doTehAwesome();</span><br><span class="line">    anotherModule.doMoarAwesome();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="require命令"><a href="#require命令" class="headerlink" title="require命令"></a>require命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul><li><p>Node使用CommonJS模块规范，内置的require命令用于加载模块文件。</p><p>  require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var invisible = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">console.log(<span class="string">"invisible"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.message = <span class="string">"hi"</span>;</span><br><span class="line"></span><br><span class="line">exports.say = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">console.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行下面的命令，可以输出exports对象。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var example = require(<span class="string">'./example.js'</span>);</span><br><span class="line">example</span><br><span class="line">// &#123;</span><br><span class="line">//   message: <span class="string">"hi"</span>,</span><br><span class="line">//   say: [Function]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p>  如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定在module.exports变量上面。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        module.exports = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(<span class="string">"hello world"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        require(<span class="string">'./example2.js'</span>)()</span><br><span class="line">    ``` </span><br><span class="line">    上面代码中，require命令调用自身，等于是执行module.exports，因此会输出 hello world。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 加载规则</span></span><br><span class="line">-  require命令用于加载文件，后缀名默认为.js。</span><br><span class="line"></span><br><span class="line">    ```bash</span><br><span class="line">        var foo = require(<span class="string">'foo'</span>);</span><br><span class="line">        //  等同于</span><br><span class="line">        var foo = require(<span class="string">'foo.js'</span>);</span><br></pre></td></tr></table></figure><p>  根据参数的不同格式，require命令去不同路径寻找模块文件。</p><p>  （1）如果参数字符串以“<code>/</code>”开头，则表示加载的是一个位于绝对路径的模块文件。比如，<code>require(&#39;/home/marco/foo.js&#39;)</code>将加载<code>/home/marco/foo.js</code>。</p><p>  （2）如果参数字符串以“<code>./</code>”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，<code>require(&#39;./circle&#39;)</code>将加载当前脚本同一目录的<code>circle.js</code>。</p><p>  （3）如果参数字符串不以“<code>./</code>“或”<code>/</code>“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。<br>  <br><br>  举例来说，脚本<code>/home/user/projects/foo.js</code>执行了require<code>(&#39;bar.js&#39;)</code>命令，Node会依次搜索以下文件。</p><blockquote><p>/usr/local/lib/node/bar.js<br>/home/user/projects/node_modules/bar.js<br>/home/user/node_modules/bar.js<br>/home/node_modules/bar.js<br>/node_modules/bar.js</p></blockquote><p>  这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。</p><p>  （4）如果参数字符串不以“<code>./</code>“或”<code>/</code>“开头，而且是一个路径，<br>  比如<code>require(&#39;example-module/path/to/file&#39;)</code>，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</p><p>  （5）如果指定的模块文件没有发现，Node会尝试为文件名添加<code>.js</code>、<code>.json</code>、<code>.node</code>后，再去搜索。<code>.js</code>件会以文本格式的JavaScript脚本文件解析，<code>.json</code>文件会以JSON格式的文本文件解析，<code>.node</code>文件会以编译后的二进制文件解析。</p><p>  （6）如果想得到require命令加载的确切文件名，使用<code>require.resolve()</code>方法。</p></li></ul><h4 id="目录的加载规则"><a href="#目录的加载规则" class="headerlink" title="目录的加载规则"></a>目录的加载规则</h4><ul><li><p>通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录。<br><br><br>在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123; <span class="string">"name"</span> : <span class="string">"some-library"</span>,</span><br><span class="line"><span class="string">"main"</span> : <span class="string">"./lib/some-library.js"</span> &#125;</span><br></pre></td></tr></table></figure><p>require发现参数字符串指向一个目录以后，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件。如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件。</p></li></ul><h4 id="模块的缓存"><a href="#模块的缓存" class="headerlink" title="模块的缓存"></a>模块的缓存</h4><ul><li><p>第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的<code>module.exports</code>属性。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require(<span class="string">'./example.js'</span>);</span><br><span class="line">require(<span class="string">'./example.js'</span>).message = <span class="string">"hello"</span>;</span><br><span class="line">require(<span class="string">'./example.js'</span>).message</span><br><span class="line">// <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><p>  上面代码中，连续三次使用require命令，加载同一个模块。第二次加载的时候，为输出的对象添加了一个message属性。但是第三次加载的时候，这个message属性依然存在，这就证明require命令并没有重新加载模块文件，而是输出了缓存。</p><p>  如果想要多次执行某个模块，可以让该模块输出一个函数，然后每次require这个模块的时候，重新执行一下输出的函数。</p><p>  所有缓存的模块保存在<code>require.cache</code>之中，如果想删除模块的缓存，可以像下面这样写。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 删除指定模块的缓存</span><br><span class="line">delete require.cache[moduleName];</span><br><span class="line"></span><br><span class="line">// 删除所有模块的缓存</span><br><span class="line">Object.keys(require.cache).forEach(<span class="keyword">function</span>(key) &#123;</span><br><span class="line">delete require.cache[key];</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><pre><code>注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，require命令还是会重新加载该模块。</code></pre><h4 id="环境变量NODE-PATH"><a href="#环境变量NODE-PATH" class="headerlink" title="环境变量NODE_PATH"></a>环境变量<code>NODE_PATH</code></h4><ul><li><p>Node执行一个脚本时，会先查看环境变量NODE_PATH。它是一组以冒号分隔的绝对路径。在其他位置找不到指定模块时，Node会去这些路径查找。</p><p>可以将<code>NODE_PATH</code>添加到<code>.bashrc</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NODE_PATH=<span class="string">"/usr/local/lib/node"</span></span><br></pre></td></tr></table></figure><p>所以，如果遇到复杂的相对路径，比如下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myModule = require(<span class="string">'../../../../lib/myModule'</span>);</span><br></pre></td></tr></table></figure><p>有两种解决方法，一是将该文件加入node_modules目录，二是修改NODE_PATH环境变量，package.json文件可以采用下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"node_path"</span>,</span><br><span class="line"><span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line"><span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"NODE_PATH=lib node index.js"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NODE_PATH是历史遗留下来的一个路径解决方案，通常不应该使用，而应该使用node_modules目录机制。</p></li></ul><h4 id="模块的循环加载"><a href="#模块的循环加载" class="headerlink" title="模块的循环加载"></a>模块的循环加载</h4><ul><li><p>如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">exports.x = <span class="string">'a1'</span>;</span><br><span class="line">console.log(<span class="string">'a.js '</span>, require(<span class="string">'./b.js'</span>).x);</span><br><span class="line">exports.x = <span class="string">'a2'</span>;</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">exports.x = <span class="string">'b1'</span>;</span><br><span class="line">console.log(<span class="string">'b.js '</span>, require(<span class="string">'./a.js'</span>).x);</span><br><span class="line">exports.x = <span class="string">'b2'</span>;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./a.js'</span>).x);</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./b.js'</span>).x);</span><br></pre></td></tr></table></figure><p>上面代码是三个JavaScript文件。其中，a.js加载了b.js，而b.js又加载a.js。这时，Node返回a.js的不完整版本，所以执行结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">b.js  a1</span><br><span class="line">a.js  b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2</span><br></pre></td></tr></table></figure><p>修改main.js，再次加载a.js和b.js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./a.js'</span>).x);</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./b.js'</span>).x);</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./a.js'</span>).x);</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./b.js'</span>).x);</span><br></pre></td></tr></table></figure><p>执行上面代码，结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">b.js  a1</span><br><span class="line">a.js  b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2</span><br></pre></td></tr></table></figure><p>上面代码中，第二次加载a.js和b.js时，会直接从缓存读取exports属性，所以a.js和b.js内部的console.log语句都不会执行了。</p></li></ul><h4 id="require-main"><a href="#require-main" class="headerlink" title="require.main"></a>require.main</h4><ul><li><p>require方法有一个main属性，可以用来判断模块是直接执行，还是被调用执行。</p><p>直接执行的时候（node module.js），require.main属性指向模块本身。</p><pre><code>require.main === module// true</code></pre><p>调用执行的时候（通过require加载该脚本执行），上面的表达式返回false。</p></li></ul><h3 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h3><ul><li><p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。</p><p>下面是一个模块文件lib.js。</p><pre><code>// lib.jsvar counter = 3;function incCounter() {counter++;}module.exports = {counter: counter,incCounter: incCounter,};</code></pre><p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。</p><p>然后，加载上面的模块。</p><pre><code>// main.jsvar counter = require(&apos;./lib&apos;).counter;var incCounter = require(&apos;./lib&apos;).incCounter;console.log(counter);  // 3incCounter();console.log(counter); // 3</code></pre><p>上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。</p></li></ul><h4 id="require的内部处理流程"><a href="#require的内部处理流程" class="headerlink" title="require的内部处理流程"></a>require的内部处理流程</h4><ul><li><p>require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module._load = <span class="keyword">function</span>(request, parent, isMain) &#123;</span><br><span class="line">// 1. 检查 Module._cache，是否缓存之中有指定模块</span><br><span class="line">// 2. 如果缓存之中没有，就创建一个新的Module实例</span><br><span class="line">// 3. 将它保存到缓存</span><br><span class="line">// 4. 使用 module.load() 加载指定的模块文件，</span><br><span class="line">//    读取文件内容之后，使用 module.compile() 执行文件代码</span><br><span class="line">// 5. 如果加载/解析过程报错，就从缓存删除该模块</span><br><span class="line">// 6. 返回该模块的 module.exports</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype._compile = <span class="keyword">function</span>(content, filename) &#123;</span><br><span class="line">// 1. 生成一个require函数，指向module.require</span><br><span class="line">// 2. 加载其他辅助方法到require</span><br><span class="line">// 3. 将文件内容放到一个函数之中，该函数可调用 require</span><br><span class="line">// 4. 执行该函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的第1步和第2步，require函数及其辅助方法主要如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require(): 加载外部模块</span><br><span class="line">require.resolve()：将模块名解析到一个绝对路径</span><br><span class="line">require.main：指向主模块</span><br><span class="line">require.cache：指向所有缓存的模块</span><br><span class="line">require.extensions：根据文件的后缀名，调用不同的执行函数</span><br></pre></td></tr></table></figure><p>一旦require函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括require、module、exports，以及其他一些参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">// YOUR CODE INJECTED HERE!</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Module._compile方法是同步执行的，所以Module._load要等它执行完成，才会向用户返回module.exports的值。</p></li></ul><blockquote><p>本文引自阮一峰的文章<br>受益匪浅，由是感激！<br>链接：<a href="http://javascript.ruanyifeng.com/nodejs/module.html#" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/module.html#</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;咸鱼了一个寒假，不能再这样了。。。&lt;br&gt;学海无涯啊0.0&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;example.js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var x = 5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var addX = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (value) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; value + x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果想在多个文件分享变量，必须定义为global对象的属性。&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;global.warning = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CommonJS" scheme="blog.yuanqinglong.cn/tags/CommonJS/"/>
    
  </entry>
  
  <entry>
    <title>关于ES6 const 篇</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8EES6-const-%E7%AF%87.html"/>
    <id>blog.yuanqinglong.cn/关于ES6-const-篇.html</id>
    <published>2018-02-02T13:19:24.000Z</published>
    <updated>2018-02-13T10:11:27.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》<br>原文链接：<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/let</a><br>学海无涯，愿与诸君共勉</p></blockquote><h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><ul><li>const声明一个只读的常量。一旦声明，常量的值就不能改变。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const PI = 3.1415;</span><br><span class="line">PI // 3.1415</span><br><span class="line"></span><br><span class="line">PI = 3;</span><br><span class="line">// TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure></li></ul><p>上面代码表明改变常量的值会报错。<br><a id="more"></a><br>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const foo;</span><br><span class="line">// SyntaxError: Missing initializer <span class="keyword">in</span> const declaration</span><br></pre></td></tr></table></figure><p></p><p>上面代码表示，对于const来说，只声明不赋值，就会报错。</p><ul><li><p>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MAX // Uncaught ReferenceError: MAX is not defined</span><br></pre></td></tr></table></figure></li><li><p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  console.log(MAX); // ReferenceError</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面代码在常量MAX声明之前就调用，结果报错。</p><ul><li>const声明的常量，也与let一样不可重复声明。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var message = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="built_in">let</span> age = 25;</span><br><span class="line"></span><br><span class="line">// 以下两行都会报错</span><br><span class="line">const message = <span class="string">"Goodbye!"</span>;</span><br><span class="line">const age = 30;</span><br></pre></td></tr></table></figure></li></ul><h5 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h5><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 为 foo 添加一个属性，可以成功</span><br><span class="line">foo.prop = 123;</span><br><span class="line">foo.prop // 123</span><br><span class="line"></span><br><span class="line">// 将 foo 指向另一个对象，就会报错</span><br><span class="line">foo = &#123;&#125;; // TypeError: <span class="string">"foo"</span> is <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><p>下面是另一个例子。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); // 可执行</span><br><span class="line">a.length = 0;    // 可执行</span><br><span class="line">a = [<span class="string">'Dave'</span>];    // 报错</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。</p><p>如果真的想将对象冻结，应该使用Object.freeze方法。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const foo = Object.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">// 常规模式时，下面一行不起作用；</span><br><span class="line">// 严格模式时，该行会报错</span><br><span class="line">foo.prop = 123;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var constantize = (obj) =&gt; &#123;</span><br><span class="line">  Object.freeze(obj);</span><br><span class="line">  Object.keys(obj).forEach( (key, i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> ( typeof obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h5 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h5><p>ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。</p><ul><li><h5 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h5>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.a = 1;</span><br><span class="line">a // 1</span><br><span class="line"></span><br><span class="line">a = 2;</span><br><span class="line">window.a // 2</span><br></pre></td></tr></table></figure></li></ul><p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p><p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">// 如果在 Node 的 REPL 环境，可以写成 global.a</span><br><span class="line">// 或者采用通用方法，写成 this.a</span><br><span class="line">window.a // 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = 1;</span><br><span class="line">window.b // undefined</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。</p><ul><li><h5 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h5>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</li></ul><p>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。<br>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。<br>Node 里面，顶层对象是global，但其他环境都不支持。<br>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</p><p>全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。<br>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。<br>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。<br>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 方法一</span><br><span class="line">(typeof window !== <span class="string">'undefined'</span></span><br><span class="line">   ? window</span><br><span class="line">   : (typeof process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      typeof require === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      typeof global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : this);</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">var getGlobal = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (typeof self !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (typeof window !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> window; &#125;</span><br><span class="line">  <span class="keyword">if</span> (typeof global !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> global; &#125;</span><br><span class="line">  throw new Error(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。</p><p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// CommonJS 的写法</span><br><span class="line">require(<span class="string">'system.global/shim'</span>)();</span><br><span class="line"></span><br><span class="line">// ES6 模块的写法</span><br><span class="line">import shim from <span class="string">'system.global/shim'</span>; shim();</span><br><span class="line">上面代码可以保证各种环境里面，global对象都是存在的。</span><br><span class="line"></span><br><span class="line">// CommonJS 的写法</span><br><span class="line">var global = require(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line">// ES6 模块的写法</span><br><span class="line">import getGlobal from <span class="string">'system.global'</span>;</span><br><span class="line">const global = getGlobal();</span><br></pre></td></tr></table></figure><p></p><p>上面代码将顶层对象放入变量global。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》&lt;br&gt;原文链接：&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://es6.ruanyifeng.com/#docs/let&lt;/a&gt;&lt;br&gt;学海无涯，愿与诸君共勉&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;const-命令&quot;&gt;&lt;a href=&quot;#const-命令&quot; class=&quot;headerlink&quot; title=&quot;const 命令&quot;&gt;&lt;/a&gt;const 命令&lt;/h3&gt;&lt;h5 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h5&gt;&lt;ul&gt;&lt;li&gt;const声明一个只读的常量。一旦声明，常量的值就不能改变。&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const PI = 3.1415;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PI // 3.1415&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PI = 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// TypeError: Assignment to constant variable.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面代码表明改变常量的值会报错。&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="blog.yuanqinglong.cn/categories/ES6/"/>
    
    
      <category term="const" scheme="blog.yuanqinglong.cn/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>关于ES6 : let 篇 </title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8EES6-let-%E7%AF%87.html"/>
    <id>blog.yuanqinglong.cn/关于ES6-let-篇.html</id>
    <published>2018-01-27T12:26:15.000Z</published>
    <updated>2018-02-13T10:11:05.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》<br>原文链接：<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/let</a><br>学海无涯，愿与诸君共勉</p></blockquote><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul><li><h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在<br>let命令所在的代码块内有效。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">let</span> a = 10;</span><br><span class="line">   var b = 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a // ReferenceError: a is not defined.</span><br><span class="line">b // 1</span><br></pre></td></tr></table></figure></li></ul><p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。<br><a id="more"></a><br>for循环的计数器，就很合适使用let命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i);</span><br><span class="line">// ReferenceError: i is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。</p><p>下面的代码如果使用var，最后输出的是10。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br></pre></td></tr></table></figure><p>上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。</p><p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p><p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  <span class="built_in">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br></pre></td></tr></table></figure><p></p><p>上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p><ul><li><h5 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h5>var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。<br>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// var 的情况</span><br><span class="line">console.log(foo); // 输出undefined</span><br><span class="line">var foo = 2;</span><br><span class="line"></span><br><span class="line">// <span class="built_in">let</span> 的情况</span><br><span class="line">console.log(bar); // 报错ReferenceError</span><br><span class="line"><span class="built_in">let</span> bar = 2;</span><br></pre></td></tr></table></figure></li></ul><p>上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</p><ul><li><h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; // ReferenceError</span><br><span class="line">  <span class="built_in">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  // TDZ开始</span><br><span class="line">  tmp = <span class="string">'abc'</span>; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> tmp; // TDZ结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。</p><p>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof x; // ReferenceError</span><br><span class="line"><span class="built_in">let</span> x;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。</p><p>作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof undeclared_variable // <span class="string">"undefined"</span></span><br></pre></td></tr></table></figure><p>上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p><p>有些“死区”比较隐蔽，不太容易发现。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bar(x = y, y = 2) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // 报错</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bar(x = 2, y = x) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); // [2, 2]</span><br></pre></td></tr></table></figure><p></p><p>另外，下面的代码也会报错，与var的行为不同。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">var x = x;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="built_in">let</span> x = x;</span><br><span class="line">// ReferenceError: x is not defined</span><br></pre></td></tr></table></figure><p></p><p>上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。</p><p>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><ul><li><h5 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h5>let不允许在相同作用域内，重复声明同一个变量。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> a = 10;</span><br><span class="line">  var a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> a = 10;</span><br><span class="line">  <span class="built_in">let</span> a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>因此，不能在函数内部重新声明参数。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> func(arg) &#123;</span><br><span class="line">  <span class="built_in">let</span> arg; // 报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> func(arg) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">let</span> arg; // 不报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><h5 id="块级作用域-1"><a href="#块级作用域-1" class="headerlink" title="块级作用域"></a>块级作用域</h5>为什么需要块级作用域？<br>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</li></ul><p>第一种场景，内层变量可能会覆盖外层变量。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    var tmp = <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure><p></p><p>上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><p>ES6 的块级作用域<br>let实际上为 JavaScript 新增了块级作用域。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> n = 5;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">let</span> n = 10;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(n); // 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。</p><p>ES6 允许块级作用域的任意嵌套。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p></p><p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">  console.log(insane); // 报错</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p></p><p>内层作用域可以定义外层作用域的同名变量。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="built_in">let</span> insane = <span class="string">'Hello World'</span>;</span><br><span class="line">  &#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p></p><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// IIFE 写法</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  var tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 块级作用域写法</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><h5 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h5>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</li></ul><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 情况一</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二</span><br><span class="line">try &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面两种函数声明，根据 ES5 的规定都是非法的。</p><p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    // 重复声明一次函数f</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p></p><p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ES5 环境</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p></p><p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p><p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p><p>允许在块级作用域内声明函数。<br>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。<br>同时，函数声明还会提升到所在的块级作用域的头部。<br>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p><p>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。</p><p>// 浏览器的 ES6 环境<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    // 重复声明一次函数f</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line">// Uncaught TypeError: f is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p></p><p>上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器的 ES6 环境</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  var f = undefined;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line">// Uncaught TypeError: f is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p></p><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明语句</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="built_in">let</span> f = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》&lt;br&gt;原文链接：&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://es6.ruanyifeng.com/#docs/let&lt;/a&gt;&lt;br&gt;学海无涯，愿与诸君共勉&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;h5 id=&quot;块级作用域&quot;&gt;&lt;a href=&quot;#块级作用域&quot; class=&quot;headerlink&quot; title=&quot;块级作用域&quot;&gt;&lt;/a&gt;块级作用域&lt;/h5&gt;ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在&lt;br&gt;let命令所在的代码块内有效。&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; a = 10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   var b = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a // ReferenceError: a is not defined.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b // 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="blog.yuanqinglong.cn/categories/ES6/"/>
    
    
      <category term="let" scheme="blog.yuanqinglong.cn/tags/let/"/>
    
  </entry>
  
  <entry>
    <title>关于object.key与object[key]的区别</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8Eobject-key%E4%B8%8Eobject-key-%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
    <id>blog.yuanqinglong.cn/关于object-key与object-key-的区别.html</id>
    <published>2018-01-24T07:01:27.000Z</published>
    <updated>2018-01-24T08:29:00.834Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录所需要的，摒弃多余的。<br>本篇文章是对segmentfault的一个问答的总结。</p></blockquote><h2 id="obeject-key与object-key-有什么区别"><a href="#obeject-key与object-key-有什么区别" class="headerlink" title="obeject.key与object[key]有什么区别?"></a>obeject.key与object[key]有什么区别?</h2><p>有什么区别，不试试怎么知道？</p><h5 id="测试代码（其实有很多栗子，随便举一个）："><a href="#测试代码（其实有很多栗子，随便举一个）：" class="headerlink" title="测试代码（其实有很多栗子，随便举一个）："></a>测试代码（其实有很多栗子，随便举一个）：</h5><pre><code> var obj = {    name: &apos;tom&apos;,    age: 22},someKey = &apos;age&apos;;        console.log(obj.name);   console.log(obj[&apos;name&apos;]); console.log(obj.someKey);  console.log(obj[someKey]);  </code></pre><a id="more"></a><h5 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h5><p>（放图）<br><img src="../imgs/blogContentImgs/2018-1-24-01.png" alt="Alt text" title="node 运行截图"></p><h5 id="通常来讲，-obj-“key”-与-obj-key-的作用差不多，但是，"><a href="#通常来讲，-obj-“key”-与-obj-key-的作用差不多，但是，" class="headerlink" title="通常来讲， obj[“key”]  与 obj.key 的作用差不多，但是，"></a>通常来讲， <em>obj[“key”]</em> 与 <em>obj.key</em> 的作用差不多，但是，</h5><ul><li>如果key不确定（key是变量）的情况下，</li><li>或者key的写法比较特殊（比如包含空格什么的）</li></ul><h5 id="则只能通过obj-的方式去访问"><a href="#则只能通过obj-的方式去访问" class="headerlink" title="则只能通过obj[ ]的方式去访问"></a>则只能通过<code>obj[ ]</code>的方式去访问</h5>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;记录所需要的，摒弃多余的。&lt;br&gt;本篇文章是对segmentfault的一个问答的总结。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;obeject-key与object-key-有什么区别&quot;&gt;&lt;a href=&quot;#obeject-key与object-key-有什么区别&quot; class=&quot;headerlink&quot; title=&quot;obeject.key与object[key]有什么区别?&quot;&gt;&lt;/a&gt;obeject.key与object[key]有什么区别?&lt;/h2&gt;&lt;p&gt;有什么区别，不试试怎么知道？&lt;/p&gt;&lt;h5 id=&quot;测试代码（其实有很多栗子，随便举一个）：&quot;&gt;&lt;a href=&quot;#测试代码（其实有很多栗子，随便举一个）：&quot; class=&quot;headerlink&quot; title=&quot;测试代码（其实有很多栗子，随便举一个）：&quot;&gt;&lt;/a&gt;测试代码（其实有很多栗子，随便举一个）：&lt;/h5&gt;&lt;pre&gt;&lt;code&gt; var obj = {
    name: &amp;apos;tom&amp;apos;,
    age: 22
},
someKey = &amp;apos;age&amp;apos;;        

console.log(obj.name);   
console.log(obj[&amp;apos;name&amp;apos;]); 
console.log(obj.someKey);  
console.log(obj[someKey]);  
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="json" scheme="blog.yuanqinglong.cn/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>Markdown常用语法</title>
    <link href="blog.yuanqinglong.cn/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html"/>
    <id>blog.yuanqinglong.cn/Markdown常用语法.html</id>
    <published>2018-01-22T12:49:29.000Z</published>
    <updated>2018-01-24T07:48:08.540Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写博客，自然免不了接触<strong>Markdown</strong>,作为初学者，为了即用即查，我决定把相关命令记录下来，本文就是边学边写<br>此处声明：本文是 <strong>参考他人的文章</strong>&amp;<strong>结合实践</strong>后，所写，另外，转载、复制随意，但请务必<strong>注明本文链接</strong></p></blockquote><h1 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h1><p>写法:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># h1级标题</span></span><br><span class="line"><span class="comment">## h2级标题</span></span><br><span class="line"><span class="comment">### h3级标题</span></span><br><span class="line"><span class="comment">#### h4级标题</span></span><br><span class="line"><span class="comment">##### h5级标题</span></span><br><span class="line"><span class="comment">###### h6级标题</span></span><br></pre></td></tr></table></figure><p></p><p>栗子：</p><ul><li><h4 id="这是一个h4级标题"><a href="#这是一个h4级标题" class="headerlink" title="这是一个h4级标题"></a>这是一个h4级标题</h4></li></ul><p>注意：</p><ul><li><code>#</code>与标题文字间要有<strong>空格</strong></li><li>当<code>-</code>与<code>#</code>结合使用时，如果不想下一行受到干扰，可以使用<kbd>Enter</kbd>换行   </li></ul><hr><a id="more"></a><h1 id="分割线："><a href="#分割线：" class="headerlink" title="分割线："></a>分割线：</h1><p>连续三个&amp;三个以上的<code>-</code> 即可作出分割线</p><h4 id="写法"><a href="#写法" class="headerlink" title="写法:"></a>写法:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="栗子："><a href="#栗子：" class="headerlink" title="栗子："></a>栗子：</h4><hr><p>注意：建议写分割线时，与上一行留出一空行</p><hr><h1 id="超链接："><a href="#超链接：" class="headerlink" title="超链接："></a>超链接：</h1><h4 id="写法1："><a href="#写法1：" class="headerlink" title="写法1："></a>写法1：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[连接名称](网址 , 标题)</span><br><span class="line"></span><br><span class="line">[baidu](https://www.baidu.com, <span class="string">"baidu"</span>)</span><br><span class="line">[&lt;i class=<span class="string">"icon-refresh"</span>&gt;&lt;/i&gt; 点我刷新](/<span class="comment">#)</span></span><br></pre></td></tr></table></figure><h4 id="栗子：-1"><a href="#栗子：-1" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><a href="https://www.baidu.com," title="baidu" target="_blank" rel="noopener">baidu</a></li><li><a href="/#"><i class="icon-refresh"></i> 点我刷新</a></li></ul><h4 id="写法2："><a href="#写法2：" class="headerlink" title="写法2："></a>写法2：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[链接名][链接代号]</span><br><span class="line">[链接代号]:详细地址</span><br><span class="line"></span><br><span class="line">[here][3]</span><br><span class="line">[3]: http://www.baidu.com</span><br></pre></td></tr></table></figure><h4 id="栗子：-2"><a href="#栗子：-2" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><a href="http://www.baidu.com" target="_blank" rel="noopener">here</a></li></ul><h4 id="写法3："><a href="#写法3：" class="headerlink" title="写法3："></a>写法3：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接展示链接：&lt;http://www.baidu.com&gt;</span><br></pre></td></tr></table></figure><h4 id="栗子：-3"><a href="#栗子：-3" class="headerlink" title="栗子："></a>栗子：</h4><ul><li>直接展示链接：<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li></ul><hr><h1 id="键盘键"><a href="#键盘键" class="headerlink" title="键盘键"></a>键盘键</h1><h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;kbd&gt;Ctrl+[&lt;/kbd&gt; and &lt;kbd&gt;Ctrl+]&lt;/kbd&gt;</span><br></pre></td></tr></table></figure><h4 id="栗子：-4"><a href="#栗子：-4" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><kbd>Ctrl+[</kbd> and <kbd>Ctrl+]</kbd></li></ul><hr><h1 id="code格式："><a href="#code格式：" class="headerlink" title="code格式："></a>code格式：</h1><p>反引号</p><h4 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Use the `<span class="built_in">printf</span>()` <span class="keyword">function</span>.</span><br><span class="line"> ``There is a literal backtick (`) here.针对在代码区段内插入反引号的情况`</span><br></pre></td></tr></table></figure><h4 id="栗子：-5"><a href="#栗子：-5" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><p>Use the <code>printf()</code> function.</p></li><li><p><code>There is a literal backtick (`) here.针对在代码区段内插入反引号的情况</code> </p></li></ul><hr><h1 id="强调："><a href="#强调：" class="headerlink" title="强调："></a>强调：</h1><h4 id="用法：-2"><a href="#用法：-2" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*斜体强调*</span><br><span class="line">**粗体强调**</span><br></pre></td></tr></table></figure><h4 id="栗子：-6"><a href="#栗子：-6" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><em>斜体强调</em></li><li><strong>粗体强调</strong></li></ul><hr><h1 id="图片："><a href="#图片：" class="headerlink" title="图片："></a>图片：</h1><h4 id="用法：-3"><a href="#用法：-3" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](../imgs/blogContentImgs/jhvh.jpg <span class="string">"这图我觉得扣得不错"</span>)</span><br><span class="line">如果图片链接失效的话，会显示 Alt text</span><br></pre></td></tr></table></figure><h4 id="栗子：-7"><a href="#栗子：-7" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><img src="../imgs/jhvh.jpg" alt="Alt text" title="这图我觉得扣得不错"></li></ul><h1 id="使用-icon-图标文字："><a href="#使用-icon-图标文字：" class="headerlink" title="使用 icon 图标文字："></a>使用 icon 图标文字：</h1><h4 id="用法：-4"><a href="#用法：-4" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=<span class="string">"fa fa-github"</span>&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure><h4 id="栗子：-8"><a href="#栗子：-8" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><i class="fa fa-github"></i></li></ul><hr><h1 id="段落："><a href="#段落：" class="headerlink" title="段落："></a>段落：</h1><p> 以一个空行开始，以一个空行结束，中间的就是一个段落。</p><hr><h1 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h1><h4 id="用法：-5"><a href="#用法：-5" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Item     | Value</span><br><span class="line">-------- | ---</span><br><span class="line">Computer | <span class="variable">$1600</span></span><br><span class="line">Phone    | <span class="variable">$12</span></span><br><span class="line">Pipe     | <span class="variable">$1</span></span><br></pre></td></tr></table></figure><h4 id="栗子：-9"><a href="#栗子：-9" class="headerlink" title="栗子："></a>栗子：</h4><table><thead><tr><th>Item</th><th>Value</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><hr><h1 id="无序列表："><a href="#无序列表：" class="headerlink" title="无序列表："></a>无序列表：</h1><p>使用 - 加一个空格</p><h4 id="用法：-6"><a href="#用法：-6" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 无需列表1</span><br><span class="line">- 无序列表2</span><br><span class="line">- 无序列表3</span><br></pre></td></tr></table></figure><h4 id="栗子：-10"><a href="#栗子：-10" class="headerlink" title="栗子："></a>栗子：</h4><ul><li>无需列表1</li><li>无序列表2</li><li>无序列表3</li></ul><hr><h1 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a>有序列表：</h1><p>使用 数字 加一个英文句点</p><h4 id="用法：-7"><a href="#用法：-7" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表</span><br><span class="line">2. 有序列表</span><br><span class="line">3. 有序列表</span><br><span class="line">4. 有序列表</span><br><span class="line">5. 有序列表</span><br></pre></td></tr></table></figure><h4 id="栗子：-11"><a href="#栗子：-11" class="headerlink" title="栗子："></a>栗子：</h4><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><hr><h1 id="换行缩进形成代码区块："><a href="#换行缩进形成代码区块：" class="headerlink" title="换行缩进形成代码区块："></a>换行缩进形成代码区块：</h1><h4 id="用法：-8"><a href="#用法：-8" class="headerlink" title="用法："></a>用法：</h4><pre><code>这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。    </code></pre><h4 id="栗子：-12"><a href="#栗子：-12" class="headerlink" title="栗子："></a>栗子：</h4><pre><code>这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。    </code></pre><hr><h1 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h1><h4 id="用法：-9"><a href="#用法：-9" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;给引用的文本开始位置都加一个 <span class="string">'&gt;'</span>，</span><br><span class="line">&gt;便可组成一个块引用。在块引用中，可以结合</span><br><span class="line">&gt;其他markdown元素一块使用，比如列表。</span><br><span class="line">&gt;**强调**</span><br><span class="line">也可以只在第一行加大于号，其他位置不加。</span><br><span class="line"></span><br><span class="line">&gt;- 块引用里使用列表，需要和上面的内容隔开一个空行</span><br><span class="line">&gt;- 记得加空格哦。</span><br></pre></td></tr></table></figure><h4 id="栗子：-13"><a href="#栗子：-13" class="headerlink" title="栗子："></a>栗子：</h4><blockquote><p>给引用的文本开始位置都加一个 ‘&gt;’，<br>便可组成一个块引用。在块引用中，可以结合<br>其他markdown元素一块使用，比如列表。<br><strong>强调</strong><br>也可以只在第一行加大于号，其他位置不加。</p><ul><li>块引用里使用列表，需要和上面的内容隔开一个空行</li><li>记得加空格哦。</li></ul></blockquote><hr><blockquote><p>本文参考链接：<br>[掌握这几种 Markdown 语法你就够了]<br><a href="https://laravel-china.org/topics/621/you-will-be-able-to-master-these-markdown-grammars" target="_blank" rel="noopener">https://laravel-china.org/topics/621/you-will-be-able-to-master-these-markdown-grammars</a><br>[中文文案排版指北]<br>:<a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">https://github.com/sparanoid/chinese-copywriting-guidelines</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;写博客，自然免不了接触&lt;strong&gt;Markdown&lt;/strong&gt;,作为初学者，为了即用即查，我决定把相关命令记录下来，本文就是边学边写&lt;br&gt;此处声明：本文是 &lt;strong&gt;参考他人的文章&lt;/strong&gt;&amp;amp;&lt;strong&gt;结合实践&lt;/strong&gt;后，所写，另外，转载、复制随意，但请务必&lt;strong&gt;注明本文链接&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;标题：&quot;&gt;&lt;a href=&quot;#标题：&quot; class=&quot;headerlink&quot; title=&quot;标题：&quot;&gt;&lt;/a&gt;标题：&lt;/h1&gt;&lt;p&gt;写法:&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# h1级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## h2级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;### h3级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#### h4级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;##### h5级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;###### h6级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;栗子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;这是一个h4级标题&quot;&gt;&lt;a href=&quot;#这是一个h4级标题&quot; class=&quot;headerlink&quot; title=&quot;这是一个h4级标题&quot;&gt;&lt;/a&gt;这是一个h4级标题&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt;与标题文字间要有&lt;strong&gt;空格&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;-&lt;/code&gt;与&lt;code&gt;#&lt;/code&gt;结合使用时，如果不想下一行受到干扰，可以使用&lt;kbd&gt;Enter&lt;/kbd&gt;换行   &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="Markdown" scheme="blog.yuanqinglong.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>原生JS实现jQuery的addClass, removeClass, hasClass函数功能</title>
    <link href="blog.yuanqinglong.cn/%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0jQuery%E7%9A%84addClass,%20removeClass,%20hasClass%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD.html"/>
    <id>blog.yuanqinglong.cn/原生JS实现jQuery的addClass, removeClass, hasClass函数功能.html</id>
    <published>2018-01-20T15:21:08.000Z</published>
    <updated>2018-01-23T03:24:21.892Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-addClass"><a href="#1-addClass" class="headerlink" title="- [1] addClass"></a>- [1] addClass</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function addClass(obj, cls)&#123;</span><br><span class="line">    var obj_class = obj.className;//获取 class 内容.</span><br><span class="line">    var blank = (obj_class != &apos;&apos;) ? &apos; &apos; : &apos;&apos;;//判断获取到的 class 是否为空, 如果不为空在前面加个&apos;空格&apos;.</span><br><span class="line">    var added = obj_class + blank + cls;//组合原来的 class 和需要添加的 class.</span><br><span class="line">    obj.className = added;//替换原来的 class.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-removeClass"><a href="#2-removeClass" class="headerlink" title="- [2]  removeClass"></a>- [2]  removeClass</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function removeClass(obj, cls)&#123;</span><br><span class="line">    var obj_class = &apos; &apos;+obj.className+&apos; &apos;;//获取 class 内容, 并在首尾各加一个空格. ex) &apos;abc        bcd&apos; -&gt; &apos; abc        bcd &apos;</span><br><span class="line">    obj_class = obj_class.replace(/(\s+)/gi, &apos; &apos;),//将多余的空字符替换成一个空格. ex) &apos; abc        bcd &apos; -&gt; &apos; abc bcd &apos;</span><br><span class="line">    var removed = obj_class.replace(&apos; &apos;+cls+&apos; &apos;, &apos; &apos;);//在原来的 class 替换掉首尾加了空格的 class. ex) &apos; abc bcd &apos; -&gt; &apos;bcd &apos;</span><br><span class="line">    removed = removed.replace(/(^\s+)|(\s+$)/g, &apos;&apos;);//去掉首尾空格. ex) &apos;bcd &apos; -&gt; &apos;bcd&apos;</span><br><span class="line">    obj.className = removed;//替换原来的 class.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-hasClass"><a href="#3-hasClass" class="headerlink" title="- [3]  hasClass"></a>- [3]  hasClass</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function hasClass(obj, cls)&#123;</span><br><span class="line">    var obj_class = obj.className;//获取 class 内容.</span><br><span class="line">    var obj_class_lst = obj_class.split(/\s+/);//通过split空字符将cls转换成数组.</span><br><span class="line">    var x = 0;</span><br><span class="line">    for(x in obj_class_lst) &#123;</span><br><span class="line">        if(obj_class_lst[x] == cls) &#123;//循环数组, 判断是否包含cls</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="原文链接-link"><a href="#原文链接-link" class="headerlink" title="==原文链接   ++link++=="></a>==<strong>原文链接</strong>   ++<a href="https://lvwenhan.com/web-front/374.html" target="_blank" rel="noopener">link</a>++==</h6><blockquote><h4 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h4></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断样式是否存在</span><br><span class="line"> */</span><br><span class="line">function hasClass(obj, cls) &#123;</span><br><span class="line">  return obj.className.match(new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 为指定的dom元素添加样式</span><br><span class="line"> */</span><br><span class="line">function addClass(obj, cls) &#123;</span><br><span class="line">  if (!this.hasClass(obj, cls)) obj.className += &quot; &quot; + cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除指定dom元素的样式</span><br><span class="line"> */</span><br><span class="line">function removeClass(obj, cls) &#123;</span><br><span class="line">  if (hasClass(obj, cls)) &#123;</span><br><span class="line">    var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;);</span><br><span class="line">    obj.className = obj.className.replace(reg, &apos; &apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果存在(不存在)，就删除(添加)一个样式</span><br><span class="line"> */</span><br><span class="line">function toggleClass(obj, cls) &#123;</span><br><span class="line">  if (hasClass(obj, cls)) &#123;</span><br><span class="line">    removeClass(obj, cls);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    addClass(obj, cls);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="原文链接-link-1"><a href="#原文链接-link-1" class="headerlink" title="==原文链接   ++link++=="></a>==<strong>原文链接</strong>   ++<a href="http://www.edaoe.com/560.html" target="_blank" rel="noopener">link</a>++==</h6>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-addClass&quot;&gt;&lt;a href=&quot;#1-addClass&quot; class=&quot;headerlink&quot; title=&quot;- [1] addClass&quot;&gt;&lt;/a&gt;- [1] addClass&lt;/h4&gt;&lt;hr&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function addClass(obj, cls)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var obj_class = obj.className;//获取 class 内容.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var blank = (obj_class != &amp;apos;&amp;apos;) ? &amp;apos; &amp;apos; : &amp;apos;&amp;apos;;//判断获取到的 class 是否为空, 如果不为空在前面加个&amp;apos;空格&amp;apos;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var added = obj_class + blank + cls;//组合原来的 class 和需要添加的 class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj.className = added;//替换原来的 class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jquery" scheme="blog.yuanqinglong.cn/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>css解决背景透明的兼容性问题</title>
    <link href="blog.yuanqinglong.cn/css%E8%A7%A3%E5%86%B3%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98.html"/>
    <id>blog.yuanqinglong.cn/css解决背景透明的兼容性问题.html</id>
    <published>2018-01-19T01:33:33.000Z</published>
    <updated>2018-01-22T12:54:39.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全浏览器兼容背景半透明的问题的么几个解决方案："><a href="#全浏览器兼容背景半透明的问题的么几个解决方案：" class="headerlink" title="全浏览器兼容背景半透明的问题的么几个解决方案："></a>全浏览器兼容背景半透明的问题的么几个解决方案：</h3><h5 id="1-使用半透明png图片平铺"><a href="#1-使用半透明png图片平铺" class="headerlink" title="1.使用半透明png图片平铺"></a>1.使用半透明png图片平铺</h5><h5 id="2-使用opcacity属性"><a href="#2-使用opcacity属性" class="headerlink" title="2.使用opcacity属性"></a>2.使用opcacity属性</h5><h5 id="3-使用rgba和IE的opacity滤镜属性结合"><a href="#3-使用rgba和IE的opacity滤镜属性结合" class="headerlink" title="3.使用rgba和IE的opacity滤镜属性结合"></a>3.使用rgba和IE的opacity滤镜属性结合</h5><a id="more"></a><h4 id="RGBA颜色"><a href="#RGBA颜色" class="headerlink" title="RGBA颜色"></a>RGBA颜色</h4><hr><p>rgba颜色的四个属性分别表示 red红色、green绿色、blue蓝色、alpha透明度。通过这几个数值能够轻松实现背景透明。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.backTtansparent&#123;</span><br><span class="line">/* 用于不支持RGBa的浏览器 */</span><br><span class="line">background: rgb(0, 0, 0);</span><br><span class="line">/* RGBa, 透明度0.6 */</span><br><span class="line">background: rgba(0, 0, 0, 0.6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样透明只对背景生效，对于非 ie 浏览器是非常完美的解决方案。<br>不幸的是 ie8 及以下不支持 rgba 属性，并且经测试 ie9 会把 rgba 解析为全透明。</p><h4 id="IE的filter"><a href="#IE的filter" class="headerlink" title="IE的filter"></a>IE的filter</h4><hr><p>通过background: transparent注释可解决 ie9 解析rgba全透明问题。通过ie 的 filter 属性便可让 ie 支持背景透明。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.backTtansparent&#123;</span><br><span class="line">background: transparent/9;</span><br><span class="line">/* For IE 5.5 - 7*/</span><br><span class="line">filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);</span><br><span class="line">/* For IE 8*/</span><br><span class="line">-ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>能够看到filter中的8位16进制的半透明颜色#99000000为argb颜色，既#AARRGGBB，前两位是透明度，后面分别是红绿蓝。</li><li>如果我们希望透明度为 0.6，则需要将 0.6 乘以 255,再转化为 16 进制。最简单的方法是利用 JavaScript，在浏览器的调试面板里输入：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Math.floor(0.6 * 255).toString(16);</span><br></pre></td></tr></table></figure><ul><li>回车后可以看到结果为99。这样透明度0.6的黑色的argb颜色即为#99000000。<h4 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h4></li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">background: rgb(0, 0, 0);</span><br><span class="line">    /* RGBa with 0.6 opacity */</span><br><span class="line">    background: rgba(0, 0, 0, 0.6);</span><br><span class="line">    /* For IE 5.5 - 7*/</span><br><span class="line">    filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);</span><br><span class="line">    /* For IE 8*/</span><br><span class="line">    -ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;全浏览器兼容背景半透明的问题的么几个解决方案：&quot;&gt;&lt;a href=&quot;#全浏览器兼容背景半透明的问题的么几个解决方案：&quot; class=&quot;headerlink&quot; title=&quot;全浏览器兼容背景半透明的问题的么几个解决方案：&quot;&gt;&lt;/a&gt;全浏览器兼容背景半透明的问题的么几个解决方案：&lt;/h3&gt;&lt;h5 id=&quot;1-使用半透明png图片平铺&quot;&gt;&lt;a href=&quot;#1-使用半透明png图片平铺&quot; class=&quot;headerlink&quot; title=&quot;1.使用半透明png图片平铺&quot;&gt;&lt;/a&gt;1.使用半透明png图片平铺&lt;/h5&gt;&lt;h5 id=&quot;2-使用opcacity属性&quot;&gt;&lt;a href=&quot;#2-使用opcacity属性&quot; class=&quot;headerlink&quot; title=&quot;2.使用opcacity属性&quot;&gt;&lt;/a&gt;2.使用opcacity属性&lt;/h5&gt;&lt;h5 id=&quot;3-使用rgba和IE的opacity滤镜属性结合&quot;&gt;&lt;a href=&quot;#3-使用rgba和IE的opacity滤镜属性结合&quot; class=&quot;headerlink&quot; title=&quot;3.使用rgba和IE的opacity滤镜属性结合&quot;&gt;&lt;/a&gt;3.使用rgba和IE的opacity滤镜属性结合&lt;/h5&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="css兼容性" scheme="blog.yuanqinglong.cn/tags/css%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="blog.yuanqinglong.cn/hello-world.html"/>
    <id>blog.yuanqinglong.cn/hello-world.html</id>
    <published>2018-01-17T13:17:10.145Z</published>
    <updated>2018-01-23T03:21:38.664Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="设置「阅读全文」"><a href="#设置「阅读全文」" class="headerlink" title="设置「阅读全文」"></a>设置「阅读全文」</h3><p>1.在文章中使用 <!-- more --> 手动进行截断，Hexo 提供的方式 推荐<br>2.在文章的 front-matter 中添加 description，并提供文章摘录<br>3.自动形成摘要，在 主题配置文件 中添加：</p><p>auto_excerpt:<br>  enable: true<br>  length: 150<br>默认截取的长度为 150 字符，可以根据需要自行设定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="blog.yuanqinglong.cn/categories/hexo/"/>
    
    
      <category term="常用命令" scheme="blog.yuanqinglong.cn/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
