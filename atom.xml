<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>西伯利亚大尾巴狼</title>
  <icon>https://www.gravatar.com/avatar/7d9cee11c8c05e013b8780c0530e6e5b</icon>
  <subtitle>子非鱼，安知鱼之乐？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.yuanqinglong.cn/"/>
  <updated>2018-11-18T15:14:33.332Z</updated>
  <id>blog.yuanqinglong.cn/</id>
  
  <author>
    <name>袁庆龙</name>
    <email>yuanql96@yeah.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>chrome开发者工具面板功能解析</title>
    <link href="blog.yuanqinglong.cn/chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E9%9D%A2%E6%9D%BF%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90.html"/>
    <id>blog.yuanqinglong.cn/chrome开发者工具面板功能解析.html</id>
    <published>2018-11-18T12:47:17.000Z</published>
    <updated>2018-11-18T15:14:33.332Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文大部分资料来源于互联网博客分享以及自身日常使用</p></blockquote><h3 id="Chrome开发者工具"><a href="#Chrome开发者工具" class="headerlink" title="Chrome开发者工具"></a>Chrome开发者工具</h3><p>打开开发者工具，我们能看见的面板有：<code>Elements</code>、<code>Console</code>、<code>Sourse</code>、<code>Network</code>、<code>Timeline</code>、<code>Profiles</code>、<code>Application</code>、<code>Security</code>、<code>Aduits</code>;<br>功能大体如下所示：<br><a id="more"></a></p><ul><li><strong>Element</strong> : 查找网页的源码HTML中的任意元素，手动修改任何元素的属性或者样式都能在浏览器上得到反馈。</li><li><strong>Console</strong> : 可以记录开发者开发过程中的日志信息，并且能够作为一个<code>JS</code>的命令行式的交互shell</li><li><strong>Sourse</strong> : 能够断点调试JS</li><li><strong>Network</strong> : 从发起页面请求Request后，分析HTTP请求得到后的各个请求资源信息（状态、资源类型、大小、所用时间），可以根据这个进行网络性能优化。</li><li><strong>Timeline</strong> : 记录分析在网站生命周期内所发生的各类事件，以此可以提高网页的运行时间的性能</li><li><strong>Profiles</strong> : 如果需要Timeline所能提供更多的信息时，可以尝试一下Profiles，比如记录JS的CPU的执行时间细节、显示JS对象和相关的DOM节点的内存消耗、记录内存的分配细节。</li><li><strong>Application</strong> 记录网站加载的所有资源的信息，包括存储数据（<code>Local Storage</code>、<code>Session Storage</code>、<code>IndexedDB</code>、<code>Web SQL</code>、<code>Cookies</code>）、缓存数据、字体、图片、脚本、样式表等</li><li><strong>Security</strong> : 判断当前网页是否安全。</li><li><strong>Audits</strong> : 对当前网页进行网络利用情况、网页性能方面的诊断，并给出一些优化建议。比如列出所有没有用到的CSS文件等。</li></ul><h3 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h3><h4 id="Network面板"><a href="#Network面板" class="headerlink" title="Network面板"></a>Network面板</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p><strong>Net</strong></p><ul><li>work面板可以记录页面上的网络请求的详情信息，从发起网页页面请求Request后分析HTTP请求后得到的各个请求资源信息（包括状态、资源类型、大小、所用时间、Request和Response等），可以根据这个进行网络性能优化。</li></ul><p>该面板主要包括5大块窗格(Pane)：</p><ul><li><p>1.Controls 控制Network的外观和功能。</p></li><li><p>2.Filters 控制Requests Table具体显示哪些内容。</p></li><li><p>3.Overview 显示获取到资源的时间轴信息。</p></li><li><p>4.Requests Table 按资源获取的前后顺序显示所有获取到的资源信息，点击资源名可以查看该资源的详细信息。</p></li><li><p>5.Summary 显示总的请求数、数据传输量、加载时间信息。</p></li></ul><p>其中 Requests Table 显示如下信息列：</p><ul><li>Name 资源名称，点击名称可以查看资源的详情情况，包括 - Headers<ul><li>Preview</li><li>Response</li><li>Cookies</li><li>Timing</li><li><strong>Status</strong> : HTTP状态码。</li></ul></li></ul><p><strong>Type</strong> : 请求的资源MIME类型。</p><p><strong>Initiator</strong> : 标记请求是由哪个对象或进程发起的（请求源）。</p><ul><li><p>Parser: 请求由Chrome的HTML解析器时发起的。</p></li><li><p>Redirect : 请求是由HTTP页面重定向发起的。</p></li><li><p>Script : 请求是由Script脚本发起的。</p></li><li><p>Other : 请求是由其他进程发起的，比如用户点击一个链接跳转到另一个页面或者在地址栏输入URL地址。</p></li></ul><p><strong>Size</strong> : 从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源则该列会显示(from cache)</p><p><strong>Time</strong> : 请求或下载的时间，从发起Request到获取到Response所用的总时间。</p><p><strong>Timeline</strong> : 显示所有网络请求的可视化瀑布流(时间状态轴)，点击时间轴，可以查看该请求的详细信息，点击列头则可以根据指定的字段可以排序。</p><h5 id="捕获屏幕"><a href="#捕获屏幕" class="headerlink" title="捕获屏幕"></a>捕获屏幕</h5><p><strong>Controls</strong><br>窗格包括的功能有网络日志录制、日志清理、捕获屏幕、过滤器，视图切换、保留日志开关、Cache开关、网络连接开关、网速阀值。<br>以捕获屏幕为例，点击摄像机按钮（捕获屏幕），重新加载页面即可捕获屏幕。<br><code>双击</code>其中的截屏可以放大显示，在放大的图下方可以点击跳转到上一帧或者下一帧。<br><code>单击</code>则可以查看该帧被捕获时的网络请求信息，并且在<code>Overview</code>上会有一条黄色竖线以标记该帧被捕获的具体时间点。</p><p>查看<code>DOMContentLoaded</code>和<code>load</code>事件信息<br><strong>DOMContentLoaded</strong>和<strong>load</strong><br>这两个事件会高亮显示。<br>DOMContentLoaded事件会在页面上DOM完全加载并解析完毕之后触发，不会等待CSS、图片、子框架加载完成。 load事件会在页面上所有DOM、CSS、JS、图片完全加载完毕之后触发。<br>DOMContentLoaded<br>事件在Overview上用一条蓝色竖线标记，并且在Summary以蓝色文字显示确切的时间。<br>load<br>事件同样会在Overview和Requests Table上用一条红色竖线标记，在Summary也会以红色文字显示确切的时间。</p><h5 id="查看具体资源的详情"><a href="#查看具体资源的详情" class="headerlink" title="查看具体资源的详情"></a>查看具体资源的详情</h5><p>通过点击某个资源的Name可以查看该资源的详细信息，根据选择的资源类型显示的信息也不太一样，可能包括如下Tab信息：<br><strong>Headers</strong> 该资源的HTTP头信息。</p><p><strong>Preview</strong> 根据你所选择的资源类型（JSON、图片、文本）显示相应的预览。</p><p><strong>Response</strong> 显示HTTP的Response信息。</p><p><strong>Cookies</strong> 显示资源HTTP的Request和Response过程中的Cookies信息。</p><p><strong>Timing</strong> 显示资源在整个请求生命周期过程中各部分花费的时间。</p><p>针对上面5个Tab进行详细讲解一下各个功能：</p><ul><li><p>① 查看资源HTTP头信息</p><ul><li>在Headers标签里面可以看到<ul><li><code>HTTP Request URL</code></li><li><code>HTTP Method</code></li><li><code>Status Code</code></li><li><code>Remote Address</code></li><li>等基本信息和详细的<code>Response Headers</code> 、<code>Request Headers</code>以及<code>Query String Parameters</code>或者<code>Form Data</code>等信息。</li></ul></li></ul></li><li><p>② 查看资源预览信息</p><ul><li>在Preview标签里面可根据选择的资源类型（JSON、图片、文本、JS、CSS）显示相应的预览信息。下图显示的是当选择的资源是JSON格式时的预览信息。</li></ul></li><li><p>③ 查看资源HTTP的Response信息</p><ul><li>在Response标签里面可根据选择的资源类型（JSON、图片、文本、JS、CSS）显示相应资源的Response响应内容。下图显示的是当选择的资源是CSS格式时的响应内容。</li></ul></li><li><p>④ 查看资源Cookies信息</p><ul><li>如果选择的资源在Request和Response过程中存在Cookies信息，则Cookies标签会自动显示出来，在里面可以查看所有的Cookies信息。</li></ul></li><li><p>⑤ 分析资源在请求的生命周期内各部分时间花费信息</p><ul><li>在Timing标签中可以显示资源在整个请求生命周期过程中各部分时间花费信息，可能会涉及到如下过程的时间花费情况：</li><li>Queuing 排队的时间花费。可能由于该请求被渲染引擎认为是优先级比较低的资源（图片）、服务器不可用、超过浏览器的并发请求的最大连接数（Chrome的最大并发连接数为6）.</li><li><p>Stalled 从HTTP连接建立到请求能够被发出送出去(真正传输数据)之间的时间花费。包含用于处理代理的时间，如果有已经建立好的连接，这个时间还包括等待已建立连接被复用的时间。</p></li><li><p>Proxy Negotiation 与代理服务器连接的时间花费。</p></li><li><p>DNS Lookup 执行DNS查询的时间。网页上每一个新的域名都要经过一个DNS查询。第二次访问浏览器有缓存的话，则这个时间为0。</p></li><li><p>Initial Connection / Connecting 建立连接的时间花费，包含了TCP握手及重试时间。</p></li><li><p>SSL 完成SSL握手的时间花费。</p></li><li><p>Request sent 发起请求的时间。</p></li><li><p>Waiting (Time to first byte (TTFB)) 是最初的网络请求被发起到从服务器接收到第一个字节这段时间，它包含了TCP连接时间，发送HTTP请求时间和获得响应消息第一个字节的时间。</p></li><li><p>Content Download 获取Response响应数据的时间花费。</p></li></ul></li></ul><pre><code>- TTFB这个部分的时间花费如果超过200ms，则应该考虑对网络进行性能优化了，可以参见网络性能优化方案及里面的相关参考文档。</code></pre><h5 id="查看资源的发起者-请求源-和依赖项"><a href="#查看资源的发起者-请求源-和依赖项" class="headerlink" title="查看资源的发起者(请求源)和依赖项"></a>查看资源的发起者(请求源)和依赖项</h5><p>通过按住Shift<br>并且把光标移到资源名称上，可以查看该资源是由哪个对象或进程发起的（请求源）和对该资源的请求过程中引发了哪些资源（依赖资源）。<br>在该资源的上方第一个标记为绿色的资源就是该资源的发起者（请求源），有可能会有第二个标记为绿色的资源是该资源的发起者的发起者，以此类推。</p><blockquote><p>本文链接：<a href="https://www.jianshu.com/p/4b2029cb8594" target="_blank" rel="noopener">https://www.jianshu.com/p/4b2029cb8594</a><br>感谢答疑解惑</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;本文大部分资料来源于互联网博客分享以及自身日常使用&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;Chrome开发者工具&quot;&gt;&lt;a href=&quot;#Chrome开发者工具&quot; class=&quot;headerlink&quot; title=&quot;Chrome开发者工具&quot;&gt;&lt;/a&gt;Chrome开发者工具&lt;/h3&gt;&lt;p&gt;打开开发者工具，我们能看见的面板有：&lt;code&gt;Elements&lt;/code&gt;、&lt;code&gt;Console&lt;/code&gt;、&lt;code&gt;Sourse&lt;/code&gt;、&lt;code&gt;Network&lt;/code&gt;、&lt;code&gt;Timeline&lt;/code&gt;、&lt;code&gt;Profiles&lt;/code&gt;、&lt;code&gt;Application&lt;/code&gt;、&lt;code&gt;Security&lt;/code&gt;、&lt;code&gt;Aduits&lt;/code&gt;;&lt;br&gt;功能大体如下所示：&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="chrome开发者工具" scheme="blog.yuanqinglong.cn/tags/chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>chrome开发者工具Fidder请求信息颜色的含义</title>
    <link href="blog.yuanqinglong.cn/chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7Fidder%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E9%A2%9C%E8%89%B2%E7%9A%84%E5%90%AB%E4%B9%89.html"/>
    <id>blog.yuanqinglong.cn/chrome开发者工具Fidder请求信息颜色的含义.html</id>
    <published>2018-11-18T10:35:43.000Z</published>
    <updated>2018-11-18T10:43:22.458Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常记录<br>图片示例：<br><img src="./DOMContentLoad-与-Load-区别/download.png" alt="解析快照1" title="浏览器解析快照"></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">颜色     | 含义</span><br><span class="line">-------- | ---</span><br><span class="line">红色     | HTTP状态错误</span><br><span class="line">黄色     | HTTP状态需要用户认证</span><br><span class="line">灰色     | 数据流类型CONNECT 或者相应内容是图片</span><br><span class="line">紫色     | 响应内容是css文件</span><br><span class="line">蓝色     | 响应内容是HTML文件</span><br><span class="line">绿色     | 相应内容是javascript文件</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;日常记录&lt;br&gt;图片示例：&lt;br&gt;&lt;img src=&quot;./DOMContentLoad-与-Load-区别/download.png&quot; alt=&quot;解析快照1&quot; title=&quot;浏览器解析快照&quot;&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DOMContentLoad 与 Load 区别</title>
    <link href="blog.yuanqinglong.cn/DOMContentLoad-%E4%B8%8E-Load-%E5%8C%BA%E5%88%AB.html"/>
    <id>blog.yuanqinglong.cn/DOMContentLoad-与-Load-区别.html</id>
    <published>2018-11-17T06:35:26.000Z</published>
    <updated>2018-11-17T06:35:26.904Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于JQuery中的 深拷贝的实现</title>
    <link href="blog.yuanqinglong.cn/jq%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>blog.yuanqinglong.cn/jq源码阅读笔记（一）.html</id>
    <published>2018-10-28T07:49:24.000Z</published>
    <updated>2018-11-18T15:13:43.311Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好久没有更新了，一些个人原因，不过，最近开始重温jquery的代码，希望温故而知新！</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在面试中，被问到深拷贝的实现，讲真，每次想起深拷贝，总会想起JSON那两个方法，然而实际上，从逻辑角度来看，这是不合理的，如果只是单纯想深拷贝而非json相关转化，不应该使用JSON对象的方法进行深拷贝转化，</p><a id="more"></a><h3 id="深浅拷贝概念"><a href="#深浅拷贝概念" class="headerlink" title="深浅拷贝概念"></a>深浅拷贝概念</h3><p>在复制的过程中，对于基本类型的变量，无论深浅拷贝，值的意义就是本身，结果都是新开辟栈内存将新的该值存起来；然而对于引用类型变量来说，栈内存的值意义代表的是堆内存<code>地址</code>的对外映射（引用），换句话来讲，无论我在栈中开辟多少个地址来存储某个引用类型的变量值，这个值指向的堆内存地址都是同一个，也就意味着牵一发而动全身。这时候深浅拷贝的意义就出现了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型的变量</span><br><span class="line">var a = 1 // a = 1</span><br><span class="line">var b = a // b = 1</span><br><span class="line">b = 2</span><br><span class="line">console.log(a) // a</span><br><span class="line"></span><br><span class="line">// 引用类型</span><br><span class="line">a = &#123;&#125; // a = &#123;&#125;</span><br><span class="line">b = a  // b = &#123;&#125;</span><br><span class="line">b.test = 1 // 尝试为b添加一个属性<span class="built_in">test</span></span><br><span class="line">console.log(b.test) // 1</span><br><span class="line">console.log(a.test) // 1,我们发现a也多出来这个属性</span><br></pre></td></tr></table></figure><p>关于<code>深拷贝</code>：</p><ul><li>在尝试复制引用类型变量的时候，深拷贝将会开辟新的堆内存空间来存储该值</li></ul><h3 id="jQuery的extend"><a href="#jQuery的extend" class="headerlink" title="jQuery的extend()"></a>jQuery的extend()</h3><p>那么，言归正传，熟悉jq的朋友都知道JQ的api有着 <code>jQuery.extend()</code>的方法，官方文档中有关这个方法：</p><ul><li>情形1：jQuery.extend( target, object1 [, objectN ] )</li><li>情形2：jQuery.extend( [deep ], target, object1 [, objectN ] )</li></ul><p>两种情形的差别就是：</p><ul><li>情形1是情形2的默认情况，且<code>[deep]</code>是Boolean类型且为默认值false，tips：<code>[deep]</code>仅接受true作为值，因为false为内部默认定义，既不用，也不可以对其赋值false</li><li>情形1是浅拷贝，情形2在<code>[deep]</code>是true时，将进行递归深拷贝，</li></ul><h4 id="extend-源码"><a href="#extend-源码" class="headerlink" title="extend() 源码"></a>extend() 源码</h4><p>以下是jq源码中关于extend的实现；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// isFuntion</span><br><span class="line">var isFunction = <span class="keyword">function</span> isFunction(obj) &#123;</span><br><span class="line">    // Support: Chrome &lt;=57, Firefox &lt;=52</span><br><span class="line">    // In some browsers, typeof returns <span class="string">"function"</span> <span class="keyword">for</span> HTML &lt;object&gt; elements</span><br><span class="line">    // (i.e., `typeof document.createElement( <span class="string">"object"</span> ) === <span class="string">"function"</span>`).</span><br><span class="line">    // We don<span class="string">'t want to classify *any* DOM node as a function.</span></span><br><span class="line"><span class="string">    return typeof obj === "function" &amp;&amp; typeof obj.nodeType !== "number";</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// isPlainObject</span></span><br><span class="line"><span class="string">isPlainObject: function (obj) &#123;</span></span><br><span class="line"><span class="string">        var proto, Ctor;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Detect obvious negatives</span></span><br><span class="line"><span class="string">        // Use toString instead of jQuery.type to catch host objects</span></span><br><span class="line"><span class="string">        if (!obj || toString.call(obj) !== "[object Object]") &#123;</span></span><br><span class="line"><span class="string">            return false;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        proto = getProto(obj);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Objects with no prototype (e.g., `Object.create( null )`) are plain</span></span><br><span class="line"><span class="string">        if (!proto) &#123;</span></span><br><span class="line"><span class="string">            return true;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Objects with prototype are plain iff they were constructed by a global Object function</span></span><br><span class="line"><span class="string">        Ctor = hasOwn.call(proto, "constructor") &amp;&amp; proto.constructor;</span></span><br><span class="line"><span class="string">        return typeof Ctor === "function" &amp;&amp; fnToString.call(Ctor) === ObjectFunctionString;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">// extend</span></span><br><span class="line"><span class="string">jQuery.extend = jQuery.fn.extend = function () &#123;</span></span><br><span class="line"><span class="string">    var options, name, src, copy, copyIsArray, clone,</span></span><br><span class="line"><span class="string">        target = arguments[0] || &#123;&#125;, // 第一个参数值，没有就用&#123;&#125;替代</span></span><br><span class="line"><span class="string">        i = 1, // 缓存i，迭代用</span></span><br><span class="line"><span class="string">        length = arguments.length,</span></span><br><span class="line"><span class="string">        deep = false; // 默认值是false，这就是为什么不期望对extend进行false赋值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Handle a deep copy situation</span></span><br><span class="line"><span class="string">    if (typeof target === "boolean") &#123; // 接到的第一个参数时布尔型</span></span><br><span class="line"><span class="string">        deep = target; // 将布尔值存储到deep上</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Skip the boolean and the target， 跳过布尔值以及对target进行复制</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        target = arguments[i] || &#123;&#125;; // 重新的将target进行复制</span></span><br><span class="line"><span class="string">        i++;    //下一次迭代后将偏移量 +1</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Handle case when target is a string or something (possible in deep copy)</span></span><br><span class="line"><span class="string">    if (typeof target !== "object" &amp;&amp; !isFunction(target)) &#123;</span></span><br><span class="line"><span class="string">        target = &#123;&#125;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Extend jQuery itself if only one argument is passed</span></span><br><span class="line"><span class="string">    if (i === length) &#123;</span></span><br><span class="line"><span class="string">        target = this;</span></span><br><span class="line"><span class="string">        i--;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for (; i &lt; length; i++) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Only deal with non-null/undefined values</span></span><br><span class="line"><span class="string">        if ((options = arguments[i]) != null) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            // Extend the base object</span></span><br><span class="line"><span class="string">            for (name in options) &#123;</span></span><br><span class="line"><span class="string">                src = target[name];</span></span><br><span class="line"><span class="string">                copy = options[name];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                // Prevent never-ending loop</span></span><br><span class="line"><span class="string">                if (target === copy) &#123;</span></span><br><span class="line"><span class="string">                    continue;</span></span><br><span class="line"><span class="string">                &#125; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                // Recurse if we'</span>re merging plain objects or arrays</span><br><span class="line">                <span class="keyword">if</span> (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) ||</span><br><span class="line">                        (copyIsArray = Array.isArray(copy)))) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (copyIsArray) &#123;</span><br><span class="line">                        copyIsArray = <span class="literal">false</span>;</span><br><span class="line">                        <span class="built_in">clone</span> = src &amp;&amp; Array.isArray(src) ? src : [];</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">clone</span> = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Never move original objects, <span class="built_in">clone</span> them</span><br><span class="line">                    target[name] = jQuery.extend(deep, <span class="built_in">clone</span>, copy);</span><br><span class="line"></span><br><span class="line">                    // Don<span class="string">'t bring in undefined values</span></span><br><span class="line"><span class="string">                &#125; else if (copy !== undefined) &#123;</span></span><br><span class="line"><span class="string">                    target[name] = copy;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Return the modified object</span></span><br><span class="line"><span class="string">    return target;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;好久没有更新了，一些个人原因，不过，最近开始重温jquery的代码，希望温故而知新！&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在面试中，被问到深拷贝的实现，讲真，每次想起深拷贝，总会想起JSON那两个方法，然而实际上，从逻辑角度来看，这是不合理的，如果只是单纯想深拷贝而非json相关转化，不应该使用JSON对象的方法进行深拷贝转化，&lt;/p&gt;
    
    </summary>
    
    
      <category term="jquery" scheme="blog.yuanqinglong.cn/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>mongo.exe启动后报错</title>
    <link href="blog.yuanqinglong.cn/mongo-exe%E5%90%AF%E5%8A%A8%E5%90%8E%E6%8A%A5%E9%94%99.html"/>
    <id>blog.yuanqinglong.cn/mongo-exe启动后报错.html</id>
    <published>2018-06-26T13:10:58.000Z</published>
    <updated>2018-08-30T14:16:56.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MongoDB的使用报错信息"><a href="#MongoDB的使用报错信息" class="headerlink" title="MongoDB的使用报错信息"></a>MongoDB的使用报错信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Server has startup warnings:</span><br><span class="line">2018-06-26T05:43:00.339-0700 I CONTROL  [initandlisten]</span><br><span class="line">2018-06-26T05:43:00.339-0700 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled <span class="keyword">for</span> the database.</span><br><span class="line">2018-06-26T05:43:00.340-0700 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.</span><br><span class="line">2018-06-26T05:43:00.340-0700 I CONTROL  [initandlisten]</span><br><span class="line">2018-06-26T05:43:00.340-0700 I CONTROL  [initandlisten] ** WARNING: This server is bound to localhost.</span><br><span class="line">2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten] **          Remote systems will be unable to connect to this server.</span><br><span class="line">2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten] **          Start the server with --bind_ip &lt;address&gt; to specify <span class="built_in">which</span> IP</span><br><span class="line">2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten] **          addresses it should serve responses from, or with --bind_ip_all to</span><br><span class="line">2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten] **          <span class="built_in">bind</span> to all interfaces. If this behavior is desired, start the</span><br><span class="line">2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten] **          server with --bind_ip 127.0.0.1 to <span class="built_in">disable</span> this warning.</span><br><span class="line">2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten]</span><br><span class="line">2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten]</span><br><span class="line">2018-06-26T05:43:00.342-0700 I CONTROL  [initandlisten] ** WARNING: The file system cache of this machine is configured to be greater than 40% of the total memory. This can lead to increased memory pressure and poor performance.</span><br><span class="line">2018-06-26T05:43:00.342-0700 I CONTROL  [initandlisten] See http://dochub.mongodb.org/core/wt-windows-system-file-cache</span><br><span class="line">2018-06-26T05:43:00.342-0700 I CONTROL  [initandlisten]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>sorry,我也不知道怎么回事，最后我决定重新建立数据库，下面是步骤：<br>（MongoDB下载完成之后最好是配个环境变量，所以我是随便打开了一个cmd，或者powershell就可以运行mongod.exe/mongo.exe）</p><h4 id="方案"><a href="#方案" class="headerlink" title="方案:"></a>方案:</h4><ol><li><p>准备工作</p><ul><li>首先，我们要在我们指定的路径新建数据库，如：<code>F:\MongoDb_data\db</code></li><li>其次，新建一个保存日志的文件夹,如：<code>F:\MongoDb_data\log</code></li><li>继而，再建一个配置文件，<code>mongo.config</code><br>  内容如图：<br>  <img src="./mongo-exe启动后报错/05.png" alt="Alt text" title="配置"></li></ul></li><li><p>执行配置文件，命令：<code>mongod --config &quot;F:\MongoDb_data\mongod.config&quot; --install</code>,我们能够看到log下生成了日志文件</p></li><li><p>这一步不要去执行exe文件，如果这样的或或得到这样的报错信息<br> <img src="./mongo-exe启动后报错/06.png" alt="Alt text" title="error"></p><p> 原因很简单，因为我们的mongodb服务尚未启动，所以，运行命令<code>net start mongo</code>,即，开启MongoDB服务（<code>net stop mongo</code>关闭服务）<br> 然后再次执行 mongo.exe<br> 得到如下结果：<br> <img src="./mongo-exe启动后报错/07.png" alt="Alt text" title="success"></p></li><li>然后我们可一查看数据库,<code>show dbs</code>，</li><li>可以随便选择一个 ,比如，admin 数据库，命令<code>use admin</code></li><li><p>添加一个用户，这里有些需要注意的地方：<br> 1) 首先我们需要了解的,创建用户的语句：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(user, writeConcern)</span><br></pre></td></tr></table></figure></code></pre><ul><li>user            这个文档创建关于用户的身份认证和访问信息；</li><li><p>writeConcern    这个文档描述保证MongoDB提供写操作的成功报告。</p><p>2) 接下来细说 user:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user: <span class="string">"&lt;name&gt;"</span>,  //用户名</span><br><span class="line">    <span class="built_in">pwd</span>: <span class="string">"&lt;cleartext password&gt;"</span>,  //密码</span><br><span class="line">    customData: &#123; &lt;any information&gt; &#125;,   //关于此用户的描述</span><br><span class="line">    roles: [  </span><br><span class="line">        &#123; role: <span class="string">"&lt;role&gt;"</span>, db: <span class="string">"&lt;database&gt;"</span> &#125; | <span class="string">"&lt;role&gt;"</span>,  //role:角色    db:指定数据库</span><br><span class="line">    ]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>user文档字段介绍：<br>  user字段，为新用户的名字；<br>  pwd字段，用户的密码；<br>  cusomData字段，为任意内容，例如可以为用户全名介绍；<br>  roles字段，指定用户的角色，可以用一个空数组给新用户设定空角色；<br>  在roles字段,可以指定内置角色和用户定义的角色。</p><p>  Built-In Roles（内置角色）：</p><ol><li>数据库用户角色：read、readWrite;</li><li>数据库管理角色：dbAdmin、dbOwner、userAdmin；</li><li>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；</li><li>备份恢复角色：backup、restore；</li><li>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</li><li>超级用户角色：root<br>// 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）</li><li><p>内部角色：__system<br>PS：关于每个角色所拥有的操作权限可以点击上面的内置角色链接查看详情。</p><p>· writeConcern文档（<a href="https://docs.mongodb.com/manual/reference/write-concern/" title="官方" target="_blank" rel="noopener">官方</a><br> w选项：允许的值分别是 1、0、大于1的值、”majority”、<tag set="">；<br> j选项：确保mongod实例写数据到磁盘上的journal（日志），这可以确保mongd以外关闭不会丢失数据。设置true启用。<br> wtimeout：指定一个时间限制,以毫秒为单位。wtimeout只适用于w值大于1。</tag></p></li></ol><p>1) 完整执行步骤</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use <span class="string">'&lt;database&gt;'</span> //选择指定的数据库</span><br><span class="line">db.createUser(user)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>以名为<code>admin</code>的数据库为例，在<code>mongo.exe</code>中执行如下:<br>1) 创建管理员</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br></pre></td></tr></table></figure><p><img src="./mongo-exe启动后报错/01 .png" alt="Alt text" title="use admin"></p><p>2) 创建管理员</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> db.createUser(</span><br><span class="line">    &#123;</span><br><span class="line">        user: <span class="string">"yuanqinglong"</span>,</span><br><span class="line">        <span class="built_in">pwd</span>: <span class="string">"yql"</span>,</span><br><span class="line">        roles: [&#123;role: <span class="string">"userAdminAnyDatabase"</span>, db: <span class="string">"admin"</span>&#125;]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="./mongo-exe启动后报错/02.png" alt="Alt text" title="db.createUser()"></p><p>3)  以用户身份登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 27017 -u <span class="string">"yuanqinglong"</span> -p <span class="string">"yql"</span> --authenticationDatabase <span class="string">"admin"</span></span><br></pre></td></tr></table></figure><p>或者直接用<code>mongo.exe</code>启动也可以<br>（端口默认就是27017可以不指定）<br>结果:<br><img src="./mongo-exe启动后报错/03.png" alt="Alt text" title="重启MongoDB服务器"></p></li></ul></li></ol><p>ok！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MongoDB的使用报错信息&quot;&gt;&lt;a href=&quot;#MongoDB的使用报错信息&quot; class=&quot;headerlink&quot; title=&quot;MongoDB的使用报错信息&quot;&gt;&lt;/a&gt;MongoDB的使用报错信息&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Server has startup warnings:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.339-0700 I CONTROL  [initandlisten]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.339-0700 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; the database.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.340-0700 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.340-0700 I CONTROL  [initandlisten]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.340-0700 I CONTROL  [initandlisten] ** WARNING: This server is bound to localhost.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten] **          Remote systems will be unable to connect to this server.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten] **          Start the server with --bind_ip &amp;lt;address&amp;gt; to specify &lt;span class=&quot;built_in&quot;&gt;which&lt;/span&gt; IP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten] **          addresses it should serve responses from, or with --bind_ip_all to&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten] **          &lt;span class=&quot;built_in&quot;&gt;bind&lt;/span&gt; to all interfaces. If this behavior is desired, start the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten] **          server with --bind_ip 127.0.0.1 to &lt;span class=&quot;built_in&quot;&gt;disable&lt;/span&gt; this warning.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.341-0700 I CONTROL  [initandlisten]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.342-0700 I CONTROL  [initandlisten] ** WARNING: The file system cache of this machine is configured to be greater than 40% of the total memory. This can lead to increased memory pressure and poor performance.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.342-0700 I CONTROL  [initandlisten] See http://dochub.mongodb.org/core/wt-windows-system-file-cache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2018-06-26T05:43:00.342-0700 I CONTROL  [initandlisten]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="blog.yuanqinglong.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB帮助文档</title>
    <link href="blog.yuanqinglong.cn/MongoDB%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3.html"/>
    <id>blog.yuanqinglong.cn/MongoDB帮助文档.html</id>
    <published>2018-06-26T13:00:57.000Z</published>
    <updated>2018-06-26T13:18:41.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="db的帮助文档"><a href="#db的帮助文档" class="headerlink" title="db的帮助文档"></a>db的帮助文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.help();</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出:"></a>输出:</h4><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">db.adminCommand(nameOrDocument)// 切换到<span class="string">'admin'</span>数据库,并且运行命令</span><br><span class="line">db.AddUser(username,password[, readOnly=<span class="literal">false</span>])  //添加用户  </span><br><span class="line">db.auth(usrename,password)     // 设置数据库连接验证  </span><br><span class="line">db.cloneDataBase(fromhost)     // 从目标服务器克隆一个数据库  </span><br><span class="line">db.commandHelp(name)           // returns the <span class="built_in">help</span> <span class="keyword">for</span> the <span class="built_in">command</span>  </span><br><span class="line">db.copyDatabase(fromdb,todb,fromhost)  // 复制数据库fromdb---源数据库名称，todb---目标数据库名称，fromhost---源数据库服务器地址  </span><br><span class="line">db.createCollection(name,&#123;size:3333,capped:333,max:88888&#125;)  // 创建一个数据集，相当于一个表  </span><br><span class="line">db.createView(name, viewOn, [ &#123; <span class="variable">$operator</span>: &#123;...&#125;&#125;, ... ], &#123; viewOptions &#125; ) // 创建视图</span><br><span class="line">db.createUser(userDocument)    // 创建用户</span><br><span class="line">db.currentOp()                 // 取消当前库的当前操作  </span><br><span class="line">db.dropDataBase()              // 删除当前数据库  </span><br><span class="line">db.eval(func,args)             // (已过时) run code server-side  </span><br><span class="line">db.fsyncLock()                 // 将数据保存到硬盘并且锁定服务器备份</span><br><span class="line">db.fsyncUnlock() unlocks server following a db.fsyncLock()</span><br><span class="line">db.getCollection(cname)        // 取得一个数据集合，同用法：db[<span class="string">'cname'</span>] or db.cname</span><br><span class="line">db.getCollenctionNames()       // 取得所有数据集合的名称列表  </span><br><span class="line">db.getLastError()              // 返回最后一个错误的提示消息  </span><br><span class="line">db.getLastErrorObj()           // 返回最后一个错误的对象  </span><br><span class="line">db.getLogComponents()</span><br><span class="line">db.getMongo()                  // 取得当前服务器的连接对象get the server  </span><br><span class="line">db.getMondo().setSlaveOk()     // allow this connection to <span class="built_in">read</span> from <span class="keyword">then</span> nonmaster membr of a replica pair  </span><br><span class="line">db.getName()                   // 返回当操作数据库的名称  </span><br><span class="line">db.getPrevError()              // 返回上一个错误对象  </span><br><span class="line">db.getProfilingLevel()         // 获取profile level  </span><br><span class="line">db.getReplicationInfo()        // 获得重复的数据  </span><br><span class="line">db.getSisterDB(name)           // get the db at the same server as this onew  </span><br><span class="line">db.killOp()                    // 停止（杀死）在当前库的当前操作 </span><br><span class="line">db.listCommands()              // lists all the db commands</span><br><span class="line">db.loadServerScripts()         // loads all the scripts <span class="keyword">in</span> db.system.js</span><br><span class="line">db.logout()</span><br><span class="line">db.printCollectionStats()      // 返回当前库的数据集状态  </span><br><span class="line">db.printReplicationInfo()      // 打印主数据库的复制状态信息  </span><br><span class="line">db.printSlaveReplicationInfo() // 打印从数据库的复制状态信息  </span><br><span class="line">db.printShardingStatus()       // 返回当前数据库是否为共享数据库  </span><br><span class="line">db.removeUser(username)        // 删除用户  </span><br><span class="line">db.repairDatabase()            // 修复当前数据库  </span><br><span class="line">db.resetError()  </span><br><span class="line">db.runCommand(cmdObj)          // run a database <span class="built_in">command</span>. <span class="keyword">if</span> cmdObj is a string, turns it into &#123;cmdObj:1&#125;  </span><br><span class="line">db.runCommand(cmdObj)          // run a database <span class="built_in">command</span>.  <span class="keyword">if</span> cmdObj is a string, turns it into &#123; cmdObj : 1 &#125;</span><br><span class="line">db.serverStatus()</span><br><span class="line">db.setLogLevel(level, &lt;component&gt;)</span><br><span class="line">db.setProfilingLevel(level, &lt;slowms&gt;)    // 设置profile level 0=off,1=slow,2=all </span><br><span class="line">db.setWriteConcern( &lt;write concern doc&gt; ) // sets the write concern <span class="keyword">for</span> writes to the db</span><br><span class="line">db.unsetWriteConcern( &lt;write concern doc&gt; ) // unsets the write concern <span class="keyword">for</span> writes to the db</span><br><span class="line">db.setVerboseShell(flag)       // display extra information <span class="keyword">in</span> shell output</span><br><span class="line">db.shutdownServer()            // 关闭当前服务程序  </span><br><span class="line">db.stats()                     // 返回当前数据库的状态信息</span><br><span class="line">db.version()                   // 返回当前程序的版本信息</span><br></pre></td></tr></table></figure><h3 id="表的帮助"><a href="#表的帮助" class="headerlink" title="表的帮助"></a>表的帮助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.tableName.help();</span><br></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出:"></a>输出:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">db.test.find(&#123;id:10&#125;)          // 返回<span class="built_in">test</span>数据集ID=10的数据集  </span><br><span class="line">db.test.find(&#123;id:10&#125;).count()  // 返回<span class="built_in">test</span>数据集ID=10的数据总数  </span><br><span class="line">db.test.find(&#123;id:10&#125;).<span class="built_in">limit</span>(2) // 返回<span class="built_in">test</span>数据集ID=10的数据集从第二条开始的数据集  </span><br><span class="line">db.test.find(&#123;id:10&#125;).skip(8)  // 返回<span class="built_in">test</span>数据集ID=10的数据集从0到第八条的数据集  </span><br><span class="line">db.test.find(&#123;id:10&#125;).<span class="built_in">limit</span>(2).skip(8)  // 返回<span class="built_in">test</span>数据集ID=1=的数据集从第二条到第八条的数据  </span><br><span class="line">db.test.find(&#123;id:10&#125;).sort()   // 返回<span class="built_in">test</span>数据集ID=10的排序数据集  </span><br><span class="line">db.test.findOne([query])       // 返回符合条件的一条数据  </span><br><span class="line">db.test.getDB()                // 返回此数据集所属的数据库名称  </span><br><span class="line">db.test.getIndexes()           // 返回些数据集的索引信息  </span><br><span class="line">db.test.group(&#123;key:...,initial:...,reduce:...[,cond:...]&#125;)    // 返回分组信息  </span><br><span class="line">db.test.mapReduce(mayFunction,reduceFunction,&lt;optional params&gt;)  // 这个有点像存储过程  </span><br><span class="line">db.test.remove(query)                      // 在数据集中删除一条数据  </span><br><span class="line">db.test.renameCollection(newName)          // 重命名些数据集名称  </span><br><span class="line">db.test.save(obj)                          // 往数据集中插入一条数据  </span><br><span class="line">db.test.stats()                            // 返回此数据集的状态  </span><br><span class="line">db.test.storageSize()                      // 返回此数据集的存储大小  </span><br><span class="line">db.test.totalIndexSize()                   // 返回此数据集的索引文件大小  </span><br><span class="line">db.test.totalSize()                        // 返回些数据集的总大小  </span><br><span class="line">db.test.update(query,object[,upsert_bool]) // 在此数据集中更新一条数据  </span><br><span class="line">db.test.validate()                         // 验证此数据集  </span><br><span class="line">db.test.getShardVersion()                  // 返回数据集共享版本号</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;db的帮助文档&quot;&gt;&lt;a href=&quot;#db的帮助文档&quot; class=&quot;headerlink&quot; title=&quot;db的帮助文档&quot;&gt;&lt;/a&gt;db的帮助文档&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;db.help();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;输出&quot;&gt;&lt;a href=&quot;#输出&quot; class=&quot;headerlink&quot; title=&quot;输出:&quot;&gt;&lt;/a&gt;输出:&lt;/h4&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="blog.yuanqinglong.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>关于Win10安装MongoDB报错</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8EWin10%E5%AE%89%E8%A3%85MongoDB%E6%8A%A5%E9%94%99.html"/>
    <id>blog.yuanqinglong.cn/关于Win10安装MongoDB报错.html</id>
    <published>2018-06-26T11:38:17.000Z</published>
    <updated>2018-06-26T12:03:14.337Z</updated>
    
    <content type="html"><![CDATA[<p>学校让留了一个爬虫任务，于是在我尝试着安装MongoDB时，遇到了这样的问题</p><h4 id="描述如下："><a href="#描述如下：" class="headerlink" title="描述如下："></a>描述如下：</h4><ul><li>etup wizard ended prematurely because of an error.your system has not been modified.To. Install this program at a later time run setup wizard again.click finish button to exit the setup</li></ul><a id="more"></a><h4 id="关于解决办法："><a href="#关于解决办法：" class="headerlink" title="关于解决办法："></a>关于解决办法：</h4><p>StackOverflow上给出的解决方案是：</p><ul><li><p>1）Choose Custom Installation</p></li><li><p>2) Uncheck Compass Installation with MongoDb</p></li><li><p>3) Finish the Setup</p></li><li><p>4) Again start setup and click on change the installation</p></li><li><p>5) Tick Compass Installation with MongoDb</p></li><li><p>6) Finish the Setup</p></li></ul><h5 id="简单的来说就是："><a href="#简单的来说就是：" class="headerlink" title="简单的来说就是："></a>简单的来说就是：</h5><p>需要在我们执行两次install.exe文件，</p><ul><li>第一次执行，我们会遇到compass这个选项，然后选择不打勾，继续安装（我安装报错就是因为第一遍安装时，这个选项我打勾了。。。），这样会安装成功</li><li>第二次执行，会出现与第一次不同的界面，我们选择<code>change</code>选项，即为，改变安装项，这时，我们一路执行到上次没打勾的compass那里，然后 <strong>打勾</strong>,继续执行，安装成功</li></ul><p>附链接：<a href="https://stackoverflow.com/questions/48474477/mongodb-3-6-2-2008r2-plus-not-installing" target="_blank" rel="noopener">https://stackoverflow.com/questions/48474477/mongodb-3-6-2-2008r2-plus-not-installing</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学校让留了一个爬虫任务，于是在我尝试着安装MongoDB时，遇到了这样的问题&lt;/p&gt;&lt;h4 id=&quot;描述如下：&quot;&gt;&lt;a href=&quot;#描述如下：&quot; class=&quot;headerlink&quot; title=&quot;描述如下：&quot;&gt;&lt;/a&gt;描述如下：&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;etup wizard ended prematurely because of an error.your system has not been modified.To. Install this program at a later time run setup wizard again.click finish button to exit the setup&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="blog.yuanqinglong.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title> HTML(5) 样式指南和代码约定</title>
    <link href="blog.yuanqinglong.cn/HTML-5-%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97%E5%92%8C%E4%BB%A3%E7%A0%81%E7%BA%A6%E5%AE%9A.html"/>
    <id>blog.yuanqinglong.cn/HTML-5-样式指南和代码约定.html</id>
    <published>2018-05-19T11:43:13.000Z</published>
    <updated>2018-06-26T12:02:53.246Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇内容转载自w3c<br>良好且优秀的代码习惯是必要的，无论是开发成本上，还是从赏心悦目的程度上</p></blockquote><h3 id="HTML-代码约定"><a href="#HTML-代码约定" class="headerlink" title="HTML 代码约定"></a>HTML 代码约定</h3><p>web 开发者常常不确定在 HTML 中使用的代码样式和语法。<br>通过 HTML5，您必须创建属于自己的最佳实践、样式指南和代码约定。<br>智能且有未来保证对样式的合乎逻辑的使用，可以令其他人更容易理解和使用您的 HTML。<br><br>在未来，诸如 XML 阅读器之类的程序，也许需要阅读您的 HTML。<br>使用格式良好的“近似 XHTML 的”语法，能够更智能。</p><h5 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h5><ul><li><p>请始终保持您的样式智能、整洁、纯净、格式良好。<br>请使用正确的文档类型请始终在文档的首行声明文档类型：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果您一贯坚持小写标签，那么可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="请使用小写元素名"><a href="#请使用小写元素名" class="headerlink" title="请使用小写元素名"></a>请使用小写元素名</h5><p>HTML5 允许在元素名中使用混合大小写字母。<br>我们推荐使用小写元素名：</p><ul><li>混合大小写名称并不好</li><li>开发者习惯使用小写名（比如在 XHTML 中）</li><li>小写更起来更纯净</li><li>小写更易书写</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//不太好</span><br><span class="line">    &lt;SECTION&gt; </span><br><span class="line">    &lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">    &lt;/SECTION&gt;</span><br><span class="line"></span><br><span class="line">    //很糟糕：</span><br><span class="line">    &lt;Section&gt; </span><br><span class="line">    &lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">    &lt;/SECTION&gt;</span><br><span class="line"></span><br><span class="line">    还不错：</span><br><span class="line">    &lt;section&gt; </span><br><span class="line">    &lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">    &lt;/section&gt;</span><br></pre></td></tr></table></figure><h5 id="关闭所有-HTML-元素"><a href="#关闭所有-HTML-元素" class="headerlink" title="关闭所有 HTML 元素"></a>关闭所有 HTML 元素</h5><p>在 HTML5 中，您不必关闭所有元素（例如 <code>&lt;p&gt;</code> 元素）<br><br>我们建议关闭所有 HTML 元素：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//看起来不好：</span><br><span class="line">&lt;section&gt;</span><br><span class="line">&lt;p&gt;This is a paragraph.</span><br><span class="line">&lt;p&gt;This is a paragraph.</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">  </span><br><span class="line">//看起来不错：</span><br><span class="line">&lt;section&gt;</span><br><span class="line">&lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h5 id="关闭空的-HTML-元素"><a href="#关闭空的-HTML-元素" class="headerlink" title="关闭空的 HTML 元素"></a>关闭空的 HTML 元素</h5><p>在 HTML5 中，关闭空元素是可选的。<br><br><br>允许这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br></pre></td></tr></table></figure><p>也允许这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=<span class="string">"utf-8"</span> /&gt;</span><br></pre></td></tr></table></figure><p>斜杠（<code>/</code>）在 XHTML 和 XML 中是必需的。<br><br><br>如果您期望 XML 软件来访问您的页面，保持这个习惯是个好主意。</p><h5 id="使用小写属性名"><a href="#使用小写属性名" class="headerlink" title="使用小写属性名"></a>使用小写属性名</h5><p>HTML5 允许大小写混合的属性名。<br><br><br>我们建议使用小写属性名：</p><ul><li>混合属性名并不好</li><li>开发者习惯于使用小写属性名（比如在 XHTML 中）</li><li>小写属性名看情况更纯净</li><li>小写属性名更易书写</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//看起来不好：</span><br><span class="line">&lt;div CLASS=<span class="string">"menu"</span>&gt;</span><br><span class="line"></span><br><span class="line">//看起来不错：</span><br><span class="line">&lt;div class=<span class="string">"menu"</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="属性值加引号"><a href="#属性值加引号" class="headerlink" title="属性值加引号"></a>属性值加引号</h5><p>HTML5 允许不加引号的属性值。<br><br><br>我们推荐属性值加引号：</p><ul><li>如果属性值包含值，则必须使用引号</li><li>混合样式绝对不好</li><li>加引号的值更易阅读</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//这个属性值无效，因为值中包含空格：</span><br><span class="line">&lt;table class=table striped&gt;</span><br><span class="line"></span><br><span class="line">//这样是有效的：</span><br><span class="line">&lt;table class=<span class="string">"table striped"</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="必需的属性"><a href="#必需的属性" class="headerlink" title="必需的属性"></a>必需的属性</h5><p>请始终对图像使用 alt 属性。当图像无法显示时该属性很重要。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"html5.gif"</span> alt=<span class="string">"HTML5"</span> style=<span class="string">"width:128px;height:128px"</span>&gt;</span><br></pre></td></tr></table></figure><p></p><p>#####请始终定义图像尺寸。<br>这样做会减少闪烁，因为浏览器会在图像加载之前为图像预留空间。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"html5.gif"</span> alt=<span class="string">"HTML5"</span> style=<span class="string">"width:128px;height:128px"</span>&gt;</span><br></pre></td></tr></table></figure><p></p><h5 id="空格和等号"><a href="#空格和等号" class="headerlink" title="空格和等号"></a>空格和等号</h5><p>等号两边的空格是合法的：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel = <span class="string">"stylesheet"</span> href = <span class="string">"styles.css"</span>&gt;</span><br></pre></td></tr></table></figure><p></p><p>但是精简空格更易阅读， But space-less is easier to read, and groups entities better together:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"styles.css"</span>&gt;</span><br></pre></td></tr></table></figure><p></p><h5 id="避免长代码行"><a href="#避免长代码行" class="headerlink" title="避免长代码行"></a>避免长代码行</h5><p>当使用 HTML 编辑器时，通过左右滚动来阅读 HTML 代码很不方便。<br><br>请尽量避免代码行超过 80 个字符。</p><h5 id="空行和缩进"><a href="#空行和缩进" class="headerlink" title="空行和缩进"></a>空行和缩进</h5><p>请勿毫无理由地增加空行。<br></p><ul><li>为了提高可读性，请增加空行来分隔大型或逻辑代码块。</li><li>为了提高可读性，请增加两个空格的缩进。请勿使用 TAB。</li><li>请勿使用没有必要的空行和缩进。没有必要在短的和相关项目之间使用空行，也没有必要缩进每个元素：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//不必要：</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Famous Cities&lt;/1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Tokyo&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">    Tokyo is the capital of Japan, the center of the Greater Tokyo Area,</span><br><span class="line">    and the most populous metropolitan area <span class="keyword">in</span> the world.</span><br><span class="line">    It is the seat of the Japanese government and the Imperial Palace,</span><br><span class="line">    and the home of the Japanese Imperial Family.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">//更好：</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Famous Cities&lt;/1&gt;</span><br><span class="line">&lt;h2&gt;Tokyo&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">Tokyo is the capital of Japan, the center of the Greater Tokyo Area,</span><br><span class="line">and the most populous metropolitan area <span class="keyword">in</span> the world.</span><br><span class="line">It is the seat of the Japanese government and the Imperial Palace,</span><br><span class="line">and the home of the Japanese Imperial Family.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">//表格示例：</span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;th&gt;Name&lt;/th&gt;</span><br><span class="line">    &lt;th&gt;Description&lt;/th&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;A&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Description of A&lt;/td&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;B&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;Description of B&lt;/td&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">//列表示例：</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">&lt;li&gt;LondonA&lt;/li&gt;</span><br><span class="line">&lt;li&gt;Paris&lt;/li&gt;</span><br><span class="line">&lt;li&gt;Tokyo&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><h5 id="省略-和-？"><a href="#省略-和-？" class="headerlink" title="省略  和 ？"></a>省略 <html> 和 <body>？</body></html></h5><p>在 HTML5 标准中，能够省略 </p><html> 标签和 <body> 标签。<br><br>以下代码作为 HTML5 进行验证：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//示例</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Page Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;This is a heading&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p></p><p>我们不推荐省略 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 标签。<br></p><p></p><html> 元素是文本的根元素。它是规定页面语言的理想位置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en-US"</span>&gt;</span><br></pre></td></tr></table></figure><p></p><p>对于可访问应用程序（屏幕阅读器）和搜索引擎，声明语言很重要。<br></p><ul><li>省略 <html> 或 <body> c可令 DOM 和 XML 软件崩溃。</body></html></li><li>省略 <body> 会在老式浏览器（IE9）中产生错误。</body></li><li>省略 <head>？</head></li></ul><h5 id="在-HTML5-标准中，-标签也能够被省略。"><a href="#在-HTML5-标准中，-标签也能够被省略。" class="headerlink" title="在 HTML5 标准中， 标签也能够被省略。"></a>在 HTML5 标准中，<head> 标签也能够被省略。</head></h5><p>默认地，浏览器会把 </p><body> 之前的所有元素添加到默认的 <head> 元素。<br><br>通过省略 <head> 标签，您能够降低 HTML 的复杂性：<br><br>示例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;title&gt;Page Title&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;This is a heading&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p></p><ul><li>注释：对于 web 开发者，省略标签的做法是陌生的。建立规则需要时间。</li></ul><h5 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h5><p><code>&lt;title&gt;</code>元素在 HTML5 中是必需的。请尽可能制作有意义的标题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;HTML5 Syntax and Coding Style&lt;/title&gt;</span><br></pre></td></tr></table></figure><h5 id="为了确保恰当的解释，以及正确的搜索引擎索引，在文档中对语言和字符编码的定义越早越好："><a href="#为了确保恰当的解释，以及正确的搜索引擎索引，在文档中对语言和字符编码的定义越早越好：" class="headerlink" title="为了确保恰当的解释，以及正确的搜索引擎索引，在文档中对语言和字符编码的定义越早越好："></a>为了确保恰当的解释，以及正确的搜索引擎索引，在文档中对语言和字符编码的定义越早越好：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en-US"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;HTML5 Syntax and Coding Style&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><h5 id="HTML-注释"><a href="#HTML-注释" class="headerlink" title="HTML 注释"></a>HTML 注释</h5><p>短注释应该在单行中书写，并在 <code>&lt;!--</code> 之后增加一个空格，在 <code>&lt;!--</code> 之前增加一个空格：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- This is a comment --&gt;</span><br></pre></td></tr></table></figure><p>长注释，跨越多行，应该通过 <code>&lt;!--</code> 和 <code>--&gt;</code> 在独立的行中书写：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">This is a long comment example. This is a long comment example. This is a long comment example.</span><br><span class="line">This is a long comment example. This is a long comment example. This is a long comment example.</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p></p><p>长注释更易观察，如果它们被缩进两个空格的话。</p><h5 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h5><p>请使用简单的语法来链接样式表（type 属性不是必需的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"styles.css"</span>&gt;</span><br></pre></td></tr></table></figure><p>短规则可以压缩为一行，就像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.into &#123;font-family:<span class="string">"Verdana"</span>; font-size:16em;&#125;</span><br></pre></td></tr></table></figure><p>长规则应该分为多行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-color: lightgrey;</span><br><span class="line">  font-family: <span class="string">"Arial Black"</span>, Helvetica, sans-serif;</span><br><span class="line">  font-size: 16em;</span><br><span class="line">  color: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>开括号与选择器位于同一行</li><li>在开括号之前用一个空格</li><li>使用两个字符的缩进</li><li>在每个属性与其值之间使用冒号加一个空格</li><li>在每个逗号或分号之后使用空格</li><li>在每个属性值对（包括最后一个）之后使用分号</li><li>只在值包含空格时使用引号来包围值</li><li>把闭括号放在新的一行，之前不用空格</li><li>避免每行超过 80 个字符</li><li>注释：在逗号或分号之后添加空格，是所有书写类型的通用规则。</li></ul><h5 id="在-HTML-中加载-JavaScript"><a href="#在-HTML-中加载-JavaScript" class="headerlink" title="在 HTML 中加载 JavaScript"></a>在 <code>HTML</code> 中加载 JavaScript</h5><p>请使用简单的语法来加载外部脚本（type 属性不是必需的）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"myscript.js"</span>&gt;</span><br></pre></td></tr></table></figure><p></p><h5 id="通过-JavaScript-访问-HTML-元素"><a href="#通过-JavaScript-访问-HTML-元素" class="headerlink" title="通过 JavaScript 访问 HTML 元素"></a>通过 JavaScript 访问 HTML 元素<br></h5><p>使用“不整洁”的 HTML 样式的后果，是可能会导致 JavaScript 错误。<br></p><p>这两个 JavaScript 语句会产生不同的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = getElementById(<span class="string">"Demo"</span>)</span><br><span class="line"></span><br><span class="line">var obj = getElementById(<span class="string">"demo"</span>)</span><br></pre></td></tr></table></figure><p>如果可能，请在 HTML 中使用（与 JavaScript）相同的命名约定。</p><h5 id="使用小写文件名"><a href="#使用小写文件名" class="headerlink" title="使用小写文件名"></a>使用小写文件名</h5><p>大多数 web 服务器（Apache、Unix）对文件名的大小写敏感：</p><ul><li>不能以 <code>london.jpg</code> 访问 <code>London.jpg</code>。</li></ul><p>其他 web 服务器（微软，IIS）对大小写不敏感：</p><p>能够以 london.jpg 或 London.jpg 访问 London.jpg。</p><p>如果使用混合大小写，那么您必须保持高度的一致性。</p><p>如果您从对大小写不敏感的服务器转到一台对大小写敏感的服务器上，这些小错误将破坏您的网站。</p><p>为了避免这些问题，请始终使用小写文件名（如果可以的话）。</p><p>文件扩展名<br>HTML 文件名应该使用扩展名 .html（而不是 .htm）。</p><p>CSS 文件应该使用扩展名 .css。</p><p>JavaScript 文件应该使用扩展名 .js。</p></head></head></body></html></body></html>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;本篇内容转载自w3c&lt;br&gt;良好且优秀的代码习惯是必要的，无论是开发成本上，还是从赏心悦目的程度上&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;HTML-代码约定&quot;&gt;&lt;a href=&quot;#HTML-代码约定&quot; class=&quot;headerlink&quot; title=&quot;HTML 代码约定&quot;&gt;&lt;/a&gt;HTML 代码约定&lt;/h3&gt;&lt;p&gt;web 开发者常常不确定在 HTML 中使用的代码样式和语法。&lt;br&gt;通过 HTML5，您必须创建属于自己的最佳实践、样式指南和代码约定。&lt;br&gt;智能且有未来保证对样式的合乎逻辑的使用，可以令其他人更容易理解和使用您的 HTML。&lt;br&gt;&lt;br&gt;在未来，诸如 XML 阅读器之类的程序，也许需要阅读您的 HTML。&lt;br&gt;使用格式良好的“近似 XHTML 的”语法，能够更智能。&lt;/p&gt;&lt;h5 id=&quot;注释：&quot;&gt;&lt;a href=&quot;#注释：&quot; class=&quot;headerlink&quot; title=&quot;注释：&quot;&gt;&lt;/a&gt;注释：&lt;/h5&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;请始终保持您的样式智能、整洁、纯净、格式良好。&lt;br&gt;请使用正确的文档类型请始终在文档的首行声明文档类型：&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="html5" scheme="blog.yuanqinglong.cn/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title> 前端提交数据的那些方式</title>
    <link href="blog.yuanqinglong.cn/%E5%89%8D%E7%AB%AF%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E6%96%B9%E5%BC%8F.html"/>
    <id>blog.yuanqinglong.cn/前端提交数据的那些方式.html</id>
    <published>2018-05-18T13:40:11.000Z</published>
    <updated>2018-11-11T03:35:48.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明：本篇文章转自<a href="https://blog.csdn.net/dancen/article/details/37572101，" target="_blank" rel="noopener">https://blog.csdn.net/dancen/article/details/37572101，</a><br>相比其他浅显的文章，这篇更让我收获颇多，<br>另外，文章已略作修改，更易于自己理解<br>文章待完善</p></blockquote><p>Http定义了与服务器交互的不同方法，最基本的方法有很多种，今天要说的分别是<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>。<br><br>另外，关于<code>URL</code>：</p><ul><li>Uniform Resource Location 全称是资源定位符 (暂时不做和URI的区分)</li><li>用于请求获取具体路径上的资源</li></ul><p>HTTP中的<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>，对应的资源操作是————查，改，增，删。<br></p><ul><li><code>GET</code>一般用于获取/查询资源信息，</li><li><p><code>POST</code>一般用于更新资源信息。</p><a id="more"></a><h4 id="根据HTTP规范，GET-用于信息获取，而且应该是安全的和幂等的。"><a href="#根据HTTP规范，GET-用于信息获取，而且应该是安全的和幂等的。" class="headerlink" title="根据HTTP规范，GET 用于信息获取，而且应该是安全的和幂等的。"></a>根据HTTP规范，GET 用于信息获取，而且应该是安全的和幂等的。</h4></li><li><p>1)所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，<code>GET</code> 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。<br></p></li></ul><ul><li>注意：这里安全的含义仅仅是指是非修改信息。</li></ul><ul><li>2)幂等，意味着对同一 <code>URL</code> 的多个请求应该返回同样的结果。<ul><li>A. 概念：幂等（idempotent、idempotence)是一个数学或计算机学概念，常见于抽象代数中。</li><li>B. 幂等有一下几种定义：<br>-i. 对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有<code>abs(a)=abs(abs(a))</code>。<br>-ii. 对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。</li><li>C. 看完上述解释后，应该可以理解<code>GET</code>幂等的含义了。</li></ul></li></ul><p>但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回最新的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。</p><h4 id="根据HTTP规范，POST表示可能修改变服务器上的资源的请求。"><a href="#根据HTTP规范，POST表示可能修改变服务器上的资源的请求。" class="headerlink" title="根据HTTP规范，POST表示可能修改变服务器上的资源的请求。"></a>根据HTTP规范，<code>POST</code>表示可能修改变服务器上的资源的请求。</h4><ul><li>继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过<code>POST</code>实现，因为在评论提交后，我们已经将数据库里的数据项进行更新（插入了一天新的评论)操作，站点的资源已经不同了，或者说资源被修改了。</li></ul><p>上面大概说了一下HTTP规范中<code>GET</code>和<code>POST</code>的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，<br>比如说：</p><ul><li><p>1) 很多人贪方便，更新资源时用了<code>GET</code>，举个栗子来讲就是我们在跳转某个链接时可能需要附带相应参数才能跳转到相应的页面<a src="http://localhost:8080/test?name=lisi&age=12">(别试了，链接瞎写的，意思到了就行了)，而<code>POST</code>必须要到FORM（表单)，以及再上传文件时，我们必须表单里添加这样的属性<code>enctype = &quot;multipart/form-data&quot;</code>，相比知悉，简单与否，便知分晓。</a></p></li><li><p>2)对资源的增，删，改，查操作，其实都可以通过<code>GET</code>/<code>POST</code>完成，不需要用到<code>PUT</code>和<code>DELETE</code>（尴尬的PUT,DELETE)。</p></li><li><p>3)另外一个是，早期的Web MVC框架设计者们并没有有意识地将<code>URL</code>当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的Web MVC框架基本上都只支持<code>GET</code>和<code>POST</code>两种HTTP方法，而不支持<code>PUT</code>和<code>DELETE</code>方法。</p><ul><li>A. 简单解释一下MVC：MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。</li></ul></li></ul><p>以上3点典型地描述了老一套的风格（没有严格遵守HTTP规范)，随着架构的发展，现在出现<code>REST</code>(Representational State Transfer)，一套支持HTTP规范的新风格，这里不多说了，可以参考《RESTful Web Services》。</p><h4 id="说完原理性的问题，我们再从表面现像上面看看GET和POST的区别："><a href="#说完原理性的问题，我们再从表面现像上面看看GET和POST的区别：" class="headerlink" title="说完原理性的问题，我们再从表面现像上面看看GET和POST的区别："></a>说完原理性的问题，我们再从表面现像上面看看<code>GET</code>和<code>POST</code>的区别：</h4><ul><li><p>1) <code>GET</code>请求的数据会附在<code>URL</code>之后（就是把数据放置在HTTP协议头中)，以?分割<code>URL</code>和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。<br><code>POST</code>把提交的数据则放置在是HTTP包的包体中。</p></li><li><p>2) “<code>GET</code>方式提交的数据最多只能是1024字节，理论上<code>POST</code>没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！</p></li></ul><h4 id="其实这样说是错误的，不准确的："><a href="#其实这样说是错误的，不准确的：" class="headerlink" title="其实这样说是错误的，不准确的："></a>其实这样说是错误的，不准确的：</h4><ul><li><p>1) 首先是”<code>GET</code>方式提交的数据最多只能是1024字节”，因为<code>GET</code>是通过<code>URL</code>提交数据，那么<code>GET</code>可提交的数据量就跟<code>URL</code>的长度有直接关系了。而实际上，<code>URL</code>不存在参数上限的问题，HTTP协议规范没有对<code>URL</code>长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对<code>URL</code>长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。<br>&gt;<br><strong>注意这是限制是整个<code>URL</code>长度，而不仅仅是你的参数值数据长度。</strong></p></li><li><p>2) 理论上讲，<code>POST</code>是没有大小限制的，HTTP协议规范也没有进行大小限制，说“<code>POST</code>数据量存在80K/100K的大小限制”是不准确的，<code>POST</code>数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。</p><ul><li>A.对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用<code>Request.BinaryRead</code>则没有这个限制。</li><li>B.由这个延伸出去，对于IIS 6.0，微软出于安全考虑，加大了限制。我们还需要注意：<ul><li>i. IIS 6.0默认ASP <code>POST</code>数据量最大为200KB，每个表单域限制是100KB。</li><li>ii. IIS 6.0默认上传文件的最大大小是4MB。</li><li>iii. IIS 6.0默认最大请求头是16KB。</li><li>iv. IIS 6.0之前没有这些限制。</li></ul></li><li>所以上面的80K，100K可能只是默认值而已(注：关于IIS4和IIS5的参数，我还没有确认)，但肯定是可以自己设置的。由于每个版本的IIS对这些参数的默认值都不一样，具体请参考相关的IIS配置文档。</li></ul></li><li><p>3) 在ASP中，服务端获取<code>GET</code>请求参数用<code>Request.QueryString</code>，获取<code>POST</code>请求参数用<code>Request.Form</code>。在JSP中，用<code>request.getParameter(\&quot;XXXX\&quot;)</code>来获取，虽然jsp中也有<code>request.getQueryString()</code>方法，但使用起来比较麻烦，比如：传一个<code>test.jsp?name=hyddd&amp;password=hyddd</code>，用<code>request.getQueryString()</code>得到的是：<code>name=hyddd&amp;password=hyddd</code>。在PHP中，可以用<code>$_GET</code>和<code>$_POST</code>分别获取<code>GET</code>和<code>POST</code>中的数据，而<code>$_REQUEST</code>则可以获取<code>GET</code>和<code>POST</code>两种请求中的数据。值得注意的是，JSP中使用<code>request</code>和PHP中使用<code>$_REQUEST</code>都会有隐患。</p></li><li><p>4) <code>POST</code>的安全性要比<code>GET</code>的安全性高。注意：这里所说的安全性和上面<code>GET</code>提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过<code>GET</code>提交数据，用户名和密码将明文出现在<code>URL</code>上，因为:</p><ul><li>A. 登录页面有可能被浏览器缓存</li><li>B. 其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用<code>GET</code>提交数据还可能会造成Cross-Site Request Forgery(跨站请求伪造)攻击。</li><li>总结一下，<code>Get</code>是向服务器发索取数据的一种请求，而<code>Post</code>是向服务器提交数据的一种请求，在FORM（表单)中，Method默认为”<code>GET</code>“<br><br>实质上，<code>GET</code>和<code>POST</code>只是发送机制不同，并不是一个取一个发！</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;声明：本篇文章转自&lt;a href=&quot;https://blog.csdn.net/dancen/article/details/37572101，&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/dancen/article/details/37572101，&lt;/a&gt;&lt;br&gt;相比其他浅显的文章，这篇更让我收获颇多，&lt;br&gt;另外，文章已略作修改，更易于自己理解&lt;br&gt;文章待完善&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Http定义了与服务器交互的不同方法，最基本的方法有很多种，今天要说的分别是&lt;code&gt;GET&lt;/code&gt;，&lt;code&gt;POST&lt;/code&gt;，&lt;code&gt;PUT&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;。&lt;br&gt;&lt;br&gt;另外，关于&lt;code&gt;URL&lt;/code&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Uniform Resource Location 全称是资源定位符 (暂时不做和URI的区分)&lt;/li&gt;&lt;li&gt;用于请求获取具体路径上的资源&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;HTTP中的&lt;code&gt;GET&lt;/code&gt;，&lt;code&gt;POST&lt;/code&gt;，&lt;code&gt;PUT&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;，对应的资源操作是————查，改，增，删。&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;GET&lt;/code&gt;一般用于获取/查询资源信息，&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;POST&lt;/code&gt;一般用于更新资源信息。&lt;/p&gt;
    
    </summary>
    
      <category term="POST&amp;GET&amp;PUT&amp;DELETE" scheme="blog.yuanqinglong.cn/categories/POST-GET-PUT-DELETE/"/>
    
    
      <category term="POST&amp;GET&amp;PUT&amp;DELETE" scheme="blog.yuanqinglong.cn/tags/POST-GET-PUT-DELETE/"/>
    
  </entry>
  
  <entry>
    <title> 关于 Restful 接口的二三事</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8E-Restful-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B.html"/>
    <id>blog.yuanqinglong.cn/关于-Restful-接口的二三事.html</id>
    <published>2018-05-18T02:13:58.000Z</published>
    <updated>2018-06-26T12:17:18.530Z</updated>
    
    <content type="html"><![CDATA[<p>互联网的发展是是迅速的，然而，这也就意味着，在纷繁复杂的环境下，前后端要想更加有效率的配合，免不了需要一种成熟的API设计理念，如：<code>RESTful</code> API<br>关于restful接口的设计，近期看了一些博文，在这里谈一下收获</p><a id="more"></a><p>一、协议<br>API与用户的通信协议，总是使用HTTPs协议。</p><p>二、域名<br>应该尽量将API部署在专用域名之下。</p><p><a href="https://api.example.com" target="_blank" rel="noopener">https://api.example.com</a><br>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p><p><a href="https://example.org/api/" target="_blank" rel="noopener">https://example.org/api/</a><br>三、版本（Versioning）<br>应该将API的版本号放入URL。</p><p><a href="https://api.example.com/v1/" target="_blank" rel="noopener">https://api.example.com/v1/</a><br>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p><p>四、路径（Endpoint）<br>路径又称”终点”（endpoint），表示API的具体网址。</p><p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p><p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p><p><a href="https://api.example.com/v1/zoos" target="_blank" rel="noopener">https://api.example.com/v1/zoos</a><br><a href="https://api.example.com/v1/animals" target="_blank" rel="noopener">https://api.example.com/v1/animals</a><br><a href="https://api.example.com/v1/employees" target="_blank" rel="noopener">https://api.example.com/v1/employees</a><br>五、HTTP动词<br>对于资源的具体操作类型，由HTTP动词表示。</p><p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><p>GET（SELECT）：从服务器取出资源（一项或多项）。<br>POST（CREATE）：在服务器新建一个资源。<br>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。<br>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。<br>DELETE（DELETE）：从服务器删除资源。<br>还有两个不常用的HTTP动词。</p><p>HEAD：获取资源的元数据。<br>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。<br>下面是一些例子。</p><p>GET /zoos：列出所有动物园<br>POST /zoos：新建一个动物园<br>GET /zoos/ID：获取某个指定动物园的信息<br>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）<br>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）<br>DELETE /zoos/ID：删除某个动物园<br>GET /zoos/ID/animals：列出某个指定动物园的所有动物<br>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物<br>六、过滤信息（Filtering）<br>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p><p>下面是一些常见的参数。</p><p>?limit=10：指定返回记录的数量<br>?offset=10：指定返回记录的开始位置。<br>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。<br>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。<br>?animal_type_id=1：指定筛选条件<br>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p><p>七、状态码（Status Codes）<br>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><p>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。<br>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。<br>202 Accepted - [<em>]：表示一个请求已经进入后台排队（异步任务）<br>204 NO CONTENT - [DELETE]：用户删除数据成功。<br>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。<br>401 Unauthorized - [</em>]：表示用户没有权限（令牌、用户名、密码错误）。<br>403 Forbidden - [<em>] 表示用户得到授权（与401错误相对），但是访问是被禁止的。<br>404 NOT FOUND - [</em>]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。<br>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。<br>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。<br>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。<br>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。<br>状态码的完全列表参见这里。</p><p>八、错误处理（Error handling）<br>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p><p>{<br>error: “Invalid API key”<br>}<br>九、返回结果<br>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><p>GET /collection：返回资源对象的列表（数组）<br>GET /collection/resource：返回单个资源对象<br>POST /collection：返回新生成的资源对象<br>PUT /collection/resource：返回完整的资源对象<br>PATCH /collection/resource：返回完整的资源对象<br>DELETE /collection/resource：返回一个空文档<br>十、Hypermedia API<br>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p><p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><p>{“link”: {<br>“rel”: “collection <a href="https://www.example.com/zoos" target="_blank" rel="noopener">https://www.example.com/zoos</a>“,<br>“href”: “<a href="https://api.example.com/zoos" target="_blank" rel="noopener">https://api.example.com/zoos</a>“,<br>“title”: “List of zoos”,<br>“type”: “application/vnd.yourformat+json”<br>}}<br>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p><p>Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。</p><p>{<br>“current_user_url”: “<a href="https://api.github.com/user" target="_blank" rel="noopener">https://api.github.com/user</a>“,<br>“authorizations_url”: “<a href="https://api.github.com/authorizations" target="_blank" rel="noopener">https://api.github.com/authorizations</a>“,<br>// …<br>}<br>从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。</p><p>{<br>“message”: “Requires authentication”,<br>“documentation_url”: “<a href="https://developer.github.com/v3" target="_blank" rel="noopener">https://developer.github.com/v3</a>“<br>}<br>上面代码表示，服务器给出了提示信息，以及文档的网址。</p><p>十一、其他<br>（1）API的身份认证应该使用OAuth 2.0框架。</p><p>（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;互联网的发展是是迅速的，然而，这也就意味着，在纷繁复杂的环境下，前后端要想更加有效率的配合，免不了需要一种成熟的API设计理念，如：&lt;code&gt;RESTful&lt;/code&gt; API&lt;br&gt;关于restful接口的设计，近期看了一些博文，在这里谈一下收获&lt;/p&gt;
    
    </summary>
    
      <category term="Restful" scheme="blog.yuanqinglong.cn/categories/Restful/"/>
    
    
      <category term="Restful" scheme="blog.yuanqinglong.cn/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>关于ES6-变量的解构与赋值</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8EES6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E4%B8%8E%E8%B5%8B%E5%80%BC.html"/>
    <id>blog.yuanqinglong.cn/关于ES6-变量的解构与赋值.html</id>
    <published>2018-05-16T13:53:18.000Z</published>
    <updated>2018-05-18T13:29:52.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》<br>原文链接：<a href="http://es6.ruanyifeng.com/?search=import&amp;x=0&amp;y=0#docs/destructuring" target="_blank" rel="noopener">http://es6.ruanyifeng.com/?search=import&amp;x=0&amp;y=0#docs/destructuring</a><br>关于ES6,很多浏览器都已经实现支持其大部分的语法，以及，在很多框架里，如Vue.js,以及一些基于Node.js的框架，都可以看到类似ES6语法的影子</p></blockquote><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><p>####基本用法</p><ul><li>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</li><li>以前，为变量赋值，只能直接指定值。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 1;</span><br><span class="line"><span class="built_in">let</span> b = 2;</span><br><span class="line"><span class="built_in">let</span> c = 3;</span><br></pre></td></tr></table></figure><ul><li>ES6 允许写成下面这样。<a id="more"></a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [a, b, c] = [1, 2, 3];</span><br></pre></td></tr></table></figure><ul><li><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p></li><li><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class="line">foo // 1</span><br><span class="line">bar // 2</span><br><span class="line">baz // 3</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third // <span class="string">"baz"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x, , y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [head, ...tail] = [1, 2, 3, 4];</span><br><span class="line">head // 1</span><br><span class="line">tail // [2, 3, 4]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x // <span class="string">"a"</span></span><br><span class="line">y // undefined</span><br><span class="line">z // []</span><br></pre></td></tr></table></figure><ul><li>如果解构不成功，变量的值就等于<code>undefined</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [foo] = [];</span><br><span class="line"><span class="built_in">let</span> [bar, foo] = [1];</span><br></pre></td></tr></table></figure><ul><li><p>以上两种情况都属于解构不成功，foo的值都会等于<code>undefined</code>。</p></li><li><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x, y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [a, [b], d] = [1, [2, 3], 4];</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">d // 4</span><br></pre></td></tr></table></figure><ul><li><p>上面两个例子，都属于不完全解构，但是可以成功。</p></li><li><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="built_in">let</span> [foo] = 1;</span><br><span class="line"><span class="built_in">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">let</span> [foo] = NaN;</span><br><span class="line"><span class="built_in">let</span> [foo] = undefined;</span><br><span class="line"><span class="built_in">let</span> [foo] = null;</span><br><span class="line"><span class="built_in">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 <code>Iterator</code> 接口（前五个表达式），要么本身就不具备 <code>Iterator</code> 接口（最后一个表达式）。</p></li></ul><h3 id="对于-Set-结构，也可以使用数组的解构赋值。"><a href="#对于-Set-结构，也可以使用数组的解构赋值。" class="headerlink" title="对于 Set 结构，也可以使用数组的解构赋值。"></a>对于 Set 结构，也可以使用数组的解构赋值。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x, y, z] = new Set([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">x // <span class="string">"a"</span></span><br></pre></td></tr></table></figure><ul><li>事实上，只要某种数据结构具有 <code>Iterator</code> 接口，都可以采用数组形式的解构赋值。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">fibs</span></span>() &#123;</span><br><span class="line"><span class="built_in">let</span> a = 0;</span><br><span class="line"><span class="built_in">let</span> b = 1;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    yield a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth // 5</span><br></pre></td></tr></table></figure><ul><li>上面代码中，fibs是一个 <code>Generator</code> 函数（参见《Generator 函数》一章），原生具有 <code>Iterator</code> 接口。解构赋值会依次从这个接口获取值。</li></ul><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><ul><li>解构赋值允许指定默认值。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; // x=<span class="string">'a'</span>, y=<span class="string">'b'</span></span><br><span class="line"><span class="built_in">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, undefined]; // x=<span class="string">'a'</span>, y=<span class="string">'b'</span></span><br></pre></td></tr></table></figure><ul><li>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</li><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x = 1] = [undefined];</span><br><span class="line">x // 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x = 1] = [null];</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为null不严格等于<code>undefined</code>。</p></li><li><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">console.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x = f()] = [1];</span><br></pre></td></tr></table></figure><ul><li><p>上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([1][0] === undefined) &#123;</span><br><span class="line">x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x = [1][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x = 1, y = x] = [];     // x=1; y=1</span><br><span class="line"><span class="built_in">let</span> [x = 1, y = x] = [2];    // x=2; y=2</span><br><span class="line"><span class="built_in">let</span> [x = 1, y = x] = [1, 2]; // x=1; y=2</span><br><span class="line"><span class="built_in">let</span> [x = y, y = 1] = [];     // ReferenceError: y is not defined</span><br></pre></td></tr></table></figure></li><li><p>上面最后一个表达式之所以会报错，是因为<code>x</code>用<code>y</code>做默认值时，<code>y</code>还没有声明。</p></li></ul><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><ul><li><p>解构不仅可以用于数组，还可以用于对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; foo, bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo // <span class="string">"aaa"</span></span><br><span class="line">bar // <span class="string">"bbb"</span></span><br></pre></td></tr></table></figure></li><li><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，- 变量必须与属性同名，才能取到正确的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; bar, foo &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo // <span class="string">"aaa"</span></span><br><span class="line">bar // <span class="string">"bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz // undefined</span><br></pre></td></tr></table></figure></li><li><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。</p></li><li><p>如果变量名与属性名不一致，必须写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; foo: baz &#125; = &#123; foo: <span class="string">'aaa'</span>, bar: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz // <span class="string">"aaa"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = &#123; first: <span class="string">'hello'</span>, last: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="built_in">let</span> &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f // <span class="string">'hello'</span></span><br><span class="line">l // <span class="string">'world'</span></span><br></pre></td></tr></table></figure></li><li><p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; foo: foo, bar: bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; foo: baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz // <span class="string">"aaa"</span></span><br><span class="line">foo // error: foo is not defined</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p></li><li><p>与数组一样，解构也可以用于嵌套结构的对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; y: <span class="string">'World'</span> &#125;</span><br><span class="line">]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // <span class="string">"Hello"</span></span><br><span class="line">y // <span class="string">"World"</span></span><br></pre></td></tr></table></figure></li><li><p>注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; y: <span class="string">'World'</span> &#125;</span><br><span class="line">]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; p, p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // <span class="string">"Hello"</span></span><br><span class="line">y // <span class="string">"World"</span></span><br><span class="line">p // [<span class="string">"Hello"</span>, &#123;y: <span class="string">"World"</span>&#125;]</span><br></pre></td></tr></table></figure></li><li><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const node = &#123;</span><br><span class="line">loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">    line: 1,</span><br><span class="line">    column: 5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line // 1</span><br><span class="line">loc  // Object &#123;start: Object&#125;</span><br><span class="line">start // Object &#123;line: 1, column: 5&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。</p></li></ul><p>下面是嵌套赋值的例子。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">obj // &#123;prop:123&#125;</span><br><span class="line">arr // [<span class="literal">true</span>]</span><br></pre></td></tr></table></figure><p></p><h3 id="对象的解构也可以指定默认值。"><a href="#对象的解构也可以指定默认值。" class="headerlink" title="对象的解构也可以指定默认值。"></a>对象的解构也可以指定默认值。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var &#123;x = 3&#125; = &#123;&#125;;</span><br><span class="line">x // 3</span><br><span class="line"></span><br><span class="line">var &#123;x, y = 5&#125; = &#123;x: 1&#125;;</span><br><span class="line">x // 1</span><br><span class="line">y // 5</span><br><span class="line"></span><br><span class="line">var &#123;x: y = 3&#125; = &#123;&#125;;</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line">var &#123;x: y = 3&#125; = &#123;x: 5&#125;;</span><br><span class="line">y // 5</span><br><span class="line"></span><br><span class="line">var &#123; message: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</span><br><span class="line">msg // <span class="string">"Something went wrong"</span></span><br></pre></td></tr></table></figure><ul><li>默认值生效的条件是，对象的属性值严格等于undefined。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var &#123;x = 3&#125; = &#123;x: undefined&#125;;</span><br><span class="line">x // 3</span><br><span class="line"></span><br><span class="line">var &#123;x = 3&#125; = &#123;x: null&#125;;</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure><ul><li><p>上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。</p></li><li><p>如果解构失败，变量的值等于undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123;foo&#125; = &#123;bar: <span class="string">'baz'</span>&#125;;</span><br><span class="line">foo // undefined</span><br></pre></td></tr></table></figure></li><li><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="built_in">let</span> &#123;foo: &#123;bar&#125;&#125; = &#123;baz: <span class="string">'baz'</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> _tmp = &#123;baz: <span class="string">'baz'</span>&#125;;</span><br><span class="line">_tmp.foo.bar // 报错</span><br></pre></td></tr></table></figure></li><li><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;x: 1&#125;;</span><br><span class="line">// SyntaxError: syntax error</span><br></pre></td></tr></table></figure></li><li><p>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 正确的写法</span><br><span class="line"><span class="built_in">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;x: 1&#125;);</span><br></pre></td></tr></table></figure></li><li><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p></li><li><p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure></li><li><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p></li><li><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; <span class="built_in">log</span>, sin, cos &#125; = Math;</span><br></pre></td></tr></table></figure></li><li><p>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p></li><li><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1, 2, 3];</span><br><span class="line"><span class="built_in">let</span> &#123;0 : first, [arr.length - 1] : last&#125; = arr;</span><br><span class="line">first // 1</span><br><span class="line">last // 3</span><br></pre></td></tr></table></figure></li><li><p>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。</p></li></ul><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><ul><li><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a // <span class="string">"h"</span></span><br><span class="line">b // <span class="string">"e"</span></span><br><span class="line">c // <span class="string">"l"</span></span><br><span class="line">d // <span class="string">"l"</span></span><br><span class="line">e // <span class="string">"o"</span></span><br></pre></td></tr></table></figure></li><li><p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123;length : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len // 5</span><br></pre></td></tr></table></figure></li></ul><h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><ul><li><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123;toString: s&#125; = 123;</span><br><span class="line">s === Number.prototype.toString // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123;toString: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === Boolean.prototype.toString // <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p></li><li><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; prop: x &#125; = undefined; // TypeError</span><br><span class="line"><span class="built_in">let</span> &#123; prop: y &#125; = null; // TypeError</span><br></pre></td></tr></table></figure><h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><ul><li><p>函数的参数也可以使用解构赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add([x, y])&#123;</span><br><span class="line"><span class="built_in">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([1, 2]); // 3</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p></li><li><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);</span><br><span class="line">// [ 3, 7 ]</span><br><span class="line">函数参数的解构也可以使用默认值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line"><span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, 0]</span><br><span class="line">move(&#123;&#125;); // [0, 0]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</p></li><li><p>注意，下面的写法会得到不一样的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line"><span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, undefined]</span><br><span class="line">move(&#123;&#125;); // [undefined, undefined]</span><br><span class="line">move(); // [0, 0]</span><br><span class="line">上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</span><br><span class="line"></span><br><span class="line">undefined就会触发函数参数的默认值。</span><br><span class="line"></span><br><span class="line">[1, undefined, 3].map((x = <span class="string">'yes'</span>) =&gt; x);</span><br><span class="line">// [ 1, <span class="string">'yes'</span>, 3 ]</span><br></pre></td></tr></table></figure></li></ul><h4 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h4><ul><li><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p></li><li><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。<br>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p></li></ul><h3 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h3><ul><li>以下三种解构赋值不得使用圆括号。</li></ul><h4 id="（1）变量声明语句"><a href="#（1）变量声明语句" class="headerlink" title="（1）变量声明语句"></a>（1）变量声明语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line"><span class="built_in">let</span> [(a)] = [1];</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123;x: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> (&#123;x: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;</span><br></pre></td></tr></table></figure><ul><li>上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</li></ul><h4 id="（2）函数参数"><a href="#（2）函数参数" class="headerlink" title="（2）函数参数"></a>（2）函数参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数参数也属于变量声明，因此不能带有圆括号。</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> f([(z)]) &#123; <span class="built_in">return</span> z; &#125;</span><br><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> f([z,(x)]) &#123; <span class="built_in">return</span> x; &#125;</span><br></pre></td></tr></table></figure><p>####（3）赋值语句的模式<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line">(&#123; p: a &#125;) = &#123; p: 42 &#125;;</span><br><span class="line">([a]) = [5];</span><br></pre></td></tr></table></figure><p></p><ul><li>上面代码将整个模式放在圆括号之中，导致报错。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><ul><li>上面代码将一部分模式放在圆括号之中，导致报错。</li></ul><ul><li>可以使用圆括号的情况</li><li><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [3]; // 正确</span><br><span class="line">(&#123; p: (d) &#125; = &#123;&#125;); // 正确</span><br><span class="line">[(parseInt.prop)] = [3]; // 正确</span><br></pre></td></tr></table></figure></li><li><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p></li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>变量的解构赋值用途很多。</li></ul><p>####（1）交换变量的值<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x = 1;</span><br><span class="line"><span class="built_in">let</span> y = 2;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p></p><ul><li>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</li></ul><h4 id="（2）从函数返回多个值"><a href="#（2）从函数返回多个值" class="headerlink" title="（2）从函数返回多个值"></a>（2）从函数返回多个值</h4><ul><li>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 返回一个数组</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line">// 返回一个对象</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><h4 id="（3）函数参数的定义"><a href="#（3）函数参数的定义" class="headerlink" title="（3）函数参数的定义"></a>（3）函数参数的定义</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 解构赋值可以方便地将一组参数与变量名对应起来。</span><br><span class="line"></span><br><span class="line">    // 参数是一组有次序的值</span><br><span class="line">    <span class="keyword">function</span> f([x, y, z]) &#123; ... &#125;</span><br><span class="line">    f([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">    // 参数是一组无次序的值</span><br><span class="line">    <span class="keyword">function</span> f(&#123;x, y, z&#125;) &#123; ... &#125;</span><br><span class="line">    f(&#123;z: 3, y: 2, x: 1&#125;);</span><br></pre></td></tr></table></figure><h4 id="（4）提取-JSON-数据"><a href="#（4）提取-JSON-数据" class="headerlink" title="（4）提取 JSON 数据"></a>（4）提取 JSON 数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">解构赋值对提取 JSON 对象中的数据，尤其有用。</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> jsonData = &#123;</span><br><span class="line">id: 42,</span><br><span class="line">status: <span class="string">"OK"</span>,</span><br><span class="line">data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.log(id, status, number);</span><br><span class="line">// 42, <span class="string">"OK"</span>, [867, 5309]</span><br><span class="line">上面代码可以快速提取 JSON 数据的值。</span><br></pre></td></tr></table></figure><p>####（5）函数参数的默认值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    jQuery.ajax = <span class="keyword">function</span> (url, &#123;</span><br><span class="line">    async = <span class="literal">true</span>,</span><br><span class="line">    beforeSend = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">    cache = <span class="literal">true</span>,</span><br><span class="line">    complete = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">    crossDomain = <span class="literal">false</span>,</span><br><span class="line">    global = <span class="literal">true</span>,</span><br><span class="line">    // ... more config</span><br><span class="line">    &#125; = &#123;&#125;) &#123;</span><br><span class="line">    // ... <span class="keyword">do</span> stuff</span><br><span class="line">&#125;;</span><br><span class="line">指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || <span class="string">'default foo'</span>;这样的语句。</span><br></pre></td></tr></table></figure><h4 id="（6）遍历-Map-结构"><a href="#（6）遍历-Map-结构" class="headerlink" title="（6）遍历 Map 结构"></a>（6）遍历 Map 结构</h4><ul><li>任何部署了 <code>Iterator</code> 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 <code>Iterator</code> 接口，配合变量的解构赋值，获取键名和键值就非常方便。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of map) &#123;</span><br><span class="line">console.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br></pre></td></tr></table></figure><ul><li>如果只想获取键名，或者只想获取键值，可以写成下面这样。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取键名</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key] of map) &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取键值</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [,value] of map) &#123;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>}</p><h4 id="（7）输入模块的指定方法"><a href="#（7）输入模块的指定方法" class="headerlink" title="（7）输入模块的指定方法"></a>（7）输入模块的指定方法</h4><ul><li>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》&lt;br&gt;原文链接：&lt;a href=&quot;http://es6.ruanyifeng.com/?search=import&amp;amp;x=0&amp;amp;y=0#docs/destructuring&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://es6.ruanyifeng.com/?search=import&amp;amp;x=0&amp;amp;y=0#docs/destructuring&lt;/a&gt;&lt;br&gt;关于ES6,很多浏览器都已经实现支持其大部分的语法，以及，在很多框架里，如Vue.js,以及一些基于Node.js的框架，都可以看到类似ES6语法的影子&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;数组的解构赋值&quot;&gt;&lt;a href=&quot;#数组的解构赋值&quot; class=&quot;headerlink&quot; title=&quot;数组的解构赋值&quot;&gt;&lt;/a&gt;数组的解构赋值&lt;/h3&gt;&lt;p&gt;####基本用法&lt;/p&gt;&lt;ul&gt;&lt;li&gt;ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。&lt;/li&gt;&lt;li&gt;以前，为变量赋值，只能直接指定值。&lt;/li&gt;&lt;/ul&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; a = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; b = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; c = 3;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;ES6 允许写成下面这样。
    
    </summary>
    
      <category term="ES6" scheme="blog.yuanqinglong.cn/categories/ES6/"/>
    
    
      <category term="变量的解构与赋值" scheme="blog.yuanqinglong.cn/tags/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E4%B8%8E%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>算法基础———选择排序 </title>
    <link href="blog.yuanqinglong.cn/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html"/>
    <id>blog.yuanqinglong.cn/算法基础———选择排序.html</id>
    <published>2018-05-05T15:08:58.000Z</published>
    <updated>2018-05-05T15:47:02.099Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日积跬步，以期千里。<br>《算法基础·打开算法之门》小札</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>首先声明<code>array[i]</code>是目前所看到的子数组中最小的元素，然后扫描数组的剩余部分，每当发现一个有一个元素小于当前最小的元素时，我们就更新最小元素的索引</li></ul><hr><a id="more"></a><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ul><li>1.令i从0到n-1依次取值<ul><li>A. 将<code>smallest</code>赋值为 <code>i</code>.</li><li>B. 令<code>j</code>从<code>i+1</code>到n依次取值：<ul><li>i. 如果<code>A[j] &lt; A[smallest]</code>,那么将<code>smallest</code>赋值为j。</li></ul></li><li>C. 交换 <code>A[i]</code> 与 <code>A[smallest]</code>的值</li></ul></li></ul><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>选择排序的时间复杂度取决于外层循环的索引i。</p><ul><li>时间复杂度<code>O(n^2)</code></li><li>空间复杂度<code>O（1）</code></li></ul><h3 id="js程序代码"><a href="#js程序代码" class="headerlink" title="js程序代码"></a>js程序代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> selectionSort(arr) &#123;</span><br><span class="line">　　var len = arr.length;</span><br><span class="line">　　var smallest, temp;</span><br><span class="line">　　console.time(<span class="string">'选择排序耗时'</span>);</span><br><span class="line">　　<span class="keyword">for</span> (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">　　　　smallest = i;</span><br><span class="line">　　　　<span class="keyword">for</span> (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">　　　　　　<span class="keyword">if</span> (arr[j] &lt; arr[smallest]) &#123; //寻找最小的数</span><br><span class="line">　　　　　　　　smallest = j; //将最小数的索引保存</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　temp = arr[i];</span><br><span class="line">　　　　arr[i] = arr[smallest];</span><br><span class="line">　　　　arr[smallest] = temp;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(<span class="string">'选择排序耗时'</span>);</span><br><span class="line">　　<span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(selectionSort(arr));</span><br></pre></td></tr></table></figure><p>其实选择排序适合小数据排序，具体这个小数据有多小呢，简单的测试了一下，在1000条以内的数据，选择排序更胜冒泡排序。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;日积跬步，以期千里。&lt;br&gt;《算法基础·打开算法之门》小札&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;首先声明&lt;code&gt;array[i]&lt;/code&gt;是目前所看到的子数组中最小的元素，然后扫描数组的剩余部分，每当发现一个有一个元素小于当前最小的元素时，我们就更新最小元素的索引&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="算法基础" scheme="blog.yuanqinglong.cn/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="选择排序" scheme="blog.yuanqinglong.cn/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法基础之二分查找 </title>
    <link href="blog.yuanqinglong.cn/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"/>
    <id>blog.yuanqinglong.cn/算法基础之二分查找.html</id>
    <published>2018-05-04T13:24:14.000Z</published>
    <updated>2018-05-04T14:49:18.025Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在看《算法基础·打开算法之门》（毕竟程序猿的算法不能太差…）<br>人总是健忘的，所以我决定将我收获的东西记录下来<br>那么，首先，就是你了，最基础的二分查找！</p></blockquote><h3 id="关于二分查找，可以拥有如下叙述"><a href="#关于二分查找，可以拥有如下叙述" class="headerlink" title="关于二分查找，可以拥有如下叙述:"></a>关于二分查找，可以拥有如下叙述:</h3><ul><li>任意情况下，我们仅仅考虑某个子数组，也就是说，介于某两个索引之间的部分数组，将这两个索引依次记为p和r。初始时，p=1,r=n，因此开始时，子数组为整个完整数组，我们反复地将数组规模减半，直到一下任意一种情况发生：要么找到了要查找的元素，要么当前子数组为空（p&gt;r）。</li><li>反复对子数组执行减半操作需要的时间花费是<code>O(lgn)</code></li></ul><hr><a id="more"></a><h3 id="case-1"><a href="#case-1" class="headerlink" title="case-1"></a>case-1</h3><h4 id="逻辑："><a href="#逻辑：" class="headerlink" title="逻辑："></a>逻辑：</h4><h5 id="程序：binary-search-arr-n-x"><a href="#程序：binary-search-arr-n-x" class="headerlink" title="程序：binary-search(arr,n,x)"></a>程序：<code>binary-search(arr,n,x)</code></h5><h5 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h5><ul><li>arr:一个数组</li><li>n:数组中元素的个数</li><li>x要查找的值</li></ul><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><ul><li>满足条件的arr[i]的索引i，</li><li>特殊值‘not found’（相对于数组的任意无效索引值）</li></ul><h5 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h5><ul><li>1）将p赋值为1,r赋值为n</li><li>2）只要p &lt; = r,执行如下操作：<ul><li>A.将q赋值为(p + r) / 2 ———— ps:向下取整</li><li>B.如果A[q] = x,那么返回q。</li><li>C.否则（A[q] ! = x）,如果A[q]&gt;x,那么将r赋值为为q-1</li><li>D.否则（A[q] &lt; x），那么将p赋值为q+1</li></ul></li><li>3）返回“not found”</li></ul><h3 id="js代码实现"><a href="#js代码实现" class="headerlink" title="js代码实现"></a>js代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//默认由小到大排列数据</span><br><span class="line"><span class="keyword">function</span> binary-search(arr,n,x)&#123;</span><br><span class="line">    var p = 0;</span><br><span class="line">    var r = n-1;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; = r)&#123;</span><br><span class="line">        var q = Math.floor((p+r)/2);</span><br><span class="line">        <span class="keyword">if</span>(arr[q] == x)&#123;</span><br><span class="line">            <span class="built_in">return</span> q;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[q]&gt;x)&#123;</span><br><span class="line">                r = q - 1;       //真实上限索引要比x索引小，所以需要对数组上限重新取半赋值；</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = q + 1        //真实下限索引要比x索引大，所以需要对数组上限重新取半赋值；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'NOT FOUND !'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="case-2-递归的方式"><a href="#case-2-递归的方式" class="headerlink" title="case-2 (递归的方式)"></a>case-2 (递归的方式)</h3><h4 id="逻辑：-1"><a href="#逻辑：-1" class="headerlink" title="逻辑："></a>逻辑：</h4><h5 id="程序：recursive-binary-search-arr-p-r-x"><a href="#程序：recursive-binary-search-arr-p-r-x" class="headerlink" title="程序：recursive-binary-search(arr,p,r,x)"></a>程序：<code>recursive-binary-search(arr,p,r,x)</code></h5><h5 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h5><ul><li>相关变量同上文</li><li>增加p ,r 为数组arr的开头结尾索引</li></ul><h5 id="具体步骤-1"><a href="#具体步骤-1" class="headerlink" title="具体步骤"></a>具体步骤</h5><ul><li>1）如果p &gt; r,那么返回“not found”</li><li>2）否则(p &lt; = r),执行如下操作：<ul><li>A.将q赋值为(p + r) / 2  ———— ps:向下取整</li><li>B.如果A[q] = x,那么返回q。</li><li>C.否则（A[q] ! = x）,如果A[q] &gt; x,那么返回一个 recursive-binary-search(arr,p,q-1,x)</li><li>D.否则（A[q] &lt; x），那么返回一个 recursive-binary-search(arr,q+1,r,x)</li></ul></li></ul><h3 id="js代码实现-1"><a href="#js代码实现-1" class="headerlink" title="js代码实现"></a>js代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//默认由小到大排列数据</span><br><span class="line"><span class="keyword">function</span> recursive-binary-search(arr,p,r,x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &gt; r)&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'NOT FOUND !'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                      //p &lt; = r</span><br><span class="line">         var q = Math.floor((p + r) /  2);</span><br><span class="line">        <span class="keyword">if</span>(arr[q] == x)&#123;</span><br><span class="line">            <span class="built_in">return</span> q;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[q] &gt; x)&#123;</span><br><span class="line">               <span class="built_in">return</span> recursive-binary-search(arr,p,q-1,x);       //真实上限索引要比x索引小，所以需要对数组上限重新取半赋值；</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;               </span><br><span class="line">               <span class="built_in">return</span> recursive-binary-search(arr,q+1,r,x);       //真实下限索引要比x索引大，所以需要对数组上限重新取半赋值；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，以上的代码也许会有错误（好像没有…），因为只是单纯根据逻辑撸码，具体事件具体分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;最近在看《算法基础·打开算法之门》（毕竟程序猿的算法不能太差…）&lt;br&gt;人总是健忘的，所以我决定将我收获的东西记录下来&lt;br&gt;那么，首先，就是你了，最基础的二分查找！&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;关于二分查找，可以拥有如下叙述&quot;&gt;&lt;a href=&quot;#关于二分查找，可以拥有如下叙述&quot; class=&quot;headerlink&quot; title=&quot;关于二分查找，可以拥有如下叙述:&quot;&gt;&lt;/a&gt;关于二分查找，可以拥有如下叙述:&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;任意情况下，我们仅仅考虑某个子数组，也就是说，介于某两个索引之间的部分数组，将这两个索引依次记为p和r。初始时，p=1,r=n，因此开始时，子数组为整个完整数组，我们反复地将数组规模减半，直到一下任意一种情况发生：要么找到了要查找的元素，要么当前子数组为空（p&amp;gt;r）。&lt;/li&gt;&lt;li&gt;反复对子数组执行减半操作需要的时间花费是&lt;code&gt;O(lgn)&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="算法基础" scheme="blog.yuanqinglong.cn/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="二分查找" scheme="blog.yuanqinglong.cn/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>解决输入框长度maxLength的兼容性问题</title>
    <link href="blog.yuanqinglong.cn/%E8%A7%A3%E5%86%B3%E8%BE%93%E5%85%A5%E6%A1%86%E9%95%BF%E5%BA%A6maxLength%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98.html"/>
    <id>blog.yuanqinglong.cn/解决输入框长度maxLength的兼容性问题.html</id>
    <published>2018-04-11T12:18:30.000Z</published>
    <updated>2018-04-11T12:48:02.579Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在忙着做些东西，差点荒废了我的博客，随便写点什么吧</p></blockquote><p>在input标签中，只需要设置maxlength=”<em>*</em>”即可，但是在textarea标签中，IE9及IE9以下浏览器是不支持的，IE10、IE11则支持，估计后续的版本应该都会支持<br><a id="more"></a><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea id=<span class="string">"taContent"</span> rows=<span class="string">"3"</span>  maxlength=<span class="string">"20"</span> </span><br><span class="line">onchange=<span class="string">"this.value=this.value.substring(0, 20)"</span></span><br><span class="line">onkeydown=<span class="string">"this.value=this.value.substring(0, 20)"</span> </span><br><span class="line">onkeyup=<span class="string">"this.value=this.value.substring(0, 20)"</span> &gt;</span><br><span class="line">&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p></p><p>备注：<code>onchange</code>、<code>onkeydown</code>、<code>onkeyup</code>三者缺一不可。</p><p>如省略<code>onchange</code>，当你用负责功能，此时一直按着ctrl不松开，鼠标去点击其他地方（焦点移出textarea）时，不会自动取消超出部分；</p><p>如省略<code>onkeydown</code>，猛敲的时候会有很多个字符突然不见了；</p><p>如省略<code>onkeyup</code>，原想预计20的情况下，会变成21，并且最后一个字符是最后敲进去的。</p><p><code>Maxlength</code> 也不可省略，加上<code>maxlength</code> 当碰到IE10及以上版本时，可以完美的实现限制输入框字数的功能。不想其他低版本的IE浏览器还可以出现一个字母后消失。</p><blockquote><p>本方法参考自： <a href="http://www.thylx.net/newsdetail.aspx?id=37" target="_blank" rel="noopener">http://www.thylx.net/newsdetail.aspx?id=37</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;最近在忙着做些东西，差点荒废了我的博客，随便写点什么吧&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在input标签中，只需要设置maxlength=”&lt;em&gt;*&lt;/em&gt;”即可，但是在textarea标签中，IE9及IE9以下浏览器是不支持的，IE10、IE11则支持，估计后续的版本应该都会支持&lt;br&gt;
    
    </summary>
    
      <category term="HTML" scheme="blog.yuanqinglong.cn/categories/HTML/"/>
    
    
      <category term="maxLength" scheme="blog.yuanqinglong.cn/tags/maxLength/"/>
    
  </entry>
  
  <entry>
    <title>改变浏览器位置</title>
    <link href="blog.yuanqinglong.cn/%E6%94%B9%E5%8F%98%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%8D%E7%BD%AE.html"/>
    <id>blog.yuanqinglong.cn/改变浏览器位置.html</id>
    <published>2018-03-20T13:45:40.000Z</published>
    <updated>2018-03-20T14:27:49.721Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。</p></blockquote><p>实际上，就是改变浏览器的url，so，有哪些方法呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) location.assign(<span class="string">"http://www.wrox.com"</span>)</span><br><span class="line">2) window.location = <span class="string">"http://www.wrox.com"</span></span><br><span class="line">3) location.href = <span class="string">"http://www.wrox.com"</span></span><br></pre></td></tr></table></figure><p>当然，2）、3）其实都是调用了assign()方法的，只不过是形式不一样而已，</p><a id="more"></a><p> 另外，每次修改location的属性时，如<code>hostname</code>,<code>path</code>,<code>port</code>等时(<code>hash</code>除外)，页面都会以新的URL载入，<br> 注：<strong>无论以何种方式修改URL。都会在历史记录中生成一条新的纪录</strong> </p><p> 若要禁止这种行为（即生成一条新的纪录），可以使用replace()方法，该方法接受一个参数，即<strong>要导航到的URL</strong>。<br> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">location.replace(<span class="string">"http://www.wrox.com"</span>);</span><br></pre></td></tr></table></figure><p></p><p> 结果就是，同样会导致浏览器的位置改变，但是不会在历史记录生成新的纪录</p><p>最后一种改变浏览器位置的方法：<code>reload</code> </p><pre><code class="bash">reload //重新加载，可能是从个缓存中加载reload(<span class="literal">true</span>); //强制加载，即从服务器端加载</code></pre><p>注意：reload()调用后，也有可能不会立即执行，它取决于网络资源或系统延迟等，所以最好将<code>reload()</code>放在代码的最后一行</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;实际上，就是改变浏览器的url，so，有哪些方法呢？&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1) location.assign(&lt;span class=&quot;string&quot;&gt;&quot;http://www.wrox.com&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2) window.location = &lt;span class=&quot;string&quot;&gt;&quot;http://www.wrox.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3) location.href = &lt;span class=&quot;string&quot;&gt;&quot;http://www.wrox.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然，2）、3）其实都是调用了assign()方法的，只不过是形式不一样而已，&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="blog.yuanqinglong.cn/categories/javascript/"/>
    
    
      <category term="loaction" scheme="blog.yuanqinglong.cn/tags/loaction/"/>
    
  </entry>
  
  <entry>
    <title>找到数组的最值 </title>
    <link href="blog.yuanqinglong.cn/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%80%BC.html"/>
    <id>blog.yuanqinglong.cn/找到数组的最值.html</id>
    <published>2018-03-15T14:20:42.000Z</published>
    <updated>2018-03-15T16:01:23.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。</p></blockquote><p>在一个数组中找到最值，书中给了我们这样的一个方法（以最大值为例）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Values = [1,2,3];</span><br><span class="line">var max = Math.max.apply(Math,Values);</span><br><span class="line">var max = Math.max.apply(null,Values);</span><br></pre></td></tr></table></figure><a id="more"></a><p> <br></p><p>那么：<br>1）问题一，为什么是 <strong><code>Math.max.apply()</code></strong> ,而非 <strong><code>Math.max()</code></strong>?<br>答：  <code>max()</code>方法本身需要大于等于2个的纯数字参数<br>比如：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Math.max(10,20,30))//<span class="string">"30"</span></span><br><span class="line">console.log(Math.max(10,20))//<span class="string">"20"</span> </span><br><span class="line">console.log(Math.max(a,b));//ReferenceError: a is not defined</span><br></pre></td></tr></table></figure><p>很明显，<strong><code>Math.max()</code></strong> 的Values，只是一个变量，无法满足大于等于2，以及纯数字的两个条件，所以为满足要求（求数组里的最值），<strong><code>Math.max.apply()</code></strong>无疑是非常好的方法：</p><p>2）问题二，为什么是 <strong><code>Math.max.apply()</code></strong>,而非是 <strong><code>Math.max().apply()</code></strong><br>答：我们要明白两个知识点<br>     【1】 <strong><code>max()</code></strong> 与 <strong><code>max</code></strong> 的区别，函数名本质上是一个指向存储函数代码的内存地址的指针，单纯的写函数名并不会而函数名后面加括号如： <strong><code>max()</code></strong> ，则是对函数的调用执行。<br>     【2】 <strong><code>apply()</code></strong>  、 <strong><code>call()</code></strong> 是每个函数都包含的非继承的方法。作用是在 <strong>特定的作用域</strong> 中 <strong>调用函数</strong>。<br>     前者可以接受两个参数，后者可以接受两个及两个以上的参数。二者的第一个参数都是设置函数体内的 <strong><code>This</code></strong> 指向，即 <strong>“ 特定的作用域 ”</strong>。只写一个参数的情况下，默认设置的是 <strong><code>This</code></strong> 指向。<br>     而 <strong>调用函数</strong>，等价于函数名后面加括号的效果。<br>3）问题三， <strong><code>Math.max.apply(null,Values)</code></strong> 与 <strong><code>Math.max.apply(Math,Values)</code></strong> 区别？<br>答：没区别。<br>    因为第一个参数是 <strong>特定的作用域</strong> （也就是this指向），又因为，null，默认是前面的对象。而在本题中，前面的对象是Math，所以显而易见，二者结果并无区别。<br>，</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在一个数组中找到最值，书中给了我们这样的一个方法（以最大值为例）：&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var Values = [1,2,3];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var max = Math.max.apply(Math,Values);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var max = Math.max.apply(null,Values);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="blog.yuanqinglong.cn/categories/javascript/"/>
    
    
      <category term="apply、call" scheme="blog.yuanqinglong.cn/tags/apply%E3%80%81call/"/>
    
  </entry>
  
  <entry>
    <title>charAt与 indexOf与lastIndexOf </title>
    <link href="blog.yuanqinglong.cn/charAt%E4%B8%8E-indexOf%E4%B8%8ElastIndexOf.html"/>
    <id>blog.yuanqinglong.cn/charAt与-indexOf与lastIndexOf.html</id>
    <published>2018-03-13T14:12:38.000Z</published>
    <updated>2018-03-14T15:46:21.055Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。</p></blockquote><ul><li><h5 id="访问字符串中特定字符的方法是：charAt-amp-charCodeAt"><a href="#访问字符串中特定字符的方法是：charAt-amp-charCodeAt" class="headerlink" title="访问字符串中特定字符的方法是：charAt() &amp; charCodeAt()"></a>访问字符串中特定字符的方法是：<code>charAt()</code> &amp; <code>charCodeAt()</code></h5><a id="more"></a><pre><code class="bash">var stringValue = <span class="string">"hello world"</span>;alert(stringValue.charAt(1));//<span class="string">"e"</span>alert(stringValue.charCodeAt(1));//<span class="string">"101"</span></code></pre><p>上述代码中<br>1)前者<code>charAt()</code>输出的是指定位置的 <strong>字符</strong><br>2)后者<code>charCodeAt()</code>输出的是指定位置的<strong>字符串的编码</strong></p></li><li><h5 id="从字符串中查找子字符串的方法是：indexOf-amp-lastIndexOf"><a href="#从字符串中查找子字符串的方法是：indexOf-amp-lastIndexOf" class="headerlink" title="从字符串中查找子字符串的方法是：indexOf() &amp; lastIndexOf()"></a>从字符串中查找子字符串的方法是：<code>indexOf()</code> &amp; <code>lastIndexOf()</code></h5><pre><code class="bash">var stringValue = <span class="string">"hello world"</span>;alert(stringValue.indexOf(<span class="string">"o"</span>));//<span class="string">"4"</span>alert(stringValue.lastIndexOf(<span class="string">"o"</span>));//<span class="string">"7"</span></code></pre><p>上述代码中<br>无论是<code>indexOf()</code>还是<code>lastIndexOf()</code>，<br>返回的子字符串位置都是基于<strong>正向查询</strong> (始于0) 。<br>由此可知，<br>若子字符串在源字符串中<code>只出现过一次</code>，则两种方法返回相同的结果。<br>若<code>未找到</code>该字符串，则都返回<code>-1</code><br>而区别在于：<br>1）前者<code>indexOf()</code>方法，是从开头向后搜索字符串<br>2）后者<code>lastIndexOf()</code>方法，是从末尾向开头搜索字符串</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;h5 id=&quot;访问字符串中特定字符的方法是：charAt-amp-charCodeAt&quot;&gt;&lt;a href=&quot;#访问字符串中特定字符的方法是：charAt-amp-charCodeAt&quot; class=&quot;headerlink&quot; title=&quot;访问字符串中特定字符的方法是：charAt() &amp;amp; charCodeAt()&quot;&gt;&lt;/a&gt;访问字符串中特定字符的方法是：&lt;code&gt;charAt()&lt;/code&gt; &amp;amp; &lt;code&gt;charCodeAt()&lt;/code&gt;&lt;/h5&gt;
    
    </summary>
    
      <category term="javascript" scheme="blog.yuanqinglong.cn/categories/javascript/"/>
    
    
      <category term="字符串位置" scheme="blog.yuanqinglong.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>关于 ‘ + ’ 与 new Date</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8E-%E2%80%99-%E2%80%98-%E4%B8%8E-new-Date.html"/>
    <id>blog.yuanqinglong.cn/关于-’-‘-与-new-Date.html</id>
    <published>2018-03-09T13:35:49.000Z</published>
    <updated>2018-03-13T14:11:54.870Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在读《javascript高级程序设计（第三版）》时，遇到的一行代码<br><code>var start = +new Date()</code>;<br>那么，<code>+new Date()</code>是什么意思？虽然大概有些猜测,但，我还是决定查一查。</p></blockquote><p>Javascript中可以在某个元素前使用<code>+</code>号,<br>这个操作是将该元素转换成<code>Number</code>类型，如果转换失败，会得到<code>NAN</code>.<br><strong>注</strong>：<em>（适当的使用 运算符 可以简化 Number类型的转化过程）</em></p><a id="more"></a><p>所以 <code>+newDate</code>将会调用<code>Data.prototype</code>上的<code>valueOf</code>,<br>而且，查一查MDN，我们也可以知道，<br><code>Data.prototype.valueOf()</code>等价于<code>Date.prototype.getTime()</code>.</p><p>所以下列代码的效果是相同的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(+new Date);</span><br><span class="line">console.log(new Date().getTime());</span><br><span class="line">console.log(new Date().valueOf());</span><br><span class="line">console.log(new Date()*1);</span><br></pre></td></tr></table></figure><p>经过实际测试，以上所有代码都会返回当前时间的总毫秒数,（单纯的 <code>new Date</code>或<code>new Date()</code>会输出GMT时间， 如：Fri Mar 09 2018 22:17:43 GMT+0800 (中国标准时间)）</p><p>实际上，在上述代码中，<br>不止<code>+</code>号，在代码后面加上<code>*1</code>或者<code>/1</code>达到相同的输出效果</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;在读《javascript高级程序设计（第三版）》时，遇到的一行代码&lt;br&gt;&lt;code&gt;var start = +new Date()&lt;/code&gt;;&lt;br&gt;那么，&lt;code&gt;+new Date()&lt;/code&gt;是什么意思？虽然大概有些猜测,但，我还是决定查一查。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Javascript中可以在某个元素前使用&lt;code&gt;+&lt;/code&gt;号,&lt;br&gt;这个操作是将该元素转换成&lt;code&gt;Number&lt;/code&gt;类型，如果转换失败，会得到&lt;code&gt;NAN&lt;/code&gt;.&lt;br&gt;&lt;strong&gt;注&lt;/strong&gt;：&lt;em&gt;（适当的使用 运算符 可以简化 Number类型的转化过程）&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="blog.yuanqinglong.cn/categories/javascript/"/>
    
    
      <category term="逻辑运算符" scheme="blog.yuanqinglong.cn/tags/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>关于ajax，大概需要了解哪些基础性的东西？</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8Eajax%EF%BC%8C%E5%A4%A7%E6%A6%82%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%80%A7%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%9F.html"/>
    <id>blog.yuanqinglong.cn/关于ajax，大概需要了解哪些基础性的东西？.html</id>
    <published>2018-03-03T13:43:07.000Z</published>
    <updated>2018-03-04T12:31:16.586Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人总是健忘的，那么为什么不多动动手呢？比如说把知识记下来。<br>我们总会或有或无的接触ajax技术，那么作为一名学习者，就有必要了解相关的知识</p></blockquote><h3 id="ajax-客户端与服务器端异步的通信的技术-原理"><a href="#ajax-客户端与服务器端异步的通信的技术-原理" class="headerlink" title="ajax(客户端与服务器端异步的通信的技术)原理:"></a>ajax(客户端与服务器端异步的通信的技术)原理:</h3><p>相当于在用户和服务器之间加了—个中间层(AJAX引擎),<br>通过创建一个XmlHttpRequest对象来向服务器发异步请求,<br>通过回调在回调函数里进行dom操作.</p><ul><li><p>代码原理：</p><p>1.第一步：创建XMLHttpRequest 对象</p><pre><code>xmlhttp=new XMLHttpRequest();（它有兼容性问题，在ie中用的是new ActiveXObject）</code></pre><p>2.第二步：向服务器发送请求</p><pre><code>xmlhttp.open(&quot;GET/POST&quot;,url,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//POST时要加这句话xmlhttp.send();</code></pre><a id="more"></a><p>3.第三步：执行回调，在回调函数中进行相应的dom操作</p><pre><code>xmlhttp.onreadystatechange=function()  {  if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)//判断状态码    {    //就可以执行相应的dom操作    document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;    }  }</code></pre></li><li><p>readyState有5种值：</p><pre><code>0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪</code></pre></li><li><p>status状态码常见的有：</p><pre><code>200 服务器成功返回301 永久重定向302 临时重定向304 缓存403 服务器拒绝访问404 资源找不到500 服务器错误</code></pre><h3 id="优与劣"><a href="#优与劣" class="headerlink" title="优与劣"></a>优与劣</h3></li><li><h5 id="ajax的优点"><a href="#ajax的优点" class="headerlink" title="ajax的优点:"></a>ajax的优点:</h5><pre><code>&lt;1&gt;.无刷新更新数据。&lt;2&gt;.异步与服务器通信。&lt;3&gt;.前端和后端负载平衡。(减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担)&lt;4&gt;.基于标准被广泛支持。&lt;5&gt;.界面与应用分离。</code></pre></li><li><h5 id="ajax的缺点"><a href="#ajax的缺点" class="headerlink" title="ajax的缺点:"></a>ajax的缺点:</h5><pre><code>&lt;1&gt;.AJAX干掉了Back和History功能，即对浏览器机制的破坏。&lt;2&gt;.AJAX的安全问题。&lt;3&gt;.违背URL和资源定位的初衷。&lt;4&gt;.客户端过肥，太多客户端代码造成开发上的成本。</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;人总是健忘的，那么为什么不多动动手呢？比如说把知识记下来。&lt;br&gt;我们总会或有或无的接触ajax技术，那么作为一名学习者，就有必要了解相关的知识&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;ajax-客户端与服务器端异步的通信的技术-原理&quot;&gt;&lt;a href=&quot;#ajax-客户端与服务器端异步的通信的技术-原理&quot; class=&quot;headerlink&quot; title=&quot;ajax(客户端与服务器端异步的通信的技术)原理:&quot;&gt;&lt;/a&gt;ajax(客户端与服务器端异步的通信的技术)原理:&lt;/h3&gt;&lt;p&gt;相当于在用户和服务器之间加了—个中间层(AJAX引擎),&lt;br&gt;通过创建一个XmlHttpRequest对象来向服务器发异步请求,&lt;br&gt;通过回调在回调函数里进行dom操作.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;代码原理：&lt;/p&gt;&lt;p&gt;1.第一步：创建XMLHttpRequest 对象&lt;/p&gt;&lt;pre&gt;&lt;code&gt;xmlhttp=new XMLHttpRequest();（它有兼容性问题，在ie中用的是new ActiveXObject）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.第二步：向服务器发送请求&lt;/p&gt;&lt;pre&gt;&lt;code&gt;xmlhttp.open(&amp;quot;GET/POST&amp;quot;,url,true);
xmlhttp.setRequestHeader(&amp;quot;Content-type&amp;quot;,&amp;quot;application/x-www-form-urlencoded&amp;quot;);//POST时要加这句话
xmlhttp.send();
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="javascript" scheme="blog.yuanqinglong.cn/categories/javascript/"/>
    
    
      <category term="ajax" scheme="blog.yuanqinglong.cn/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>对CommonJS规范的一些理解</title>
    <link href="blog.yuanqinglong.cn/%E5%AF%B9CommonJS%E8%A7%84%E8%8C%83%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3.html"/>
    <id>blog.yuanqinglong.cn/对CommonJS规范的一些理解.html</id>
    <published>2018-02-28T11:03:21.000Z</published>
    <updated>2018-03-02T02:44:21.336Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>咸鱼了一个寒假，不能再这样了。。。<br>学海无涯啊0.0</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">example.js</span><br><span class="line">var x = 5;</span><br><span class="line">var addX = <span class="keyword">function</span> (value) &#123;</span><br><span class="line"><span class="built_in">return</span> value + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。</p></li><li><p>如果想在多个文件分享变量，必须定义为global对象的属性。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global.warning = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p> 上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。</p></li></ul><a id="more"></a><ul><li><p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 5;</span><br><span class="line">var addX = <span class="keyword">function</span> (value) &#123;</span><br><span class="line"><span class="built_in">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.x = x;</span><br><span class="line">module.exports.addX = addX;</span><br></pre></td></tr></table></figure><p> 上面代码通过module.exports输出变量x和函数addX。</p></li><li><p>require方法用于加载模块。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var example = require(<span class="string">'./example.js'</span>);</span><br><span class="line">console.log(example.x); // 5</span><br><span class="line">console.log(example.addX(1)); // 6</span><br></pre></td></tr></table></figure><p> require方法的详细解释参见《Require命令》一节。</p></li></ul><h4 id="CommonJS模块的特点如下"><a href="#CommonJS模块的特点如下" class="headerlink" title="CommonJS模块的特点如下:"></a>CommonJS模块的特点如下:</h4><blockquote><p>1.所有代码都运行在模块作用域，不会污染全局作用域。<br>2.模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了,以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。<br>3.模块加载的顺序，按照其在代码中出现的顺序。</p></blockquote><h3 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h3><ul><li><p>Node内部提供一个Module构建函数。所有模块都是Module的实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Module(id, parent) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">this.exports = &#123;&#125;;</span><br><span class="line">this.parent = parent;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure></li></ul><p>每个模块内部，都有一个module对象，代表当前模块。它有以下属性。</p><blockquote><p>module.id 模块的识别符，通常是带有绝对路径的模块文件名。<br>module.filename 模块的文件名，带有绝对路径。<br>module.loaded 返回一个布尔值，表示模块是否已经完成加载。<br>module.parent 返回一个对象，表示调用该模块的模块。<br>module.children 返回一个数组，表示该模块要用到的其他模    块。<br>module.exports 表示模块对外输出的值。</p></blockquote><ul><li><p>下面是一个示例文件，最后一行输出module变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var jquery = require(<span class="string">'jquery'</span>);</span><br><span class="line">exports.$ = jquery;</span><br><span class="line">console.log(module);</span><br></pre></td></tr></table></figure><p>执行这个文件，命令行会输出如下信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; id: <span class="string">'.'</span>,</span><br><span class="line">exports: &#123; <span class="string">'$'</span>: [Function] &#125;,</span><br><span class="line">parent: null,</span><br><span class="line">filename: <span class="string">'/path/to/example.js'</span>,</span><br><span class="line">loaded: <span class="literal">false</span>,</span><br><span class="line">children:</span><br><span class="line">[ &#123; id: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">    exports: [Function],</span><br><span class="line">    parent: [Circular],</span><br><span class="line">    filename: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">    loaded: <span class="literal">true</span>,</span><br><span class="line">    children: [],</span><br><span class="line">    paths: [Object] &#125; ],</span><br><span class="line">paths:</span><br><span class="line">[ <span class="string">'/home/user/deleted/node_modules'</span>,</span><br><span class="line">    <span class="string">'/home/user/node_modules'</span>,</span><br><span class="line">    <span class="string">'/home/node_modules'</span>,</span><br><span class="line">    <span class="string">'/node_modules'</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果在命令行下调用某个模块，比如node something.js，那么module.parent就是null。如果是在脚本之中调用，比如require(‘./something.js’)，那么module.parent就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!module.parent) &#123;</span><br><span class="line">      // ran with `node something.js`</span><br><span class="line">      app.listen(8088, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          console.log(<span class="string">'app listening on port 8088'</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      // used with `require(<span class="string">'/.something.js'</span>)`</span><br><span class="line">      module.exports = app;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="module-exports属性"><a href="#module-exports属性" class="headerlink" title="module.exports属性"></a>module.exports属性</h4><ul><li><p>module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var EventEmitter = require(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line">module.exports = new EventEmitter();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">module.exports.emit(<span class="string">'ready'</span>);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><p> 上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = require(<span class="string">'./a'</span>);</span><br><span class="line">a.on(<span class="string">'ready'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">console.log(<span class="string">'module a is ready'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="exports变量"><a href="#exports变量" class="headerlink" title="exports变量"></a>exports变量</h4><ul><li><p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var exports = module.exports;</span><br></pre></td></tr></table></figure><p>  造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports.area = <span class="keyword">function</span> (r) &#123;</span><br><span class="line"><span class="built_in">return</span> Math.PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.circumference = <span class="keyword">function</span> (r) &#123;</span><br><span class="line"><span class="built_in">return</span> 2 * Math.PI * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = <span class="keyword">function</span>(x) &#123;console.log(x)&#125;;</span><br></pre></td></tr></table></figure><p>  上面这样的写法是无效的，因为exports不再指向module.exports了。<br>  下面的写法也是无效的。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.hello = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">'hello'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = <span class="string">'Hello world'</span>;</span><br></pre></td></tr></table></figure><p>  上面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了。<br>  这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = <span class="keyword">function</span> (x)&#123; console.log(x);&#125;;</span><br></pre></td></tr></table></figure><p>  如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。</p></li></ul><h3 id="AMD规范与CommonJS规范的兼容性"><a href="#AMD规范与CommonJS规范的兼容性" class="headerlink" title="AMD规范与CommonJS规范的兼容性"></a>AMD规范与CommonJS规范的兼容性</h3><ul><li><p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。</p><p>  AMD规范使用define方法定义模块，下面就是一个例子：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'package/lib'</span>], <span class="keyword">function</span>(lib)&#123;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>()&#123;</span><br><span class="line">    lib.log(<span class="string">'hello world!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> &#123;</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  AMD规范允许输出的模块兼容CommonJS规范，这时define方法需要写成下面这样：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span> (require, exports, module)&#123;</span><br><span class="line">var someModule = require(<span class="string">"someModule"</span>);</span><br><span class="line">var anotherModule = require(<span class="string">"anotherModule"</span>);</span><br><span class="line"></span><br><span class="line">someModule.doTehAwesome();</span><br><span class="line">anotherModule.doMoarAwesome();</span><br><span class="line"></span><br><span class="line">exports.asplode = <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">    someModule.doTehAwesome();</span><br><span class="line">    anotherModule.doMoarAwesome();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="require命令"><a href="#require命令" class="headerlink" title="require命令"></a>require命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul><li><p>Node使用CommonJS模块规范，内置的require命令用于加载模块文件。</p><p>  require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var invisible = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">console.log(<span class="string">"invisible"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.message = <span class="string">"hi"</span>;</span><br><span class="line"></span><br><span class="line">exports.say = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">console.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行下面的命令，可以输出exports对象。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var example = require(<span class="string">'./example.js'</span>);</span><br><span class="line">example</span><br><span class="line">// &#123;</span><br><span class="line">//   message: <span class="string">"hi"</span>,</span><br><span class="line">//   say: [Function]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p>  如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定在module.exports变量上面。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        module.exports = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(<span class="string">"hello world"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        require(<span class="string">'./example2.js'</span>)()</span><br><span class="line">    ``` </span><br><span class="line">    上面代码中，require命令调用自身，等于是执行module.exports，因此会输出 hello world。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 加载规则</span></span><br><span class="line">-  require命令用于加载文件，后缀名默认为.js。</span><br><span class="line"></span><br><span class="line">    ```bash</span><br><span class="line">        var foo = require(<span class="string">'foo'</span>);</span><br><span class="line">        //  等同于</span><br><span class="line">        var foo = require(<span class="string">'foo.js'</span>);</span><br></pre></td></tr></table></figure><p>  根据参数的不同格式，require命令去不同路径寻找模块文件。</p><p>  （1）如果参数字符串以“<code>/</code>”开头，则表示加载的是一个位于绝对路径的模块文件。比如，<code>require(&#39;/home/marco/foo.js&#39;)</code>将加载<code>/home/marco/foo.js</code>。</p><p>  （2）如果参数字符串以“<code>./</code>”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，<code>require(&#39;./circle&#39;)</code>将加载当前脚本同一目录的<code>circle.js</code>。</p><p>  （3）如果参数字符串不以“<code>./</code>“或”<code>/</code>“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。<br>  <br><br>  举例来说，脚本<code>/home/user/projects/foo.js</code>执行了require<code>(&#39;bar.js&#39;)</code>命令，Node会依次搜索以下文件。</p><blockquote><p>/usr/local/lib/node/bar.js<br>/home/user/projects/node_modules/bar.js<br>/home/user/node_modules/bar.js<br>/home/node_modules/bar.js<br>/node_modules/bar.js</p></blockquote><p>  这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。</p><p>  （4）如果参数字符串不以“<code>./</code>“或”<code>/</code>“开头，而且是一个路径，<br>  比如<code>require(&#39;example-module/path/to/file&#39;)</code>，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</p><p>  （5）如果指定的模块文件没有发现，Node会尝试为文件名添加<code>.js</code>、<code>.json</code>、<code>.node</code>后，再去搜索。<code>.js</code>件会以文本格式的JavaScript脚本文件解析，<code>.json</code>文件会以JSON格式的文本文件解析，<code>.node</code>文件会以编译后的二进制文件解析。</p><p>  （6）如果想得到require命令加载的确切文件名，使用<code>require.resolve()</code>方法。</p></li></ul><h4 id="目录的加载规则"><a href="#目录的加载规则" class="headerlink" title="目录的加载规则"></a>目录的加载规则</h4><ul><li><p>通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录。<br><br><br>在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123; <span class="string">"name"</span> : <span class="string">"some-library"</span>,</span><br><span class="line"><span class="string">"main"</span> : <span class="string">"./lib/some-library.js"</span> &#125;</span><br></pre></td></tr></table></figure><p>require发现参数字符串指向一个目录以后，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件。如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件。</p></li></ul><h4 id="模块的缓存"><a href="#模块的缓存" class="headerlink" title="模块的缓存"></a>模块的缓存</h4><ul><li><p>第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的<code>module.exports</code>属性。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require(<span class="string">'./example.js'</span>);</span><br><span class="line">require(<span class="string">'./example.js'</span>).message = <span class="string">"hello"</span>;</span><br><span class="line">require(<span class="string">'./example.js'</span>).message</span><br><span class="line">// <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><p>  上面代码中，连续三次使用require命令，加载同一个模块。第二次加载的时候，为输出的对象添加了一个message属性。但是第三次加载的时候，这个message属性依然存在，这就证明require命令并没有重新加载模块文件，而是输出了缓存。</p><p>  如果想要多次执行某个模块，可以让该模块输出一个函数，然后每次require这个模块的时候，重新执行一下输出的函数。</p><p>  所有缓存的模块保存在<code>require.cache</code>之中，如果想删除模块的缓存，可以像下面这样写。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 删除指定模块的缓存</span><br><span class="line">delete require.cache[moduleName];</span><br><span class="line"></span><br><span class="line">// 删除所有模块的缓存</span><br><span class="line">Object.keys(require.cache).forEach(<span class="keyword">function</span>(key) &#123;</span><br><span class="line">delete require.cache[key];</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><pre><code>注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，require命令还是会重新加载该模块。</code></pre><h4 id="环境变量NODE-PATH"><a href="#环境变量NODE-PATH" class="headerlink" title="环境变量NODE_PATH"></a>环境变量<code>NODE_PATH</code></h4><ul><li><p>Node执行一个脚本时，会先查看环境变量NODE_PATH。它是一组以冒号分隔的绝对路径。在其他位置找不到指定模块时，Node会去这些路径查找。</p><p>可以将<code>NODE_PATH</code>添加到<code>.bashrc</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NODE_PATH=<span class="string">"/usr/local/lib/node"</span></span><br></pre></td></tr></table></figure><p>所以，如果遇到复杂的相对路径，比如下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myModule = require(<span class="string">'../../../../lib/myModule'</span>);</span><br></pre></td></tr></table></figure><p>有两种解决方法，一是将该文件加入node_modules目录，二是修改NODE_PATH环境变量，package.json文件可以采用下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"node_path"</span>,</span><br><span class="line"><span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line"><span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"NODE_PATH=lib node index.js"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NODE_PATH是历史遗留下来的一个路径解决方案，通常不应该使用，而应该使用node_modules目录机制。</p></li></ul><h4 id="模块的循环加载"><a href="#模块的循环加载" class="headerlink" title="模块的循环加载"></a>模块的循环加载</h4><ul><li><p>如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">exports.x = <span class="string">'a1'</span>;</span><br><span class="line">console.log(<span class="string">'a.js '</span>, require(<span class="string">'./b.js'</span>).x);</span><br><span class="line">exports.x = <span class="string">'a2'</span>;</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">exports.x = <span class="string">'b1'</span>;</span><br><span class="line">console.log(<span class="string">'b.js '</span>, require(<span class="string">'./a.js'</span>).x);</span><br><span class="line">exports.x = <span class="string">'b2'</span>;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./a.js'</span>).x);</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./b.js'</span>).x);</span><br></pre></td></tr></table></figure><p>上面代码是三个JavaScript文件。其中，a.js加载了b.js，而b.js又加载a.js。这时，Node返回a.js的不完整版本，所以执行结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">b.js  a1</span><br><span class="line">a.js  b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2</span><br></pre></td></tr></table></figure><p>修改main.js，再次加载a.js和b.js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./a.js'</span>).x);</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./b.js'</span>).x);</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./a.js'</span>).x);</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./b.js'</span>).x);</span><br></pre></td></tr></table></figure><p>执行上面代码，结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">b.js  a1</span><br><span class="line">a.js  b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2</span><br></pre></td></tr></table></figure><p>上面代码中，第二次加载a.js和b.js时，会直接从缓存读取exports属性，所以a.js和b.js内部的console.log语句都不会执行了。</p></li></ul><h4 id="require-main"><a href="#require-main" class="headerlink" title="require.main"></a>require.main</h4><ul><li><p>require方法有一个main属性，可以用来判断模块是直接执行，还是被调用执行。</p><p>直接执行的时候（node module.js），require.main属性指向模块本身。</p><pre><code>require.main === module// true</code></pre><p>调用执行的时候（通过require加载该脚本执行），上面的表达式返回false。</p></li></ul><h3 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h3><ul><li><p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。</p><p>下面是一个模块文件lib.js。</p><pre><code>// lib.jsvar counter = 3;function incCounter() {counter++;}module.exports = {counter: counter,incCounter: incCounter,};</code></pre><p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。</p><p>然后，加载上面的模块。</p><pre><code>// main.jsvar counter = require(&apos;./lib&apos;).counter;var incCounter = require(&apos;./lib&apos;).incCounter;console.log(counter);  // 3incCounter();console.log(counter); // 3</code></pre><p>上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。</p></li></ul><h4 id="require的内部处理流程"><a href="#require的内部处理流程" class="headerlink" title="require的内部处理流程"></a>require的内部处理流程</h4><ul><li><p>require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module._load = <span class="keyword">function</span>(request, parent, isMain) &#123;</span><br><span class="line">// 1. 检查 Module._cache，是否缓存之中有指定模块</span><br><span class="line">// 2. 如果缓存之中没有，就创建一个新的Module实例</span><br><span class="line">// 3. 将它保存到缓存</span><br><span class="line">// 4. 使用 module.load() 加载指定的模块文件，</span><br><span class="line">//    读取文件内容之后，使用 module.compile() 执行文件代码</span><br><span class="line">// 5. 如果加载/解析过程报错，就从缓存删除该模块</span><br><span class="line">// 6. 返回该模块的 module.exports</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype._compile = <span class="keyword">function</span>(content, filename) &#123;</span><br><span class="line">// 1. 生成一个require函数，指向module.require</span><br><span class="line">// 2. 加载其他辅助方法到require</span><br><span class="line">// 3. 将文件内容放到一个函数之中，该函数可调用 require</span><br><span class="line">// 4. 执行该函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的第1步和第2步，require函数及其辅助方法主要如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require(): 加载外部模块</span><br><span class="line">require.resolve()：将模块名解析到一个绝对路径</span><br><span class="line">require.main：指向主模块</span><br><span class="line">require.cache：指向所有缓存的模块</span><br><span class="line">require.extensions：根据文件的后缀名，调用不同的执行函数</span><br></pre></td></tr></table></figure><p>一旦require函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括require、module、exports，以及其他一些参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">// YOUR CODE INJECTED HERE!</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Module._compile方法是同步执行的，所以Module._load要等它执行完成，才会向用户返回module.exports的值。</p></li></ul><blockquote><p>本文引自阮一峰的文章<br>受益匪浅，由是感激！<br>链接：<a href="http://javascript.ruanyifeng.com/nodejs/module.html#" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/module.html#</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;咸鱼了一个寒假，不能再这样了。。。&lt;br&gt;学海无涯啊0.0&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;example.js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var x = 5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var addX = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (value) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; value + x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果想在多个文件分享变量，必须定义为global对象的属性。&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;global.warning = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CommonJS" scheme="blog.yuanqinglong.cn/tags/CommonJS/"/>
    
  </entry>
  
</feed>
