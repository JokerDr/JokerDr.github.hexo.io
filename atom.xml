<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>西伯利亚大尾巴狼</title>
  <icon>https://www.gravatar.com/avatar/7d9cee11c8c05e013b8780c0530e6e5b</icon>
  <subtitle>子非鱼，安知鱼之乐？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.yuanqinglong.cn/"/>
  <updated>2018-02-13T10:11:27.533Z</updated>
  <id>blog.yuanqinglong.cn/</id>
  
  <author>
    <name>袁庆龙</name>
    <email>yuanql96@yeah.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于ES6 const 篇</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8EES6-const-%E7%AF%87.html"/>
    <id>blog.yuanqinglong.cn/关于ES6-const-篇.html</id>
    <published>2018-02-02T13:19:24.000Z</published>
    <updated>2018-02-13T10:11:27.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》<br>原文链接：<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/let</a><br>学海无涯，愿与诸君共勉</p></blockquote><h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><ul><li>const声明一个只读的常量。一旦声明，常量的值就不能改变。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const PI = 3.1415;</span><br><span class="line">PI // 3.1415</span><br><span class="line"></span><br><span class="line">PI = 3;</span><br><span class="line">// TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure></li></ul><p>上面代码表明改变常量的值会报错。<br><a id="more"></a><br>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const foo;</span><br><span class="line">// SyntaxError: Missing initializer <span class="keyword">in</span> const declaration</span><br></pre></td></tr></table></figure><p></p><p>上面代码表示，对于const来说，只声明不赋值，就会报错。</p><ul><li><p>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MAX // Uncaught ReferenceError: MAX is not defined</span><br></pre></td></tr></table></figure></li><li><p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  console.log(MAX); // ReferenceError</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面代码在常量MAX声明之前就调用，结果报错。</p><ul><li>const声明的常量，也与let一样不可重复声明。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var message = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="built_in">let</span> age = 25;</span><br><span class="line"></span><br><span class="line">// 以下两行都会报错</span><br><span class="line">const message = <span class="string">"Goodbye!"</span>;</span><br><span class="line">const age = 30;</span><br></pre></td></tr></table></figure></li></ul><h5 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h5><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 为 foo 添加一个属性，可以成功</span><br><span class="line">foo.prop = 123;</span><br><span class="line">foo.prop // 123</span><br><span class="line"></span><br><span class="line">// 将 foo 指向另一个对象，就会报错</span><br><span class="line">foo = &#123;&#125;; // TypeError: <span class="string">"foo"</span> is <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><p>下面是另一个例子。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); // 可执行</span><br><span class="line">a.length = 0;    // 可执行</span><br><span class="line">a = [<span class="string">'Dave'</span>];    // 报错</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。</p><p>如果真的想将对象冻结，应该使用Object.freeze方法。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const foo = Object.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">// 常规模式时，下面一行不起作用；</span><br><span class="line">// 严格模式时，该行会报错</span><br><span class="line">foo.prop = 123;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var constantize = (obj) =&gt; &#123;</span><br><span class="line">  Object.freeze(obj);</span><br><span class="line">  Object.keys(obj).forEach( (key, i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> ( typeof obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h5 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h5><p>ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。</p><ul><li><h5 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h5>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.a = 1;</span><br><span class="line">a // 1</span><br><span class="line"></span><br><span class="line">a = 2;</span><br><span class="line">window.a // 2</span><br></pre></td></tr></table></figure></li></ul><p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p><p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">// 如果在 Node 的 REPL 环境，可以写成 global.a</span><br><span class="line">// 或者采用通用方法，写成 this.a</span><br><span class="line">window.a // 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = 1;</span><br><span class="line">window.b // undefined</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。</p><ul><li><h5 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h5>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</li></ul><p>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。<br>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。<br>Node 里面，顶层对象是global，但其他环境都不支持。<br>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</p><p>全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。<br>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。<br>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。<br>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 方法一</span><br><span class="line">(typeof window !== <span class="string">'undefined'</span></span><br><span class="line">   ? window</span><br><span class="line">   : (typeof process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      typeof require === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      typeof global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : this);</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">var getGlobal = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (typeof self !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (typeof window !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> window; &#125;</span><br><span class="line">  <span class="keyword">if</span> (typeof global !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> global; &#125;</span><br><span class="line">  throw new Error(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。</p><p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// CommonJS 的写法</span><br><span class="line">require(<span class="string">'system.global/shim'</span>)();</span><br><span class="line"></span><br><span class="line">// ES6 模块的写法</span><br><span class="line">import shim from <span class="string">'system.global/shim'</span>; shim();</span><br><span class="line">上面代码可以保证各种环境里面，global对象都是存在的。</span><br><span class="line"></span><br><span class="line">// CommonJS 的写法</span><br><span class="line">var global = require(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line">// ES6 模块的写法</span><br><span class="line">import getGlobal from <span class="string">'system.global'</span>;</span><br><span class="line">const global = getGlobal();</span><br></pre></td></tr></table></figure><p></p><p>上面代码将顶层对象放入变量global。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》&lt;br&gt;原文链接：&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://es6.ruanyifeng.com/#docs/let&lt;/a&gt;&lt;br&gt;学海无涯，愿与诸君共勉&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;const-命令&quot;&gt;&lt;a href=&quot;#const-命令&quot; class=&quot;headerlink&quot; title=&quot;const 命令&quot;&gt;&lt;/a&gt;const 命令&lt;/h3&gt;&lt;h5 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h5&gt;&lt;ul&gt;&lt;li&gt;const声明一个只读的常量。一旦声明，常量的值就不能改变。&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const PI = 3.1415;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PI // 3.1415&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PI = 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// TypeError: Assignment to constant variable.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面代码表明改变常量的值会报错。&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="blog.yuanqinglong.cn/categories/ES6/"/>
    
    
      <category term="const" scheme="blog.yuanqinglong.cn/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>关于ES6 : let 篇 </title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8EES6-let-%E7%AF%87.html"/>
    <id>blog.yuanqinglong.cn/关于ES6-let-篇.html</id>
    <published>2018-01-27T12:26:15.000Z</published>
    <updated>2018-02-13T10:11:05.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》<br>原文链接：<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/let</a><br>学海无涯，愿与诸君共勉</p></blockquote><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul><li><h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在<br>let命令所在的代码块内有效。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">let</span> a = 10;</span><br><span class="line">   var b = 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a // ReferenceError: a is not defined.</span><br><span class="line">b // 1</span><br></pre></td></tr></table></figure></li></ul><p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。<br><a id="more"></a><br>for循环的计数器，就很合适使用let命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i);</span><br><span class="line">// ReferenceError: i is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。</p><p>下面的代码如果使用var，最后输出的是10。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br></pre></td></tr></table></figure><p>上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。</p><p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p><p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  <span class="built_in">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br></pre></td></tr></table></figure><p></p><p>上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p><ul><li><h5 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h5>var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。<br>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// var 的情况</span><br><span class="line">console.log(foo); // 输出undefined</span><br><span class="line">var foo = 2;</span><br><span class="line"></span><br><span class="line">// <span class="built_in">let</span> 的情况</span><br><span class="line">console.log(bar); // 报错ReferenceError</span><br><span class="line"><span class="built_in">let</span> bar = 2;</span><br></pre></td></tr></table></figure></li></ul><p>上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</p><ul><li><h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; // ReferenceError</span><br><span class="line">  <span class="built_in">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  // TDZ开始</span><br><span class="line">  tmp = <span class="string">'abc'</span>; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> tmp; // TDZ结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。</p><p>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof x; // ReferenceError</span><br><span class="line"><span class="built_in">let</span> x;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。</p><p>作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof undeclared_variable // <span class="string">"undefined"</span></span><br></pre></td></tr></table></figure><p>上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p><p>有些“死区”比较隐蔽，不太容易发现。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bar(x = y, y = 2) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // 报错</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bar(x = 2, y = x) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); // [2, 2]</span><br></pre></td></tr></table></figure><p></p><p>另外，下面的代码也会报错，与var的行为不同。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">var x = x;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="built_in">let</span> x = x;</span><br><span class="line">// ReferenceError: x is not defined</span><br></pre></td></tr></table></figure><p></p><p>上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。</p><p>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><ul><li><h5 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h5>let不允许在相同作用域内，重复声明同一个变量。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> a = 10;</span><br><span class="line">  var a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> a = 10;</span><br><span class="line">  <span class="built_in">let</span> a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>因此，不能在函数内部重新声明参数。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> func(arg) &#123;</span><br><span class="line">  <span class="built_in">let</span> arg; // 报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> func(arg) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">let</span> arg; // 不报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><h5 id="块级作用域-1"><a href="#块级作用域-1" class="headerlink" title="块级作用域"></a>块级作用域</h5>为什么需要块级作用域？<br>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</li></ul><p>第一种场景，内层变量可能会覆盖外层变量。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    var tmp = <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure><p></p><p>上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><p>ES6 的块级作用域<br>let实际上为 JavaScript 新增了块级作用域。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> n = 5;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">let</span> n = 10;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(n); // 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。</p><p>ES6 允许块级作用域的任意嵌套。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p></p><p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">  console.log(insane); // 报错</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p></p><p>内层作用域可以定义外层作用域的同名变量。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="built_in">let</span> insane = <span class="string">'Hello World'</span>;</span><br><span class="line">  &#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p></p><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// IIFE 写法</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  var tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 块级作用域写法</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><h5 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h5>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</li></ul><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 情况一</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二</span><br><span class="line">try &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面两种函数声明，根据 ES5 的规定都是非法的。</p><p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    // 重复声明一次函数f</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p></p><p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ES5 环境</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p></p><p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p><p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p><p>允许在块级作用域内声明函数。<br>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。<br>同时，函数声明还会提升到所在的块级作用域的头部。<br>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p><p>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。</p><p>// 浏览器的 ES6 环境<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    // 重复声明一次函数f</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line">// Uncaught TypeError: f is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p></p><p>上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器的 ES6 环境</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  var f = undefined;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line">// Uncaught TypeError: f is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p></p><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明语句</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="built_in">let</span> f = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》&lt;br&gt;原文链接：&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://es6.ruanyifeng.com/#docs/let&lt;/a&gt;&lt;br&gt;学海无涯，愿与诸君共勉&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;h5 id=&quot;块级作用域&quot;&gt;&lt;a href=&quot;#块级作用域&quot; class=&quot;headerlink&quot; title=&quot;块级作用域&quot;&gt;&lt;/a&gt;块级作用域&lt;/h5&gt;ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在&lt;br&gt;let命令所在的代码块内有效。&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; a = 10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   var b = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a // ReferenceError: a is not defined.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b // 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="blog.yuanqinglong.cn/categories/ES6/"/>
    
    
      <category term="let" scheme="blog.yuanqinglong.cn/tags/let/"/>
    
  </entry>
  
  <entry>
    <title>关于object.key与object[key]的区别</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8Eobject-key%E4%B8%8Eobject-key-%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
    <id>blog.yuanqinglong.cn/关于object-key与object-key-的区别.html</id>
    <published>2018-01-24T07:01:27.000Z</published>
    <updated>2018-01-24T08:29:00.834Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录所需要的，摒弃多余的。<br>本篇文章是对segmentfault的一个问答的总结。</p></blockquote><h2 id="obeject-key与object-key-有什么区别"><a href="#obeject-key与object-key-有什么区别" class="headerlink" title="obeject.key与object[key]有什么区别?"></a>obeject.key与object[key]有什么区别?</h2><p>有什么区别，不试试怎么知道？</p><h5 id="测试代码（其实有很多栗子，随便举一个）："><a href="#测试代码（其实有很多栗子，随便举一个）：" class="headerlink" title="测试代码（其实有很多栗子，随便举一个）："></a>测试代码（其实有很多栗子，随便举一个）：</h5><pre><code> var obj = {    name: &apos;tom&apos;,    age: 22},someKey = &apos;age&apos;;        console.log(obj.name);   console.log(obj[&apos;name&apos;]); console.log(obj.someKey);  console.log(obj[someKey]);  </code></pre><a id="more"></a><h5 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h5><p>（放图）<br><img src="../imgs/blogContentImgs/2018-1-24-01.png" alt="Alt text" title="node 运行截图"></p><h5 id="通常来讲，-obj-“key”-与-obj-key-的作用差不多，但是，"><a href="#通常来讲，-obj-“key”-与-obj-key-的作用差不多，但是，" class="headerlink" title="通常来讲， obj[“key”]  与 obj.key 的作用差不多，但是，"></a>通常来讲， <em>obj[“key”]</em> 与 <em>obj.key</em> 的作用差不多，但是，</h5><ul><li>如果key不确定（key是变量）的情况下，</li><li>或者key的写法比较特殊（比如包含空格什么的）</li></ul><h5 id="则只能通过obj-的方式去访问"><a href="#则只能通过obj-的方式去访问" class="headerlink" title="则只能通过obj[ ]的方式去访问"></a>则只能通过<code>obj[ ]</code>的方式去访问</h5>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;记录所需要的，摒弃多余的。&lt;br&gt;本篇文章是对segmentfault的一个问答的总结。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;obeject-key与object-key-有什么区别&quot;&gt;&lt;a href=&quot;#obeject-key与object-key-有什么区别&quot; class=&quot;headerlink&quot; title=&quot;obeject.key与object[key]有什么区别?&quot;&gt;&lt;/a&gt;obeject.key与object[key]有什么区别?&lt;/h2&gt;&lt;p&gt;有什么区别，不试试怎么知道？&lt;/p&gt;&lt;h5 id=&quot;测试代码（其实有很多栗子，随便举一个）：&quot;&gt;&lt;a href=&quot;#测试代码（其实有很多栗子，随便举一个）：&quot; class=&quot;headerlink&quot; title=&quot;测试代码（其实有很多栗子，随便举一个）：&quot;&gt;&lt;/a&gt;测试代码（其实有很多栗子，随便举一个）：&lt;/h5&gt;&lt;pre&gt;&lt;code&gt; var obj = {
    name: &amp;apos;tom&amp;apos;,
    age: 22
},
someKey = &amp;apos;age&amp;apos;;        

console.log(obj.name);   
console.log(obj[&amp;apos;name&amp;apos;]); 
console.log(obj.someKey);  
console.log(obj[someKey]);  
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="json" scheme="blog.yuanqinglong.cn/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>Markdown常用语法</title>
    <link href="blog.yuanqinglong.cn/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html"/>
    <id>blog.yuanqinglong.cn/Markdown常用语法.html</id>
    <published>2018-01-22T12:49:29.000Z</published>
    <updated>2018-01-24T07:48:08.540Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写博客，自然免不了接触<strong>Markdown</strong>,作为初学者，为了即用即查，我决定把相关命令记录下来，本文就是边学边写<br>此处声明：本文是 <strong>参考他人的文章</strong>&amp;<strong>结合实践</strong>后，所写，另外，转载、复制随意，但请务必<strong>注明本文链接</strong></p></blockquote><h1 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h1><p>写法:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># h1级标题</span></span><br><span class="line"><span class="comment">## h2级标题</span></span><br><span class="line"><span class="comment">### h3级标题</span></span><br><span class="line"><span class="comment">#### h4级标题</span></span><br><span class="line"><span class="comment">##### h5级标题</span></span><br><span class="line"><span class="comment">###### h6级标题</span></span><br></pre></td></tr></table></figure><p></p><p>栗子：</p><ul><li><h4 id="这是一个h4级标题"><a href="#这是一个h4级标题" class="headerlink" title="这是一个h4级标题"></a>这是一个h4级标题</h4></li></ul><p>注意：</p><ul><li><code>#</code>与标题文字间要有<strong>空格</strong></li><li>当<code>-</code>与<code>#</code>结合使用时，如果不想下一行受到干扰，可以使用<kbd>Enter</kbd>换行   </li></ul><hr><a id="more"></a><h1 id="分割线："><a href="#分割线：" class="headerlink" title="分割线："></a>分割线：</h1><p>连续三个&amp;三个以上的<code>-</code> 即可作出分割线</p><h4 id="写法"><a href="#写法" class="headerlink" title="写法:"></a>写法:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="栗子："><a href="#栗子：" class="headerlink" title="栗子："></a>栗子：</h4><hr><p>注意：建议写分割线时，与上一行留出一空行</p><hr><h1 id="超链接："><a href="#超链接：" class="headerlink" title="超链接："></a>超链接：</h1><h4 id="写法1："><a href="#写法1：" class="headerlink" title="写法1："></a>写法1：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[连接名称](网址 , 标题)</span><br><span class="line"></span><br><span class="line">[baidu](https://www.baidu.com, <span class="string">"baidu"</span>)</span><br><span class="line">[&lt;i class=<span class="string">"icon-refresh"</span>&gt;&lt;/i&gt; 点我刷新](/<span class="comment">#)</span></span><br></pre></td></tr></table></figure><h4 id="栗子：-1"><a href="#栗子：-1" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><a href="https://www.baidu.com," title="baidu" target="_blank" rel="noopener">baidu</a></li><li><a href="/#"><i class="icon-refresh"></i> 点我刷新</a></li></ul><h4 id="写法2："><a href="#写法2：" class="headerlink" title="写法2："></a>写法2：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[链接名][链接代号]</span><br><span class="line">[链接代号]:详细地址</span><br><span class="line"></span><br><span class="line">[here][3]</span><br><span class="line">[3]: http://www.baidu.com</span><br></pre></td></tr></table></figure><h4 id="栗子：-2"><a href="#栗子：-2" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><a href="http://www.baidu.com" target="_blank" rel="noopener">here</a></li></ul><h4 id="写法3："><a href="#写法3：" class="headerlink" title="写法3："></a>写法3：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接展示链接：&lt;http://www.baidu.com&gt;</span><br></pre></td></tr></table></figure><h4 id="栗子：-3"><a href="#栗子：-3" class="headerlink" title="栗子："></a>栗子：</h4><ul><li>直接展示链接：<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li></ul><hr><h1 id="键盘键"><a href="#键盘键" class="headerlink" title="键盘键"></a>键盘键</h1><h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;kbd&gt;Ctrl+[&lt;/kbd&gt; and &lt;kbd&gt;Ctrl+]&lt;/kbd&gt;</span><br></pre></td></tr></table></figure><h4 id="栗子：-4"><a href="#栗子：-4" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><kbd>Ctrl+[</kbd> and <kbd>Ctrl+]</kbd></li></ul><hr><h1 id="code格式："><a href="#code格式：" class="headerlink" title="code格式："></a>code格式：</h1><p>反引号</p><h4 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Use the `<span class="built_in">printf</span>()` <span class="keyword">function</span>.</span><br><span class="line"> ``There is a literal backtick (`) here.针对在代码区段内插入反引号的情况`</span><br></pre></td></tr></table></figure><h4 id="栗子：-5"><a href="#栗子：-5" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><p>Use the <code>printf()</code> function.</p></li><li><p><code>There is a literal backtick (`) here.针对在代码区段内插入反引号的情况</code> </p></li></ul><hr><h1 id="强调："><a href="#强调：" class="headerlink" title="强调："></a>强调：</h1><h4 id="用法：-2"><a href="#用法：-2" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*斜体强调*</span><br><span class="line">**粗体强调**</span><br></pre></td></tr></table></figure><h4 id="栗子：-6"><a href="#栗子：-6" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><em>斜体强调</em></li><li><strong>粗体强调</strong></li></ul><hr><h1 id="图片："><a href="#图片：" class="headerlink" title="图片："></a>图片：</h1><h4 id="用法：-3"><a href="#用法：-3" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](../imgs/blogContentImgs/jhvh.jpg <span class="string">"这图我觉得扣得不错"</span>)</span><br><span class="line">如果图片链接失效的话，会显示 Alt text</span><br></pre></td></tr></table></figure><h4 id="栗子：-7"><a href="#栗子：-7" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><img src="../imgs/jhvh.jpg" alt="Alt text" title="这图我觉得扣得不错"></li></ul><h1 id="使用-icon-图标文字："><a href="#使用-icon-图标文字：" class="headerlink" title="使用 icon 图标文字："></a>使用 icon 图标文字：</h1><h4 id="用法：-4"><a href="#用法：-4" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=<span class="string">"fa fa-github"</span>&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure><h4 id="栗子：-8"><a href="#栗子：-8" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><i class="fa fa-github"></i></li></ul><hr><h1 id="段落："><a href="#段落：" class="headerlink" title="段落："></a>段落：</h1><p> 以一个空行开始，以一个空行结束，中间的就是一个段落。</p><hr><h1 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h1><h4 id="用法：-5"><a href="#用法：-5" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Item     | Value</span><br><span class="line">-------- | ---</span><br><span class="line">Computer | <span class="variable">$1600</span></span><br><span class="line">Phone    | <span class="variable">$12</span></span><br><span class="line">Pipe     | <span class="variable">$1</span></span><br></pre></td></tr></table></figure><h4 id="栗子：-9"><a href="#栗子：-9" class="headerlink" title="栗子："></a>栗子：</h4><table><thead><tr><th>Item</th><th>Value</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><hr><h1 id="无序列表："><a href="#无序列表：" class="headerlink" title="无序列表："></a>无序列表：</h1><p>使用 - 加一个空格</p><h4 id="用法：-6"><a href="#用法：-6" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 无需列表1</span><br><span class="line">- 无序列表2</span><br><span class="line">- 无序列表3</span><br></pre></td></tr></table></figure><h4 id="栗子：-10"><a href="#栗子：-10" class="headerlink" title="栗子："></a>栗子：</h4><ul><li>无需列表1</li><li>无序列表2</li><li>无序列表3</li></ul><hr><h1 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a>有序列表：</h1><p>使用 数字 加一个英文句点</p><h4 id="用法：-7"><a href="#用法：-7" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表</span><br><span class="line">2. 有序列表</span><br><span class="line">3. 有序列表</span><br><span class="line">4. 有序列表</span><br><span class="line">5. 有序列表</span><br></pre></td></tr></table></figure><h4 id="栗子：-11"><a href="#栗子：-11" class="headerlink" title="栗子："></a>栗子：</h4><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><hr><h1 id="换行缩进形成代码区块："><a href="#换行缩进形成代码区块：" class="headerlink" title="换行缩进形成代码区块："></a>换行缩进形成代码区块：</h1><h4 id="用法：-8"><a href="#用法：-8" class="headerlink" title="用法："></a>用法：</h4><pre><code>这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。    </code></pre><h4 id="栗子：-12"><a href="#栗子：-12" class="headerlink" title="栗子："></a>栗子：</h4><pre><code>这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。    </code></pre><hr><h1 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h1><h4 id="用法：-9"><a href="#用法：-9" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;给引用的文本开始位置都加一个 <span class="string">'&gt;'</span>，</span><br><span class="line">&gt;便可组成一个块引用。在块引用中，可以结合</span><br><span class="line">&gt;其他markdown元素一块使用，比如列表。</span><br><span class="line">&gt;**强调**</span><br><span class="line">也可以只在第一行加大于号，其他位置不加。</span><br><span class="line"></span><br><span class="line">&gt;- 块引用里使用列表，需要和上面的内容隔开一个空行</span><br><span class="line">&gt;- 记得加空格哦。</span><br></pre></td></tr></table></figure><h4 id="栗子：-13"><a href="#栗子：-13" class="headerlink" title="栗子："></a>栗子：</h4><blockquote><p>给引用的文本开始位置都加一个 ‘&gt;’，<br>便可组成一个块引用。在块引用中，可以结合<br>其他markdown元素一块使用，比如列表。<br><strong>强调</strong><br>也可以只在第一行加大于号，其他位置不加。</p><ul><li>块引用里使用列表，需要和上面的内容隔开一个空行</li><li>记得加空格哦。</li></ul></blockquote><hr><blockquote><p>本文参考链接：<br>[掌握这几种 Markdown 语法你就够了]<br><a href="https://laravel-china.org/topics/621/you-will-be-able-to-master-these-markdown-grammars" target="_blank" rel="noopener">https://laravel-china.org/topics/621/you-will-be-able-to-master-these-markdown-grammars</a><br>[中文文案排版指北]<br>:<a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">https://github.com/sparanoid/chinese-copywriting-guidelines</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;写博客，自然免不了接触&lt;strong&gt;Markdown&lt;/strong&gt;,作为初学者，为了即用即查，我决定把相关命令记录下来，本文就是边学边写&lt;br&gt;此处声明：本文是 &lt;strong&gt;参考他人的文章&lt;/strong&gt;&amp;amp;&lt;strong&gt;结合实践&lt;/strong&gt;后，所写，另外，转载、复制随意，但请务必&lt;strong&gt;注明本文链接&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;标题：&quot;&gt;&lt;a href=&quot;#标题：&quot; class=&quot;headerlink&quot; title=&quot;标题：&quot;&gt;&lt;/a&gt;标题：&lt;/h1&gt;&lt;p&gt;写法:&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# h1级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## h2级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;### h3级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#### h4级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;##### h5级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;###### h6级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;栗子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;这是一个h4级标题&quot;&gt;&lt;a href=&quot;#这是一个h4级标题&quot; class=&quot;headerlink&quot; title=&quot;这是一个h4级标题&quot;&gt;&lt;/a&gt;这是一个h4级标题&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt;与标题文字间要有&lt;strong&gt;空格&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;-&lt;/code&gt;与&lt;code&gt;#&lt;/code&gt;结合使用时，如果不想下一行受到干扰，可以使用&lt;kbd&gt;Enter&lt;/kbd&gt;换行   &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="Markdown" scheme="blog.yuanqinglong.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>原生JS实现jQuery的addClass, removeClass, hasClass函数功能</title>
    <link href="blog.yuanqinglong.cn/%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0jQuery%E7%9A%84addClass,%20removeClass,%20hasClass%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD.html"/>
    <id>blog.yuanqinglong.cn/原生JS实现jQuery的addClass, removeClass, hasClass函数功能.html</id>
    <published>2018-01-20T15:21:08.000Z</published>
    <updated>2018-01-23T03:24:21.892Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-addClass"><a href="#1-addClass" class="headerlink" title="- [1] addClass"></a>- [1] addClass</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function addClass(obj, cls)&#123;</span><br><span class="line">    var obj_class = obj.className;//获取 class 内容.</span><br><span class="line">    var blank = (obj_class != &apos;&apos;) ? &apos; &apos; : &apos;&apos;;//判断获取到的 class 是否为空, 如果不为空在前面加个&apos;空格&apos;.</span><br><span class="line">    var added = obj_class + blank + cls;//组合原来的 class 和需要添加的 class.</span><br><span class="line">    obj.className = added;//替换原来的 class.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-removeClass"><a href="#2-removeClass" class="headerlink" title="- [2]  removeClass"></a>- [2]  removeClass</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function removeClass(obj, cls)&#123;</span><br><span class="line">    var obj_class = &apos; &apos;+obj.className+&apos; &apos;;//获取 class 内容, 并在首尾各加一个空格. ex) &apos;abc        bcd&apos; -&gt; &apos; abc        bcd &apos;</span><br><span class="line">    obj_class = obj_class.replace(/(\s+)/gi, &apos; &apos;),//将多余的空字符替换成一个空格. ex) &apos; abc        bcd &apos; -&gt; &apos; abc bcd &apos;</span><br><span class="line">    var removed = obj_class.replace(&apos; &apos;+cls+&apos; &apos;, &apos; &apos;);//在原来的 class 替换掉首尾加了空格的 class. ex) &apos; abc bcd &apos; -&gt; &apos;bcd &apos;</span><br><span class="line">    removed = removed.replace(/(^\s+)|(\s+$)/g, &apos;&apos;);//去掉首尾空格. ex) &apos;bcd &apos; -&gt; &apos;bcd&apos;</span><br><span class="line">    obj.className = removed;//替换原来的 class.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-hasClass"><a href="#3-hasClass" class="headerlink" title="- [3]  hasClass"></a>- [3]  hasClass</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function hasClass(obj, cls)&#123;</span><br><span class="line">    var obj_class = obj.className;//获取 class 内容.</span><br><span class="line">    var obj_class_lst = obj_class.split(/\s+/);//通过split空字符将cls转换成数组.</span><br><span class="line">    var x = 0;</span><br><span class="line">    for(x in obj_class_lst) &#123;</span><br><span class="line">        if(obj_class_lst[x] == cls) &#123;//循环数组, 判断是否包含cls</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="原文链接-link"><a href="#原文链接-link" class="headerlink" title="==原文链接   ++link++=="></a>==<strong>原文链接</strong>   ++<a href="https://lvwenhan.com/web-front/374.html" target="_blank" rel="noopener">link</a>++==</h6><blockquote><h4 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h4></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断样式是否存在</span><br><span class="line"> */</span><br><span class="line">function hasClass(obj, cls) &#123;</span><br><span class="line">  return obj.className.match(new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 为指定的dom元素添加样式</span><br><span class="line"> */</span><br><span class="line">function addClass(obj, cls) &#123;</span><br><span class="line">  if (!this.hasClass(obj, cls)) obj.className += &quot; &quot; + cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除指定dom元素的样式</span><br><span class="line"> */</span><br><span class="line">function removeClass(obj, cls) &#123;</span><br><span class="line">  if (hasClass(obj, cls)) &#123;</span><br><span class="line">    var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;);</span><br><span class="line">    obj.className = obj.className.replace(reg, &apos; &apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果存在(不存在)，就删除(添加)一个样式</span><br><span class="line"> */</span><br><span class="line">function toggleClass(obj, cls) &#123;</span><br><span class="line">  if (hasClass(obj, cls)) &#123;</span><br><span class="line">    removeClass(obj, cls);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    addClass(obj, cls);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="原文链接-link-1"><a href="#原文链接-link-1" class="headerlink" title="==原文链接   ++link++=="></a>==<strong>原文链接</strong>   ++<a href="http://www.edaoe.com/560.html" target="_blank" rel="noopener">link</a>++==</h6>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-addClass&quot;&gt;&lt;a href=&quot;#1-addClass&quot; class=&quot;headerlink&quot; title=&quot;- [1] addClass&quot;&gt;&lt;/a&gt;- [1] addClass&lt;/h4&gt;&lt;hr&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function addClass(obj, cls)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var obj_class = obj.className;//获取 class 内容.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var blank = (obj_class != &amp;apos;&amp;apos;) ? &amp;apos; &amp;apos; : &amp;apos;&amp;apos;;//判断获取到的 class 是否为空, 如果不为空在前面加个&amp;apos;空格&amp;apos;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var added = obj_class + blank + cls;//组合原来的 class 和需要添加的 class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj.className = added;//替换原来的 class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jquery" scheme="blog.yuanqinglong.cn/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>css解决背景透明的兼容性问题</title>
    <link href="blog.yuanqinglong.cn/css%E8%A7%A3%E5%86%B3%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98.html"/>
    <id>blog.yuanqinglong.cn/css解决背景透明的兼容性问题.html</id>
    <published>2018-01-19T01:33:33.000Z</published>
    <updated>2018-01-22T12:54:39.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全浏览器兼容背景半透明的问题的么几个解决方案："><a href="#全浏览器兼容背景半透明的问题的么几个解决方案：" class="headerlink" title="全浏览器兼容背景半透明的问题的么几个解决方案："></a>全浏览器兼容背景半透明的问题的么几个解决方案：</h3><h5 id="1-使用半透明png图片平铺"><a href="#1-使用半透明png图片平铺" class="headerlink" title="1.使用半透明png图片平铺"></a>1.使用半透明png图片平铺</h5><h5 id="2-使用opcacity属性"><a href="#2-使用opcacity属性" class="headerlink" title="2.使用opcacity属性"></a>2.使用opcacity属性</h5><h5 id="3-使用rgba和IE的opacity滤镜属性结合"><a href="#3-使用rgba和IE的opacity滤镜属性结合" class="headerlink" title="3.使用rgba和IE的opacity滤镜属性结合"></a>3.使用rgba和IE的opacity滤镜属性结合</h5><a id="more"></a><h4 id="RGBA颜色"><a href="#RGBA颜色" class="headerlink" title="RGBA颜色"></a>RGBA颜色</h4><hr><p>rgba颜色的四个属性分别表示 red红色、green绿色、blue蓝色、alpha透明度。通过这几个数值能够轻松实现背景透明。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.backTtansparent&#123;</span><br><span class="line">/* 用于不支持RGBa的浏览器 */</span><br><span class="line">background: rgb(0, 0, 0);</span><br><span class="line">/* RGBa, 透明度0.6 */</span><br><span class="line">background: rgba(0, 0, 0, 0.6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样透明只对背景生效，对于非 ie 浏览器是非常完美的解决方案。<br>不幸的是 ie8 及以下不支持 rgba 属性，并且经测试 ie9 会把 rgba 解析为全透明。</p><h4 id="IE的filter"><a href="#IE的filter" class="headerlink" title="IE的filter"></a>IE的filter</h4><hr><p>通过background: transparent注释可解决 ie9 解析rgba全透明问题。通过ie 的 filter 属性便可让 ie 支持背景透明。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.backTtansparent&#123;</span><br><span class="line">background: transparent/9;</span><br><span class="line">/* For IE 5.5 - 7*/</span><br><span class="line">filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);</span><br><span class="line">/* For IE 8*/</span><br><span class="line">-ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>能够看到filter中的8位16进制的半透明颜色#99000000为argb颜色，既#AARRGGBB，前两位是透明度，后面分别是红绿蓝。</li><li>如果我们希望透明度为 0.6，则需要将 0.6 乘以 255,再转化为 16 进制。最简单的方法是利用 JavaScript，在浏览器的调试面板里输入：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Math.floor(0.6 * 255).toString(16);</span><br></pre></td></tr></table></figure><ul><li>回车后可以看到结果为99。这样透明度0.6的黑色的argb颜色即为#99000000。<h4 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h4></li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">background: rgb(0, 0, 0);</span><br><span class="line">    /* RGBa with 0.6 opacity */</span><br><span class="line">    background: rgba(0, 0, 0, 0.6);</span><br><span class="line">    /* For IE 5.5 - 7*/</span><br><span class="line">    filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);</span><br><span class="line">    /* For IE 8*/</span><br><span class="line">    -ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;全浏览器兼容背景半透明的问题的么几个解决方案：&quot;&gt;&lt;a href=&quot;#全浏览器兼容背景半透明的问题的么几个解决方案：&quot; class=&quot;headerlink&quot; title=&quot;全浏览器兼容背景半透明的问题的么几个解决方案：&quot;&gt;&lt;/a&gt;全浏览器兼容背景半透明的问题的么几个解决方案：&lt;/h3&gt;&lt;h5 id=&quot;1-使用半透明png图片平铺&quot;&gt;&lt;a href=&quot;#1-使用半透明png图片平铺&quot; class=&quot;headerlink&quot; title=&quot;1.使用半透明png图片平铺&quot;&gt;&lt;/a&gt;1.使用半透明png图片平铺&lt;/h5&gt;&lt;h5 id=&quot;2-使用opcacity属性&quot;&gt;&lt;a href=&quot;#2-使用opcacity属性&quot; class=&quot;headerlink&quot; title=&quot;2.使用opcacity属性&quot;&gt;&lt;/a&gt;2.使用opcacity属性&lt;/h5&gt;&lt;h5 id=&quot;3-使用rgba和IE的opacity滤镜属性结合&quot;&gt;&lt;a href=&quot;#3-使用rgba和IE的opacity滤镜属性结合&quot; class=&quot;headerlink&quot; title=&quot;3.使用rgba和IE的opacity滤镜属性结合&quot;&gt;&lt;/a&gt;3.使用rgba和IE的opacity滤镜属性结合&lt;/h5&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="css兼容性" scheme="blog.yuanqinglong.cn/tags/css%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="blog.yuanqinglong.cn/hello-world.html"/>
    <id>blog.yuanqinglong.cn/hello-world.html</id>
    <published>2018-01-17T13:17:10.145Z</published>
    <updated>2018-01-23T03:21:38.664Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="设置「阅读全文」"><a href="#设置「阅读全文」" class="headerlink" title="设置「阅读全文」"></a>设置「阅读全文」</h3><p>1.在文章中使用 <!-- more --> 手动进行截断，Hexo 提供的方式 推荐<br>2.在文章的 front-matter 中添加 description，并提供文章摘录<br>3.自动形成摘要，在 主题配置文件 中添加：</p><p>auto_excerpt:<br>  enable: true<br>  length: 150<br>默认截取的长度为 150 字符，可以根据需要自行设定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="blog.yuanqinglong.cn/categories/hexo/"/>
    
    
      <category term="常用命令" scheme="blog.yuanqinglong.cn/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
