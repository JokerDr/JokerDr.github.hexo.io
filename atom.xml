<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>西伯利亚大尾巴狼</title>
  <icon>https://www.gravatar.com/avatar/7d9cee11c8c05e013b8780c0530e6e5b</icon>
  <subtitle>子非鱼，安知鱼之乐？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.yuanqinglong.cn/"/>
  <updated>2018-03-03T13:59:35.059Z</updated>
  <id>blog.yuanqinglong.cn/</id>
  
  <author>
    <name>袁庆龙</name>
    <email>yuanql96@yeah.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于ajax，大概需要了解哪些基础性的东西？</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8Eajax%EF%BC%8C%E5%A4%A7%E6%A6%82%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%80%A7%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%9F.html"/>
    <id>blog.yuanqinglong.cn/关于ajax，大概需要了解哪些基础性的东西？.html</id>
    <published>2018-03-03T13:43:07.000Z</published>
    <updated>2018-03-03T13:59:35.059Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人总是健忘的，那么为什么不多动动手呢？比如说把知识记下来。<br>我们总会或有或无的接触ajax技术，那么作为一名学习者，就有必要了解相关的知识</p></blockquote><h3 id="ajax-客户端与服务器端异步的通信的技术-原理"><a href="#ajax-客户端与服务器端异步的通信的技术-原理" class="headerlink" title="ajax(客户端与服务器端异步的通信的技术)原理:"></a>ajax(客户端与服务器端异步的通信的技术)原理:</h3><p>相当于在用户和服务器之间加了—个中间层(AJAX引擎),<br>通过创建一个XmlHttpRequest对象来向服务器发异步请求,<br>通过回调在回调函数里进行dom操作.</p><ul><li><p>代码原理：</p><p>1.第一步：创建XMLHttpRequest 对象</p><pre><code>xmlhttp=new XMLHttpRequest();（它有兼容性问题，在ie中用的是new ActiveXObject）</code></pre><p>2.第二步：向服务器发送请求</p><pre><code>xmlhttp.open(&quot;GET/POST&quot;,url,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//POST时要加这句话xmlhttp.send();</code></pre><p>3.第三步：执行回调，在回调函数中进行相应的dom操作</p><pre><code>xmlhttp.onreadystatechange=function()  {  if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)//判断状态码    {    //就可以执行相应的dom操作    document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;    }  }</code></pre></li><li><p>readyState有5种值：</p><pre><code>0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪</code></pre></li><li><p>status状态码常见的有：</p><pre><code>200 服务器成功返回301 永久重定向302 临时重定向304 缓存403 服务器拒绝访问404 资源找不到500 服务器错误</code></pre><h3 id="优与劣"><a href="#优与劣" class="headerlink" title="优与劣"></a>优与劣</h3></li><li><h5 id="ajax的优点"><a href="#ajax的优点" class="headerlink" title="ajax的优点:"></a>ajax的优点:</h5><pre><code>&lt;1&gt;.无刷新更新数据。&lt;2&gt;.异步与服务器通信。&lt;3&gt;.前端和后端负载平衡。(减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担)&lt;4&gt;.基于标准被广泛支持。&lt;5&gt;.界面与应用分离。</code></pre></li><li><h5 id="ajax的缺点"><a href="#ajax的缺点" class="headerlink" title="ajax的缺点:"></a>ajax的缺点:</h5><pre><code>&lt;1&gt;.AJAX干掉了Back和History功能，即对浏览器机制的破坏。&lt;2&gt;.AJAX的安全问题。&lt;3&gt;.违背URL和资源定位的初衷。&lt;4&gt;.客户端过肥，太多客户端代码造成开发上的成本。</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;人总是健忘的，那么为什么不多动动手呢？比如说把知识记下来。&lt;br&gt;我们总会或有或无的接触ajax技术，那么作为一名学习者，就有必要了解相关的知识&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;ajax-客户端与服务器端异步的通信的技术-原理&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="javascript" scheme="blog.yuanqinglong.cn/categories/javascript/"/>
    
    
      <category term="ajax" scheme="blog.yuanqinglong.cn/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>对CommonJS规范的一些理解</title>
    <link href="blog.yuanqinglong.cn/%E5%AF%B9CommonJS%E8%A7%84%E8%8C%83%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3.html"/>
    <id>blog.yuanqinglong.cn/对CommonJS规范的一些理解.html</id>
    <published>2018-02-28T11:03:21.000Z</published>
    <updated>2018-03-02T02:44:21.336Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>咸鱼了一个寒假，不能再这样了。。。<br>学海无涯啊0.0</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">example.js</span><br><span class="line">var x = 5;</span><br><span class="line">var addX = <span class="keyword">function</span> (value) &#123;</span><br><span class="line"><span class="built_in">return</span> value + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。</p></li><li><p>如果想在多个文件分享变量，必须定义为global对象的属性。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global.warning = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p> 上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。</p></li></ul><a id="more"></a><ul><li><p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 5;</span><br><span class="line">var addX = <span class="keyword">function</span> (value) &#123;</span><br><span class="line"><span class="built_in">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.x = x;</span><br><span class="line">module.exports.addX = addX;</span><br></pre></td></tr></table></figure><p> 上面代码通过module.exports输出变量x和函数addX。</p></li><li><p>require方法用于加载模块。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var example = require(<span class="string">'./example.js'</span>);</span><br><span class="line">console.log(example.x); // 5</span><br><span class="line">console.log(example.addX(1)); // 6</span><br></pre></td></tr></table></figure><p> require方法的详细解释参见《Require命令》一节。</p></li></ul><h4 id="CommonJS模块的特点如下"><a href="#CommonJS模块的特点如下" class="headerlink" title="CommonJS模块的特点如下:"></a>CommonJS模块的特点如下:</h4><blockquote><p>1.所有代码都运行在模块作用域，不会污染全局作用域。<br>2.模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了,以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。<br>3.模块加载的顺序，按照其在代码中出现的顺序。</p></blockquote><h3 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h3><ul><li><p>Node内部提供一个Module构建函数。所有模块都是Module的实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Module(id, parent) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">this.exports = &#123;&#125;;</span><br><span class="line">this.parent = parent;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure></li></ul><p>每个模块内部，都有一个module对象，代表当前模块。它有以下属性。</p><blockquote><p>module.id 模块的识别符，通常是带有绝对路径的模块文件名。<br>module.filename 模块的文件名，带有绝对路径。<br>module.loaded 返回一个布尔值，表示模块是否已经完成加载。<br>module.parent 返回一个对象，表示调用该模块的模块。<br>module.children 返回一个数组，表示该模块要用到的其他模    块。<br>module.exports 表示模块对外输出的值。</p></blockquote><ul><li><p>下面是一个示例文件，最后一行输出module变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var jquery = require(<span class="string">'jquery'</span>);</span><br><span class="line">exports.$ = jquery;</span><br><span class="line">console.log(module);</span><br></pre></td></tr></table></figure><p>执行这个文件，命令行会输出如下信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; id: <span class="string">'.'</span>,</span><br><span class="line">exports: &#123; <span class="string">'$'</span>: [Function] &#125;,</span><br><span class="line">parent: null,</span><br><span class="line">filename: <span class="string">'/path/to/example.js'</span>,</span><br><span class="line">loaded: <span class="literal">false</span>,</span><br><span class="line">children:</span><br><span class="line">[ &#123; id: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">    exports: [Function],</span><br><span class="line">    parent: [Circular],</span><br><span class="line">    filename: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">    loaded: <span class="literal">true</span>,</span><br><span class="line">    children: [],</span><br><span class="line">    paths: [Object] &#125; ],</span><br><span class="line">paths:</span><br><span class="line">[ <span class="string">'/home/user/deleted/node_modules'</span>,</span><br><span class="line">    <span class="string">'/home/user/node_modules'</span>,</span><br><span class="line">    <span class="string">'/home/node_modules'</span>,</span><br><span class="line">    <span class="string">'/node_modules'</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果在命令行下调用某个模块，比如node something.js，那么module.parent就是null。如果是在脚本之中调用，比如require(‘./something.js’)，那么module.parent就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!module.parent) &#123;</span><br><span class="line">      // ran with `node something.js`</span><br><span class="line">      app.listen(8088, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          console.log(<span class="string">'app listening on port 8088'</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      // used with `require(<span class="string">'/.something.js'</span>)`</span><br><span class="line">      module.exports = app;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="module-exports属性"><a href="#module-exports属性" class="headerlink" title="module.exports属性"></a>module.exports属性</h4><ul><li><p>module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var EventEmitter = require(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line">module.exports = new EventEmitter();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">module.exports.emit(<span class="string">'ready'</span>);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><p> 上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = require(<span class="string">'./a'</span>);</span><br><span class="line">a.on(<span class="string">'ready'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">console.log(<span class="string">'module a is ready'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="exports变量"><a href="#exports变量" class="headerlink" title="exports变量"></a>exports变量</h4><ul><li><p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var exports = module.exports;</span><br></pre></td></tr></table></figure><p>  造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports.area = <span class="keyword">function</span> (r) &#123;</span><br><span class="line"><span class="built_in">return</span> Math.PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.circumference = <span class="keyword">function</span> (r) &#123;</span><br><span class="line"><span class="built_in">return</span> 2 * Math.PI * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = <span class="keyword">function</span>(x) &#123;console.log(x)&#125;;</span><br></pre></td></tr></table></figure><p>  上面这样的写法是无效的，因为exports不再指向module.exports了。<br>  下面的写法也是无效的。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.hello = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">'hello'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = <span class="string">'Hello world'</span>;</span><br></pre></td></tr></table></figure><p>  上面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了。<br>  这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = <span class="keyword">function</span> (x)&#123; console.log(x);&#125;;</span><br></pre></td></tr></table></figure><p>  如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。</p></li></ul><h3 id="AMD规范与CommonJS规范的兼容性"><a href="#AMD规范与CommonJS规范的兼容性" class="headerlink" title="AMD规范与CommonJS规范的兼容性"></a>AMD规范与CommonJS规范的兼容性</h3><ul><li><p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。</p><p>  AMD规范使用define方法定义模块，下面就是一个例子：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'package/lib'</span>], <span class="keyword">function</span>(lib)&#123;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>()&#123;</span><br><span class="line">    lib.log(<span class="string">'hello world!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> &#123;</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  AMD规范允许输出的模块兼容CommonJS规范，这时define方法需要写成下面这样：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span> (require, exports, module)&#123;</span><br><span class="line">var someModule = require(<span class="string">"someModule"</span>);</span><br><span class="line">var anotherModule = require(<span class="string">"anotherModule"</span>);</span><br><span class="line"></span><br><span class="line">someModule.doTehAwesome();</span><br><span class="line">anotherModule.doMoarAwesome();</span><br><span class="line"></span><br><span class="line">exports.asplode = <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">    someModule.doTehAwesome();</span><br><span class="line">    anotherModule.doMoarAwesome();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="require命令"><a href="#require命令" class="headerlink" title="require命令"></a>require命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul><li><p>Node使用CommonJS模块规范，内置的require命令用于加载模块文件。</p><p>  require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var invisible = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">console.log(<span class="string">"invisible"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.message = <span class="string">"hi"</span>;</span><br><span class="line"></span><br><span class="line">exports.say = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">console.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行下面的命令，可以输出exports对象。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var example = require(<span class="string">'./example.js'</span>);</span><br><span class="line">example</span><br><span class="line">// &#123;</span><br><span class="line">//   message: <span class="string">"hi"</span>,</span><br><span class="line">//   say: [Function]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p>  如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定在module.exports变量上面。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        module.exports = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(<span class="string">"hello world"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        require(<span class="string">'./example2.js'</span>)()</span><br><span class="line">    ``` </span><br><span class="line">    上面代码中，require命令调用自身，等于是执行module.exports，因此会输出 hello world。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 加载规则</span></span><br><span class="line">-  require命令用于加载文件，后缀名默认为.js。</span><br><span class="line"></span><br><span class="line">    ```bash</span><br><span class="line">        var foo = require(<span class="string">'foo'</span>);</span><br><span class="line">        //  等同于</span><br><span class="line">        var foo = require(<span class="string">'foo.js'</span>);</span><br></pre></td></tr></table></figure><p>  根据参数的不同格式，require命令去不同路径寻找模块文件。</p><p>  （1）如果参数字符串以“<code>/</code>”开头，则表示加载的是一个位于绝对路径的模块文件。比如，<code>require(&#39;/home/marco/foo.js&#39;)</code>将加载<code>/home/marco/foo.js</code>。</p><p>  （2）如果参数字符串以“<code>./</code>”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，<code>require(&#39;./circle&#39;)</code>将加载当前脚本同一目录的<code>circle.js</code>。</p><p>  （3）如果参数字符串不以“<code>./</code>“或”<code>/</code>“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。<br>  <br><br>  举例来说，脚本<code>/home/user/projects/foo.js</code>执行了require<code>(&#39;bar.js&#39;)</code>命令，Node会依次搜索以下文件。</p><blockquote><p>/usr/local/lib/node/bar.js<br>/home/user/projects/node_modules/bar.js<br>/home/user/node_modules/bar.js<br>/home/node_modules/bar.js<br>/node_modules/bar.js</p></blockquote><p>  这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。</p><p>  （4）如果参数字符串不以“<code>./</code>“或”<code>/</code>“开头，而且是一个路径，<br>  比如<code>require(&#39;example-module/path/to/file&#39;)</code>，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</p><p>  （5）如果指定的模块文件没有发现，Node会尝试为文件名添加<code>.js</code>、<code>.json</code>、<code>.node</code>后，再去搜索。<code>.js</code>件会以文本格式的JavaScript脚本文件解析，<code>.json</code>文件会以JSON格式的文本文件解析，<code>.node</code>文件会以编译后的二进制文件解析。</p><p>  （6）如果想得到require命令加载的确切文件名，使用<code>require.resolve()</code>方法。</p></li></ul><h4 id="目录的加载规则"><a href="#目录的加载规则" class="headerlink" title="目录的加载规则"></a>目录的加载规则</h4><ul><li><p>通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录。<br><br><br>在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123; <span class="string">"name"</span> : <span class="string">"some-library"</span>,</span><br><span class="line"><span class="string">"main"</span> : <span class="string">"./lib/some-library.js"</span> &#125;</span><br></pre></td></tr></table></figure><p>require发现参数字符串指向一个目录以后，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件。如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件。</p></li></ul><h4 id="模块的缓存"><a href="#模块的缓存" class="headerlink" title="模块的缓存"></a>模块的缓存</h4><ul><li><p>第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的<code>module.exports</code>属性。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require(<span class="string">'./example.js'</span>);</span><br><span class="line">require(<span class="string">'./example.js'</span>).message = <span class="string">"hello"</span>;</span><br><span class="line">require(<span class="string">'./example.js'</span>).message</span><br><span class="line">// <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><p>  上面代码中，连续三次使用require命令，加载同一个模块。第二次加载的时候，为输出的对象添加了一个message属性。但是第三次加载的时候，这个message属性依然存在，这就证明require命令并没有重新加载模块文件，而是输出了缓存。</p><p>  如果想要多次执行某个模块，可以让该模块输出一个函数，然后每次require这个模块的时候，重新执行一下输出的函数。</p><p>  所有缓存的模块保存在<code>require.cache</code>之中，如果想删除模块的缓存，可以像下面这样写。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 删除指定模块的缓存</span><br><span class="line">delete require.cache[moduleName];</span><br><span class="line"></span><br><span class="line">// 删除所有模块的缓存</span><br><span class="line">Object.keys(require.cache).forEach(<span class="keyword">function</span>(key) &#123;</span><br><span class="line">delete require.cache[key];</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><pre><code>注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，require命令还是会重新加载该模块。</code></pre><h4 id="环境变量NODE-PATH"><a href="#环境变量NODE-PATH" class="headerlink" title="环境变量NODE_PATH"></a>环境变量<code>NODE_PATH</code></h4><ul><li><p>Node执行一个脚本时，会先查看环境变量NODE_PATH。它是一组以冒号分隔的绝对路径。在其他位置找不到指定模块时，Node会去这些路径查找。</p><p>可以将<code>NODE_PATH</code>添加到<code>.bashrc</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NODE_PATH=<span class="string">"/usr/local/lib/node"</span></span><br></pre></td></tr></table></figure><p>所以，如果遇到复杂的相对路径，比如下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myModule = require(<span class="string">'../../../../lib/myModule'</span>);</span><br></pre></td></tr></table></figure><p>有两种解决方法，一是将该文件加入node_modules目录，二是修改NODE_PATH环境变量，package.json文件可以采用下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"node_path"</span>,</span><br><span class="line"><span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line"><span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"NODE_PATH=lib node index.js"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NODE_PATH是历史遗留下来的一个路径解决方案，通常不应该使用，而应该使用node_modules目录机制。</p></li></ul><h4 id="模块的循环加载"><a href="#模块的循环加载" class="headerlink" title="模块的循环加载"></a>模块的循环加载</h4><ul><li><p>如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">exports.x = <span class="string">'a1'</span>;</span><br><span class="line">console.log(<span class="string">'a.js '</span>, require(<span class="string">'./b.js'</span>).x);</span><br><span class="line">exports.x = <span class="string">'a2'</span>;</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">exports.x = <span class="string">'b1'</span>;</span><br><span class="line">console.log(<span class="string">'b.js '</span>, require(<span class="string">'./a.js'</span>).x);</span><br><span class="line">exports.x = <span class="string">'b2'</span>;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./a.js'</span>).x);</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./b.js'</span>).x);</span><br></pre></td></tr></table></figure><p>上面代码是三个JavaScript文件。其中，a.js加载了b.js，而b.js又加载a.js。这时，Node返回a.js的不完整版本，所以执行结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">b.js  a1</span><br><span class="line">a.js  b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2</span><br></pre></td></tr></table></figure><p>修改main.js，再次加载a.js和b.js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./a.js'</span>).x);</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./b.js'</span>).x);</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./a.js'</span>).x);</span><br><span class="line">console.log(<span class="string">'main.js '</span>, require(<span class="string">'./b.js'</span>).x);</span><br></pre></td></tr></table></figure><p>执行上面代码，结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">b.js  a1</span><br><span class="line">a.js  b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2</span><br></pre></td></tr></table></figure><p>上面代码中，第二次加载a.js和b.js时，会直接从缓存读取exports属性，所以a.js和b.js内部的console.log语句都不会执行了。</p></li></ul><h4 id="require-main"><a href="#require-main" class="headerlink" title="require.main"></a>require.main</h4><ul><li><p>require方法有一个main属性，可以用来判断模块是直接执行，还是被调用执行。</p><p>直接执行的时候（node module.js），require.main属性指向模块本身。</p><pre><code>require.main === module// true</code></pre><p>调用执行的时候（通过require加载该脚本执行），上面的表达式返回false。</p></li></ul><h3 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h3><ul><li><p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。</p><p>下面是一个模块文件lib.js。</p><pre><code>// lib.jsvar counter = 3;function incCounter() {counter++;}module.exports = {counter: counter,incCounter: incCounter,};</code></pre><p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。</p><p>然后，加载上面的模块。</p><pre><code>// main.jsvar counter = require(&apos;./lib&apos;).counter;var incCounter = require(&apos;./lib&apos;).incCounter;console.log(counter);  // 3incCounter();console.log(counter); // 3</code></pre><p>上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。</p></li></ul><h4 id="require的内部处理流程"><a href="#require的内部处理流程" class="headerlink" title="require的内部处理流程"></a>require的内部处理流程</h4><ul><li><p>require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module._load = <span class="keyword">function</span>(request, parent, isMain) &#123;</span><br><span class="line">// 1. 检查 Module._cache，是否缓存之中有指定模块</span><br><span class="line">// 2. 如果缓存之中没有，就创建一个新的Module实例</span><br><span class="line">// 3. 将它保存到缓存</span><br><span class="line">// 4. 使用 module.load() 加载指定的模块文件，</span><br><span class="line">//    读取文件内容之后，使用 module.compile() 执行文件代码</span><br><span class="line">// 5. 如果加载/解析过程报错，就从缓存删除该模块</span><br><span class="line">// 6. 返回该模块的 module.exports</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype._compile = <span class="keyword">function</span>(content, filename) &#123;</span><br><span class="line">// 1. 生成一个require函数，指向module.require</span><br><span class="line">// 2. 加载其他辅助方法到require</span><br><span class="line">// 3. 将文件内容放到一个函数之中，该函数可调用 require</span><br><span class="line">// 4. 执行该函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的第1步和第2步，require函数及其辅助方法主要如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require(): 加载外部模块</span><br><span class="line">require.resolve()：将模块名解析到一个绝对路径</span><br><span class="line">require.main：指向主模块</span><br><span class="line">require.cache：指向所有缓存的模块</span><br><span class="line">require.extensions：根据文件的后缀名，调用不同的执行函数</span><br></pre></td></tr></table></figure><p>一旦require函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括require、module、exports，以及其他一些参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">// YOUR CODE INJECTED HERE!</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Module._compile方法是同步执行的，所以Module._load要等它执行完成，才会向用户返回module.exports的值。</p></li></ul><blockquote><p>本文引自阮一峰的文章<br>受益匪浅，由是感激！<br>链接：<a href="http://javascript.ruanyifeng.com/nodejs/module.html#" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/module.html#</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;咸鱼了一个寒假，不能再这样了。。。&lt;br&gt;学海无涯啊0.0&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;example.js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var x = 5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var addX = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (value) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; value + x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果想在多个文件分享变量，必须定义为global对象的属性。&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;global.warning = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CommonJS" scheme="blog.yuanqinglong.cn/tags/CommonJS/"/>
    
  </entry>
  
  <entry>
    <title>关于ES6 const 篇</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8EES6-const-%E7%AF%87.html"/>
    <id>blog.yuanqinglong.cn/关于ES6-const-篇.html</id>
    <published>2018-02-02T13:19:24.000Z</published>
    <updated>2018-02-13T10:11:27.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》<br>原文链接：<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/let</a><br>学海无涯，愿与诸君共勉</p></blockquote><h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><ul><li>const声明一个只读的常量。一旦声明，常量的值就不能改变。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const PI = 3.1415;</span><br><span class="line">PI // 3.1415</span><br><span class="line"></span><br><span class="line">PI = 3;</span><br><span class="line">// TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure></li></ul><p>上面代码表明改变常量的值会报错。<br><a id="more"></a><br>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const foo;</span><br><span class="line">// SyntaxError: Missing initializer <span class="keyword">in</span> const declaration</span><br></pre></td></tr></table></figure><p></p><p>上面代码表示，对于const来说，只声明不赋值，就会报错。</p><ul><li><p>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MAX // Uncaught ReferenceError: MAX is not defined</span><br></pre></td></tr></table></figure></li><li><p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  console.log(MAX); // ReferenceError</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面代码在常量MAX声明之前就调用，结果报错。</p><ul><li>const声明的常量，也与let一样不可重复声明。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var message = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="built_in">let</span> age = 25;</span><br><span class="line"></span><br><span class="line">// 以下两行都会报错</span><br><span class="line">const message = <span class="string">"Goodbye!"</span>;</span><br><span class="line">const age = 30;</span><br></pre></td></tr></table></figure></li></ul><h5 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h5><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 为 foo 添加一个属性，可以成功</span><br><span class="line">foo.prop = 123;</span><br><span class="line">foo.prop // 123</span><br><span class="line"></span><br><span class="line">// 将 foo 指向另一个对象，就会报错</span><br><span class="line">foo = &#123;&#125;; // TypeError: <span class="string">"foo"</span> is <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><p>下面是另一个例子。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); // 可执行</span><br><span class="line">a.length = 0;    // 可执行</span><br><span class="line">a = [<span class="string">'Dave'</span>];    // 报错</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。</p><p>如果真的想将对象冻结，应该使用Object.freeze方法。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const foo = Object.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">// 常规模式时，下面一行不起作用；</span><br><span class="line">// 严格模式时，该行会报错</span><br><span class="line">foo.prop = 123;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var constantize = (obj) =&gt; &#123;</span><br><span class="line">  Object.freeze(obj);</span><br><span class="line">  Object.keys(obj).forEach( (key, i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> ( typeof obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h5 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h5><p>ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。</p><ul><li><h5 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h5>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.a = 1;</span><br><span class="line">a // 1</span><br><span class="line"></span><br><span class="line">a = 2;</span><br><span class="line">window.a // 2</span><br></pre></td></tr></table></figure></li></ul><p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p><p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">// 如果在 Node 的 REPL 环境，可以写成 global.a</span><br><span class="line">// 或者采用通用方法，写成 this.a</span><br><span class="line">window.a // 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = 1;</span><br><span class="line">window.b // undefined</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。</p><ul><li><h5 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h5>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</li></ul><p>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。<br>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。<br>Node 里面，顶层对象是global，但其他环境都不支持。<br>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</p><p>全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。<br>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。<br>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。<br>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 方法一</span><br><span class="line">(typeof window !== <span class="string">'undefined'</span></span><br><span class="line">   ? window</span><br><span class="line">   : (typeof process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      typeof require === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      typeof global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : this);</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">var getGlobal = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (typeof self !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (typeof window !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> window; &#125;</span><br><span class="line">  <span class="keyword">if</span> (typeof global !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> global; &#125;</span><br><span class="line">  throw new Error(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。</p><p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// CommonJS 的写法</span><br><span class="line">require(<span class="string">'system.global/shim'</span>)();</span><br><span class="line"></span><br><span class="line">// ES6 模块的写法</span><br><span class="line">import shim from <span class="string">'system.global/shim'</span>; shim();</span><br><span class="line">上面代码可以保证各种环境里面，global对象都是存在的。</span><br><span class="line"></span><br><span class="line">// CommonJS 的写法</span><br><span class="line">var global = require(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line">// ES6 模块的写法</span><br><span class="line">import getGlobal from <span class="string">'system.global'</span>;</span><br><span class="line">const global = getGlobal();</span><br></pre></td></tr></table></figure><p></p><p>上面代码将顶层对象放入变量global。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》&lt;br&gt;原文链接：&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://es6.ruanyifeng.com/#docs/let&lt;/a&gt;&lt;br&gt;学海无涯，愿与诸君共勉&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;const-命令&quot;&gt;&lt;a href=&quot;#const-命令&quot; class=&quot;headerlink&quot; title=&quot;const 命令&quot;&gt;&lt;/a&gt;const 命令&lt;/h3&gt;&lt;h5 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h5&gt;&lt;ul&gt;&lt;li&gt;const声明一个只读的常量。一旦声明，常量的值就不能改变。&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const PI = 3.1415;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PI // 3.1415&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PI = 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// TypeError: Assignment to constant variable.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面代码表明改变常量的值会报错。&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="blog.yuanqinglong.cn/categories/ES6/"/>
    
    
      <category term="const" scheme="blog.yuanqinglong.cn/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>关于ES6 : let 篇 </title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8EES6-let-%E7%AF%87.html"/>
    <id>blog.yuanqinglong.cn/关于ES6-let-篇.html</id>
    <published>2018-01-27T12:26:15.000Z</published>
    <updated>2018-02-13T10:11:05.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》<br>原文链接：<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/let</a><br>学海无涯，愿与诸君共勉</p></blockquote><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul><li><h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在<br>let命令所在的代码块内有效。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">let</span> a = 10;</span><br><span class="line">   var b = 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a // ReferenceError: a is not defined.</span><br><span class="line">b // 1</span><br></pre></td></tr></table></figure></li></ul><p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。<br><a id="more"></a><br>for循环的计数器，就很合适使用let命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i);</span><br><span class="line">// ReferenceError: i is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。</p><p>下面的代码如果使用var，最后输出的是10。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br></pre></td></tr></table></figure><p>上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。</p><p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p><p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  <span class="built_in">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br></pre></td></tr></table></figure><p></p><p>上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p><ul><li><h5 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h5>var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。<br>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// var 的情况</span><br><span class="line">console.log(foo); // 输出undefined</span><br><span class="line">var foo = 2;</span><br><span class="line"></span><br><span class="line">// <span class="built_in">let</span> 的情况</span><br><span class="line">console.log(bar); // 报错ReferenceError</span><br><span class="line"><span class="built_in">let</span> bar = 2;</span><br></pre></td></tr></table></figure></li></ul><p>上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</p><ul><li><h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; // ReferenceError</span><br><span class="line">  <span class="built_in">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  // TDZ开始</span><br><span class="line">  tmp = <span class="string">'abc'</span>; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> tmp; // TDZ结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。</p><p>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof x; // ReferenceError</span><br><span class="line"><span class="built_in">let</span> x;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。</p><p>作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof undeclared_variable // <span class="string">"undefined"</span></span><br></pre></td></tr></table></figure><p>上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p><p>有些“死区”比较隐蔽，不太容易发现。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bar(x = y, y = 2) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // 报错</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bar(x = 2, y = x) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); // [2, 2]</span><br></pre></td></tr></table></figure><p></p><p>另外，下面的代码也会报错，与var的行为不同。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">var x = x;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="built_in">let</span> x = x;</span><br><span class="line">// ReferenceError: x is not defined</span><br></pre></td></tr></table></figure><p></p><p>上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。</p><p>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><ul><li><h5 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h5>let不允许在相同作用域内，重复声明同一个变量。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> a = 10;</span><br><span class="line">  var a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> a = 10;</span><br><span class="line">  <span class="built_in">let</span> a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>因此，不能在函数内部重新声明参数。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> func(arg) &#123;</span><br><span class="line">  <span class="built_in">let</span> arg; // 报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> func(arg) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">let</span> arg; // 不报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><h5 id="块级作用域-1"><a href="#块级作用域-1" class="headerlink" title="块级作用域"></a>块级作用域</h5>为什么需要块级作用域？<br>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</li></ul><p>第一种场景，内层变量可能会覆盖外层变量。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    var tmp = <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure><p></p><p>上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure><p></p><p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><p>ES6 的块级作用域<br>let实际上为 JavaScript 新增了块级作用域。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> n = 5;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">let</span> n = 10;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(n); // 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。</p><p>ES6 允许块级作用域的任意嵌套。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p></p><p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">  console.log(insane); // 报错</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p></p><p>内层作用域可以定义外层作用域的同名变量。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="built_in">let</span> insane = <span class="string">'Hello World'</span>;</span><br><span class="line">  &#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p></p><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// IIFE 写法</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  var tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 块级作用域写法</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><h5 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h5>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</li></ul><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 情况一</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二</span><br><span class="line">try &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面两种函数声明，根据 ES5 的规定都是非法的。</p><p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    // 重复声明一次函数f</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p></p><p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ES5 环境</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p></p><p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p><p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p><p>允许在块级作用域内声明函数。<br>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。<br>同时，函数声明还会提升到所在的块级作用域的头部。<br>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p><p>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。</p><p>// 浏览器的 ES6 环境<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    // 重复声明一次函数f</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line">// Uncaught TypeError: f is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p></p><p>上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器的 ES6 环境</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  var f = undefined;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line">// Uncaught TypeError: f is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p></p><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明语句</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="built_in">let</span> f = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》&lt;br&gt;原文链接：&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://es6.ruanyifeng.com/#docs/let&lt;/a&gt;&lt;br&gt;学海无涯，愿与诸君共勉&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;h5 id=&quot;块级作用域&quot;&gt;&lt;a href=&quot;#块级作用域&quot; class=&quot;headerlink&quot; title=&quot;块级作用域&quot;&gt;&lt;/a&gt;块级作用域&lt;/h5&gt;ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在&lt;br&gt;let命令所在的代码块内有效。&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; a = 10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   var b = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a // ReferenceError: a is not defined.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b // 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="blog.yuanqinglong.cn/categories/ES6/"/>
    
    
      <category term="let" scheme="blog.yuanqinglong.cn/tags/let/"/>
    
  </entry>
  
  <entry>
    <title>关于object.key与object[key]的区别</title>
    <link href="blog.yuanqinglong.cn/%E5%85%B3%E4%BA%8Eobject-key%E4%B8%8Eobject-key-%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
    <id>blog.yuanqinglong.cn/关于object-key与object-key-的区别.html</id>
    <published>2018-01-24T07:01:27.000Z</published>
    <updated>2018-01-24T08:29:00.834Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录所需要的，摒弃多余的。<br>本篇文章是对segmentfault的一个问答的总结。</p></blockquote><h2 id="obeject-key与object-key-有什么区别"><a href="#obeject-key与object-key-有什么区别" class="headerlink" title="obeject.key与object[key]有什么区别?"></a>obeject.key与object[key]有什么区别?</h2><p>有什么区别，不试试怎么知道？</p><h5 id="测试代码（其实有很多栗子，随便举一个）："><a href="#测试代码（其实有很多栗子，随便举一个）：" class="headerlink" title="测试代码（其实有很多栗子，随便举一个）："></a>测试代码（其实有很多栗子，随便举一个）：</h5><pre><code> var obj = {    name: &apos;tom&apos;,    age: 22},someKey = &apos;age&apos;;        console.log(obj.name);   console.log(obj[&apos;name&apos;]); console.log(obj.someKey);  console.log(obj[someKey]);  </code></pre><a id="more"></a><h5 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h5><p>（放图）<br><img src="../imgs/blogContentImgs/2018-1-24-01.png" alt="Alt text" title="node 运行截图"></p><h5 id="通常来讲，-obj-“key”-与-obj-key-的作用差不多，但是，"><a href="#通常来讲，-obj-“key”-与-obj-key-的作用差不多，但是，" class="headerlink" title="通常来讲， obj[“key”]  与 obj.key 的作用差不多，但是，"></a>通常来讲， <em>obj[“key”]</em> 与 <em>obj.key</em> 的作用差不多，但是，</h5><ul><li>如果key不确定（key是变量）的情况下，</li><li>或者key的写法比较特殊（比如包含空格什么的）</li></ul><h5 id="则只能通过obj-的方式去访问"><a href="#则只能通过obj-的方式去访问" class="headerlink" title="则只能通过obj[ ]的方式去访问"></a>则只能通过<code>obj[ ]</code>的方式去访问</h5>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;记录所需要的，摒弃多余的。&lt;br&gt;本篇文章是对segmentfault的一个问答的总结。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;obeject-key与object-key-有什么区别&quot;&gt;&lt;a href=&quot;#obeject-key与object-key-有什么区别&quot; class=&quot;headerlink&quot; title=&quot;obeject.key与object[key]有什么区别?&quot;&gt;&lt;/a&gt;obeject.key与object[key]有什么区别?&lt;/h2&gt;&lt;p&gt;有什么区别，不试试怎么知道？&lt;/p&gt;&lt;h5 id=&quot;测试代码（其实有很多栗子，随便举一个）：&quot;&gt;&lt;a href=&quot;#测试代码（其实有很多栗子，随便举一个）：&quot; class=&quot;headerlink&quot; title=&quot;测试代码（其实有很多栗子，随便举一个）：&quot;&gt;&lt;/a&gt;测试代码（其实有很多栗子，随便举一个）：&lt;/h5&gt;&lt;pre&gt;&lt;code&gt; var obj = {
    name: &amp;apos;tom&amp;apos;,
    age: 22
},
someKey = &amp;apos;age&amp;apos;;        

console.log(obj.name);   
console.log(obj[&amp;apos;name&amp;apos;]); 
console.log(obj.someKey);  
console.log(obj[someKey]);  
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="json" scheme="blog.yuanqinglong.cn/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>Markdown常用语法</title>
    <link href="blog.yuanqinglong.cn/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html"/>
    <id>blog.yuanqinglong.cn/Markdown常用语法.html</id>
    <published>2018-01-22T12:49:29.000Z</published>
    <updated>2018-01-24T07:48:08.540Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写博客，自然免不了接触<strong>Markdown</strong>,作为初学者，为了即用即查，我决定把相关命令记录下来，本文就是边学边写<br>此处声明：本文是 <strong>参考他人的文章</strong>&amp;<strong>结合实践</strong>后，所写，另外，转载、复制随意，但请务必<strong>注明本文链接</strong></p></blockquote><h1 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h1><p>写法:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># h1级标题</span></span><br><span class="line"><span class="comment">## h2级标题</span></span><br><span class="line"><span class="comment">### h3级标题</span></span><br><span class="line"><span class="comment">#### h4级标题</span></span><br><span class="line"><span class="comment">##### h5级标题</span></span><br><span class="line"><span class="comment">###### h6级标题</span></span><br></pre></td></tr></table></figure><p></p><p>栗子：</p><ul><li><h4 id="这是一个h4级标题"><a href="#这是一个h4级标题" class="headerlink" title="这是一个h4级标题"></a>这是一个h4级标题</h4></li></ul><p>注意：</p><ul><li><code>#</code>与标题文字间要有<strong>空格</strong></li><li>当<code>-</code>与<code>#</code>结合使用时，如果不想下一行受到干扰，可以使用<kbd>Enter</kbd>换行   </li></ul><hr><a id="more"></a><h1 id="分割线："><a href="#分割线：" class="headerlink" title="分割线："></a>分割线：</h1><p>连续三个&amp;三个以上的<code>-</code> 即可作出分割线</p><h4 id="写法"><a href="#写法" class="headerlink" title="写法:"></a>写法:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="栗子："><a href="#栗子：" class="headerlink" title="栗子："></a>栗子：</h4><hr><p>注意：建议写分割线时，与上一行留出一空行</p><hr><h1 id="超链接："><a href="#超链接：" class="headerlink" title="超链接："></a>超链接：</h1><h4 id="写法1："><a href="#写法1：" class="headerlink" title="写法1："></a>写法1：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[连接名称](网址 , 标题)</span><br><span class="line"></span><br><span class="line">[baidu](https://www.baidu.com, <span class="string">"baidu"</span>)</span><br><span class="line">[&lt;i class=<span class="string">"icon-refresh"</span>&gt;&lt;/i&gt; 点我刷新](/<span class="comment">#)</span></span><br></pre></td></tr></table></figure><h4 id="栗子：-1"><a href="#栗子：-1" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><a href="https://www.baidu.com," title="baidu" target="_blank" rel="noopener">baidu</a></li><li><a href="/#"><i class="icon-refresh"></i> 点我刷新</a></li></ul><h4 id="写法2："><a href="#写法2：" class="headerlink" title="写法2："></a>写法2：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[链接名][链接代号]</span><br><span class="line">[链接代号]:详细地址</span><br><span class="line"></span><br><span class="line">[here][3]</span><br><span class="line">[3]: http://www.baidu.com</span><br></pre></td></tr></table></figure><h4 id="栗子：-2"><a href="#栗子：-2" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><a href="http://www.baidu.com" target="_blank" rel="noopener">here</a></li></ul><h4 id="写法3："><a href="#写法3：" class="headerlink" title="写法3："></a>写法3：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接展示链接：&lt;http://www.baidu.com&gt;</span><br></pre></td></tr></table></figure><h4 id="栗子：-3"><a href="#栗子：-3" class="headerlink" title="栗子："></a>栗子：</h4><ul><li>直接展示链接：<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li></ul><hr><h1 id="键盘键"><a href="#键盘键" class="headerlink" title="键盘键"></a>键盘键</h1><h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;kbd&gt;Ctrl+[&lt;/kbd&gt; and &lt;kbd&gt;Ctrl+]&lt;/kbd&gt;</span><br></pre></td></tr></table></figure><h4 id="栗子：-4"><a href="#栗子：-4" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><kbd>Ctrl+[</kbd> and <kbd>Ctrl+]</kbd></li></ul><hr><h1 id="code格式："><a href="#code格式：" class="headerlink" title="code格式："></a>code格式：</h1><p>反引号</p><h4 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Use the `<span class="built_in">printf</span>()` <span class="keyword">function</span>.</span><br><span class="line"> ``There is a literal backtick (`) here.针对在代码区段内插入反引号的情况`</span><br></pre></td></tr></table></figure><h4 id="栗子：-5"><a href="#栗子：-5" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><p>Use the <code>printf()</code> function.</p></li><li><p><code>There is a literal backtick (`) here.针对在代码区段内插入反引号的情况</code> </p></li></ul><hr><h1 id="强调："><a href="#强调：" class="headerlink" title="强调："></a>强调：</h1><h4 id="用法：-2"><a href="#用法：-2" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*斜体强调*</span><br><span class="line">**粗体强调**</span><br></pre></td></tr></table></figure><h4 id="栗子：-6"><a href="#栗子：-6" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><em>斜体强调</em></li><li><strong>粗体强调</strong></li></ul><hr><h1 id="图片："><a href="#图片：" class="headerlink" title="图片："></a>图片：</h1><h4 id="用法：-3"><a href="#用法：-3" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](../imgs/blogContentImgs/jhvh.jpg <span class="string">"这图我觉得扣得不错"</span>)</span><br><span class="line">如果图片链接失效的话，会显示 Alt text</span><br></pre></td></tr></table></figure><h4 id="栗子：-7"><a href="#栗子：-7" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><img src="../imgs/jhvh.jpg" alt="Alt text" title="这图我觉得扣得不错"></li></ul><h1 id="使用-icon-图标文字："><a href="#使用-icon-图标文字：" class="headerlink" title="使用 icon 图标文字："></a>使用 icon 图标文字：</h1><h4 id="用法：-4"><a href="#用法：-4" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=<span class="string">"fa fa-github"</span>&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure><h4 id="栗子：-8"><a href="#栗子：-8" class="headerlink" title="栗子："></a>栗子：</h4><ul><li><i class="fa fa-github"></i></li></ul><hr><h1 id="段落："><a href="#段落：" class="headerlink" title="段落："></a>段落：</h1><p> 以一个空行开始，以一个空行结束，中间的就是一个段落。</p><hr><h1 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h1><h4 id="用法：-5"><a href="#用法：-5" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Item     | Value</span><br><span class="line">-------- | ---</span><br><span class="line">Computer | <span class="variable">$1600</span></span><br><span class="line">Phone    | <span class="variable">$12</span></span><br><span class="line">Pipe     | <span class="variable">$1</span></span><br></pre></td></tr></table></figure><h4 id="栗子：-9"><a href="#栗子：-9" class="headerlink" title="栗子："></a>栗子：</h4><table><thead><tr><th>Item</th><th>Value</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><hr><h1 id="无序列表："><a href="#无序列表：" class="headerlink" title="无序列表："></a>无序列表：</h1><p>使用 - 加一个空格</p><h4 id="用法：-6"><a href="#用法：-6" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 无需列表1</span><br><span class="line">- 无序列表2</span><br><span class="line">- 无序列表3</span><br></pre></td></tr></table></figure><h4 id="栗子：-10"><a href="#栗子：-10" class="headerlink" title="栗子："></a>栗子：</h4><ul><li>无需列表1</li><li>无序列表2</li><li>无序列表3</li></ul><hr><h1 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a>有序列表：</h1><p>使用 数字 加一个英文句点</p><h4 id="用法：-7"><a href="#用法：-7" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表</span><br><span class="line">2. 有序列表</span><br><span class="line">3. 有序列表</span><br><span class="line">4. 有序列表</span><br><span class="line">5. 有序列表</span><br></pre></td></tr></table></figure><h4 id="栗子：-11"><a href="#栗子：-11" class="headerlink" title="栗子："></a>栗子：</h4><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><hr><h1 id="换行缩进形成代码区块："><a href="#换行缩进形成代码区块：" class="headerlink" title="换行缩进形成代码区块："></a>换行缩进形成代码区块：</h1><h4 id="用法：-8"><a href="#用法：-8" class="headerlink" title="用法："></a>用法：</h4><pre><code>这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。    </code></pre><h4 id="栗子：-12"><a href="#栗子：-12" class="headerlink" title="栗子："></a>栗子：</h4><pre><code>这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。    </code></pre><hr><h1 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h1><h4 id="用法：-9"><a href="#用法：-9" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;给引用的文本开始位置都加一个 <span class="string">'&gt;'</span>，</span><br><span class="line">&gt;便可组成一个块引用。在块引用中，可以结合</span><br><span class="line">&gt;其他markdown元素一块使用，比如列表。</span><br><span class="line">&gt;**强调**</span><br><span class="line">也可以只在第一行加大于号，其他位置不加。</span><br><span class="line"></span><br><span class="line">&gt;- 块引用里使用列表，需要和上面的内容隔开一个空行</span><br><span class="line">&gt;- 记得加空格哦。</span><br></pre></td></tr></table></figure><h4 id="栗子：-13"><a href="#栗子：-13" class="headerlink" title="栗子："></a>栗子：</h4><blockquote><p>给引用的文本开始位置都加一个 ‘&gt;’，<br>便可组成一个块引用。在块引用中，可以结合<br>其他markdown元素一块使用，比如列表。<br><strong>强调</strong><br>也可以只在第一行加大于号，其他位置不加。</p><ul><li>块引用里使用列表，需要和上面的内容隔开一个空行</li><li>记得加空格哦。</li></ul></blockquote><hr><blockquote><p>本文参考链接：<br>[掌握这几种 Markdown 语法你就够了]<br><a href="https://laravel-china.org/topics/621/you-will-be-able-to-master-these-markdown-grammars" target="_blank" rel="noopener">https://laravel-china.org/topics/621/you-will-be-able-to-master-these-markdown-grammars</a><br>[中文文案排版指北]<br>:<a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">https://github.com/sparanoid/chinese-copywriting-guidelines</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;写博客，自然免不了接触&lt;strong&gt;Markdown&lt;/strong&gt;,作为初学者，为了即用即查，我决定把相关命令记录下来，本文就是边学边写&lt;br&gt;此处声明：本文是 &lt;strong&gt;参考他人的文章&lt;/strong&gt;&amp;amp;&lt;strong&gt;结合实践&lt;/strong&gt;后，所写，另外，转载、复制随意，但请务必&lt;strong&gt;注明本文链接&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;标题：&quot;&gt;&lt;a href=&quot;#标题：&quot; class=&quot;headerlink&quot; title=&quot;标题：&quot;&gt;&lt;/a&gt;标题：&lt;/h1&gt;&lt;p&gt;写法:&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# h1级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## h2级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;### h3级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#### h4级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;##### h5级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;###### h6级标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;栗子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;这是一个h4级标题&quot;&gt;&lt;a href=&quot;#这是一个h4级标题&quot; class=&quot;headerlink&quot; title=&quot;这是一个h4级标题&quot;&gt;&lt;/a&gt;这是一个h4级标题&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt;与标题文字间要有&lt;strong&gt;空格&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;-&lt;/code&gt;与&lt;code&gt;#&lt;/code&gt;结合使用时，如果不想下一行受到干扰，可以使用&lt;kbd&gt;Enter&lt;/kbd&gt;换行   &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="Markdown" scheme="blog.yuanqinglong.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>原生JS实现jQuery的addClass, removeClass, hasClass函数功能</title>
    <link href="blog.yuanqinglong.cn/%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0jQuery%E7%9A%84addClass,%20removeClass,%20hasClass%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD.html"/>
    <id>blog.yuanqinglong.cn/原生JS实现jQuery的addClass, removeClass, hasClass函数功能.html</id>
    <published>2018-01-20T15:21:08.000Z</published>
    <updated>2018-01-23T03:24:21.892Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-addClass"><a href="#1-addClass" class="headerlink" title="- [1] addClass"></a>- [1] addClass</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function addClass(obj, cls)&#123;</span><br><span class="line">    var obj_class = obj.className;//获取 class 内容.</span><br><span class="line">    var blank = (obj_class != &apos;&apos;) ? &apos; &apos; : &apos;&apos;;//判断获取到的 class 是否为空, 如果不为空在前面加个&apos;空格&apos;.</span><br><span class="line">    var added = obj_class + blank + cls;//组合原来的 class 和需要添加的 class.</span><br><span class="line">    obj.className = added;//替换原来的 class.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-removeClass"><a href="#2-removeClass" class="headerlink" title="- [2]  removeClass"></a>- [2]  removeClass</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function removeClass(obj, cls)&#123;</span><br><span class="line">    var obj_class = &apos; &apos;+obj.className+&apos; &apos;;//获取 class 内容, 并在首尾各加一个空格. ex) &apos;abc        bcd&apos; -&gt; &apos; abc        bcd &apos;</span><br><span class="line">    obj_class = obj_class.replace(/(\s+)/gi, &apos; &apos;),//将多余的空字符替换成一个空格. ex) &apos; abc        bcd &apos; -&gt; &apos; abc bcd &apos;</span><br><span class="line">    var removed = obj_class.replace(&apos; &apos;+cls+&apos; &apos;, &apos; &apos;);//在原来的 class 替换掉首尾加了空格的 class. ex) &apos; abc bcd &apos; -&gt; &apos;bcd &apos;</span><br><span class="line">    removed = removed.replace(/(^\s+)|(\s+$)/g, &apos;&apos;);//去掉首尾空格. ex) &apos;bcd &apos; -&gt; &apos;bcd&apos;</span><br><span class="line">    obj.className = removed;//替换原来的 class.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-hasClass"><a href="#3-hasClass" class="headerlink" title="- [3]  hasClass"></a>- [3]  hasClass</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function hasClass(obj, cls)&#123;</span><br><span class="line">    var obj_class = obj.className;//获取 class 内容.</span><br><span class="line">    var obj_class_lst = obj_class.split(/\s+/);//通过split空字符将cls转换成数组.</span><br><span class="line">    var x = 0;</span><br><span class="line">    for(x in obj_class_lst) &#123;</span><br><span class="line">        if(obj_class_lst[x] == cls) &#123;//循环数组, 判断是否包含cls</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="原文链接-link"><a href="#原文链接-link" class="headerlink" title="==原文链接   ++link++=="></a>==<strong>原文链接</strong>   ++<a href="https://lvwenhan.com/web-front/374.html" target="_blank" rel="noopener">link</a>++==</h6><blockquote><h4 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h4></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断样式是否存在</span><br><span class="line"> */</span><br><span class="line">function hasClass(obj, cls) &#123;</span><br><span class="line">  return obj.className.match(new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 为指定的dom元素添加样式</span><br><span class="line"> */</span><br><span class="line">function addClass(obj, cls) &#123;</span><br><span class="line">  if (!this.hasClass(obj, cls)) obj.className += &quot; &quot; + cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除指定dom元素的样式</span><br><span class="line"> */</span><br><span class="line">function removeClass(obj, cls) &#123;</span><br><span class="line">  if (hasClass(obj, cls)) &#123;</span><br><span class="line">    var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;);</span><br><span class="line">    obj.className = obj.className.replace(reg, &apos; &apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果存在(不存在)，就删除(添加)一个样式</span><br><span class="line"> */</span><br><span class="line">function toggleClass(obj, cls) &#123;</span><br><span class="line">  if (hasClass(obj, cls)) &#123;</span><br><span class="line">    removeClass(obj, cls);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    addClass(obj, cls);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="原文链接-link-1"><a href="#原文链接-link-1" class="headerlink" title="==原文链接   ++link++=="></a>==<strong>原文链接</strong>   ++<a href="http://www.edaoe.com/560.html" target="_blank" rel="noopener">link</a>++==</h6>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-addClass&quot;&gt;&lt;a href=&quot;#1-addClass&quot; class=&quot;headerlink&quot; title=&quot;- [1] addClass&quot;&gt;&lt;/a&gt;- [1] addClass&lt;/h4&gt;&lt;hr&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function addClass(obj, cls)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var obj_class = obj.className;//获取 class 内容.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var blank = (obj_class != &amp;apos;&amp;apos;) ? &amp;apos; &amp;apos; : &amp;apos;&amp;apos;;//判断获取到的 class 是否为空, 如果不为空在前面加个&amp;apos;空格&amp;apos;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var added = obj_class + blank + cls;//组合原来的 class 和需要添加的 class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj.className = added;//替换原来的 class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jquery" scheme="blog.yuanqinglong.cn/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>css解决背景透明的兼容性问题</title>
    <link href="blog.yuanqinglong.cn/css%E8%A7%A3%E5%86%B3%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98.html"/>
    <id>blog.yuanqinglong.cn/css解决背景透明的兼容性问题.html</id>
    <published>2018-01-19T01:33:33.000Z</published>
    <updated>2018-01-22T12:54:39.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全浏览器兼容背景半透明的问题的么几个解决方案："><a href="#全浏览器兼容背景半透明的问题的么几个解决方案：" class="headerlink" title="全浏览器兼容背景半透明的问题的么几个解决方案："></a>全浏览器兼容背景半透明的问题的么几个解决方案：</h3><h5 id="1-使用半透明png图片平铺"><a href="#1-使用半透明png图片平铺" class="headerlink" title="1.使用半透明png图片平铺"></a>1.使用半透明png图片平铺</h5><h5 id="2-使用opcacity属性"><a href="#2-使用opcacity属性" class="headerlink" title="2.使用opcacity属性"></a>2.使用opcacity属性</h5><h5 id="3-使用rgba和IE的opacity滤镜属性结合"><a href="#3-使用rgba和IE的opacity滤镜属性结合" class="headerlink" title="3.使用rgba和IE的opacity滤镜属性结合"></a>3.使用rgba和IE的opacity滤镜属性结合</h5><a id="more"></a><h4 id="RGBA颜色"><a href="#RGBA颜色" class="headerlink" title="RGBA颜色"></a>RGBA颜色</h4><hr><p>rgba颜色的四个属性分别表示 red红色、green绿色、blue蓝色、alpha透明度。通过这几个数值能够轻松实现背景透明。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.backTtansparent&#123;</span><br><span class="line">/* 用于不支持RGBa的浏览器 */</span><br><span class="line">background: rgb(0, 0, 0);</span><br><span class="line">/* RGBa, 透明度0.6 */</span><br><span class="line">background: rgba(0, 0, 0, 0.6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样透明只对背景生效，对于非 ie 浏览器是非常完美的解决方案。<br>不幸的是 ie8 及以下不支持 rgba 属性，并且经测试 ie9 会把 rgba 解析为全透明。</p><h4 id="IE的filter"><a href="#IE的filter" class="headerlink" title="IE的filter"></a>IE的filter</h4><hr><p>通过background: transparent注释可解决 ie9 解析rgba全透明问题。通过ie 的 filter 属性便可让 ie 支持背景透明。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.backTtansparent&#123;</span><br><span class="line">background: transparent/9;</span><br><span class="line">/* For IE 5.5 - 7*/</span><br><span class="line">filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);</span><br><span class="line">/* For IE 8*/</span><br><span class="line">-ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>能够看到filter中的8位16进制的半透明颜色#99000000为argb颜色，既#AARRGGBB，前两位是透明度，后面分别是红绿蓝。</li><li>如果我们希望透明度为 0.6，则需要将 0.6 乘以 255,再转化为 16 进制。最简单的方法是利用 JavaScript，在浏览器的调试面板里输入：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Math.floor(0.6 * 255).toString(16);</span><br></pre></td></tr></table></figure><ul><li>回车后可以看到结果为99。这样透明度0.6的黑色的argb颜色即为#99000000。<h4 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h4></li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">background: rgb(0, 0, 0);</span><br><span class="line">    /* RGBa with 0.6 opacity */</span><br><span class="line">    background: rgba(0, 0, 0, 0.6);</span><br><span class="line">    /* For IE 5.5 - 7*/</span><br><span class="line">    filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);</span><br><span class="line">    /* For IE 8*/</span><br><span class="line">    -ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;全浏览器兼容背景半透明的问题的么几个解决方案：&quot;&gt;&lt;a href=&quot;#全浏览器兼容背景半透明的问题的么几个解决方案：&quot; class=&quot;headerlink&quot; title=&quot;全浏览器兼容背景半透明的问题的么几个解决方案：&quot;&gt;&lt;/a&gt;全浏览器兼容背景半透明的问题的么几个解决方案：&lt;/h3&gt;&lt;h5 id=&quot;1-使用半透明png图片平铺&quot;&gt;&lt;a href=&quot;#1-使用半透明png图片平铺&quot; class=&quot;headerlink&quot; title=&quot;1.使用半透明png图片平铺&quot;&gt;&lt;/a&gt;1.使用半透明png图片平铺&lt;/h5&gt;&lt;h5 id=&quot;2-使用opcacity属性&quot;&gt;&lt;a href=&quot;#2-使用opcacity属性&quot; class=&quot;headerlink&quot; title=&quot;2.使用opcacity属性&quot;&gt;&lt;/a&gt;2.使用opcacity属性&lt;/h5&gt;&lt;h5 id=&quot;3-使用rgba和IE的opacity滤镜属性结合&quot;&gt;&lt;a href=&quot;#3-使用rgba和IE的opacity滤镜属性结合&quot; class=&quot;headerlink&quot; title=&quot;3.使用rgba和IE的opacity滤镜属性结合&quot;&gt;&lt;/a&gt;3.使用rgba和IE的opacity滤镜属性结合&lt;/h5&gt;
    
    </summary>
    
      <category term="前端技术" scheme="blog.yuanqinglong.cn/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="css兼容性" scheme="blog.yuanqinglong.cn/tags/css%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="blog.yuanqinglong.cn/hello-world.html"/>
    <id>blog.yuanqinglong.cn/hello-world.html</id>
    <published>2018-01-17T13:17:10.145Z</published>
    <updated>2018-01-23T03:21:38.664Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="设置「阅读全文」"><a href="#设置「阅读全文」" class="headerlink" title="设置「阅读全文」"></a>设置「阅读全文」</h3><p>1.在文章中使用 <!-- more --> 手动进行截断，Hexo 提供的方式 推荐<br>2.在文章的 front-matter 中添加 description，并提供文章摘录<br>3.自动形成摘要，在 主题配置文件 中添加：</p><p>auto_excerpt:<br>  enable: true<br>  length: 150<br>默认截取的长度为 150 字符，可以根据需要自行设定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="blog.yuanqinglong.cn/categories/hexo/"/>
    
    
      <category term="常用命令" scheme="blog.yuanqinglong.cn/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
