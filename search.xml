<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于Win10安装MongoDB报错]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EWin10%E5%AE%89%E8%A3%85MongoDB%E6%8A%A5%E9%94%99.html</url>
    <content type="text"><![CDATA[学校让留了一个爬虫任务，于是在我尝试着安装MongoDB时，遇到了这样的问题描述如下：etup wizard ended prematurely because of an error.your system has not been modified.To. Install this program at a later time run setup wizard again.click finish button to exit the setup关于解决办法：StackOverflow上给出的解决方案是：1）Choose Custom Installation2) Uncheck Compass Installation with MongoDb3) Finish the Setup4) Again start setup and click on change the installation5) Tick Compass Installation with MongoDb6) Finish the Setup简单的来说就是：需要在我们执行两次install.exe文件，第一次执行，我们会遇到compass这个选项，然后选择不打勾，继续安装（我安装报错就是因为第一遍安装时，这个选项我打勾了。。。），这样会安装成功第二次执行，会出现与第一次不同的界面，我们选择change选项，即为，改变安装项，这时，我们一路执行到上次没打勾的compass那里，然后 打勾,继续执行，安装成功附链接：https://stackoverflow.com/questions/48474477/mongodb-3-6-2-2008r2-plus-not-installing]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML(5) 样式指南和代码约定]]></title>
    <url>%2FHTML-5-%E6%A0%B7%E5%BC%8F%E6%8C%87%E5%8D%97%E5%92%8C%E4%BB%A3%E7%A0%81%E7%BA%A6%E5%AE%9A.html</url>
    <content type="text"><![CDATA[本篇内容转载自w3c良好且优秀的代码习惯是必要的，无论是开发成本上，还是从赏心悦目的程度上HTML 代码约定web 开发者常常不确定在 HTML 中使用的代码样式和语法。通过 HTML5，您必须创建属于自己的最佳实践、样式指南和代码约定。智能且有未来保证对样式的合乎逻辑的使用，可以令其他人更容易理解和使用您的 HTML。在未来，诸如 XML 阅读器之类的程序，也许需要阅读您的 HTML。使用格式良好的“近似 XHTML 的”语法，能够更智能。注释：请始终保持您的样式智能、整洁、纯净、格式良好。请使用正确的文档类型请始终在文档的首行声明文档类型：1&lt;!DOCTYPE html&gt; 如果您一贯坚持小写标签，那么可以使用： 1&lt;!doctype html&gt; 请使用小写元素名HTML5 允许在元素名中使用混合大小写字母。我们推荐使用小写元素名： 混合大小写名称并不好 开发者习惯使用小写名（比如在 XHTML 中） 小写更起来更纯净 小写更易书写 1234567891011121314//不太好 &lt;SECTION&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/SECTION&gt; //很糟糕： &lt;Section&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/SECTION&gt; 还不错： &lt;section&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/section&gt; 关闭所有 HTML 元素在 HTML5 中，您不必关闭所有元素（例如 &lt;p&gt; 元素）我们建议关闭所有 HTML 元素： 1234567891011//看起来不好：&lt;section&gt;&lt;p&gt;This is a paragraph.&lt;p&gt;This is a paragraph.&lt;/section&gt; //看起来不错：&lt;section&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;/section&gt; 关闭空的 HTML 元素在 HTML5 中，关闭空元素是可选的。允许这样： 1&lt;meta charset="utf-8"&gt; 也允许这样： 1&lt;meta charset="utf-8" /&gt; 斜杠（/）在 XHTML 和 XML 中是必需的。如果您期望 XML 软件来访问您的页面，保持这个习惯是个好主意。 使用小写属性名HTML5 允许大小写混合的属性名。我们建议使用小写属性名： 混合属性名并不好 开发者习惯于使用小写属性名（比如在 XHTML 中） 小写属性名看情况更纯净 小写属性名更易书写 12345//看起来不好：&lt;div CLASS="menu"&gt;//看起来不错：&lt;div class="menu"&gt; 属性值加引号HTML5 允许不加引号的属性值。我们推荐属性值加引号： 如果属性值包含值，则必须使用引号 混合样式绝对不好 加引号的值更易阅读 12345//这个属性值无效，因为值中包含空格：&lt;table class=table striped&gt;//这样是有效的：&lt;table class="table striped"&gt; 必需的属性请始终对图像使用 alt 属性。当图像无法显示时该属性很重要。1&lt;img src="html5.gif" alt="HTML5" style="width:128px;height:128px"&gt; #####请始终定义图像尺寸。这样做会减少闪烁，因为浏览器会在图像加载之前为图像预留空间。1&lt;img src="html5.gif" alt="HTML5" style="width:128px;height:128px"&gt; 空格和等号等号两边的空格是合法的：1&lt;link rel = "stylesheet" href = "styles.css"&gt; 但是精简空格更易阅读， But space-less is easier to read, and groups entities better together:1&lt;link rel="stylesheet" href="styles.css"&gt; 避免长代码行当使用 HTML 编辑器时，通过左右滚动来阅读 HTML 代码很不方便。请尽量避免代码行超过 80 个字符。 空行和缩进请勿毫无理由地增加空行。 为了提高可读性，请增加空行来分隔大型或逻辑代码块。 为了提高可读性，请增加两个空格的缩进。请勿使用 TAB。 请勿使用没有必要的空行和缩进。没有必要在短的和相关项目之间使用空行，也没有必要缩进每个元素： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//不必要：&lt;body&gt;&lt;h1&gt;Famous Cities&lt;/1&gt;&lt;h2&gt;Tokyo&lt;/h2&gt;&lt;p&gt; Tokyo is the capital of Japan, the center of the Greater Tokyo Area, and the most populous metropolitan area in the world. It is the seat of the Japanese government and the Imperial Palace, and the home of the Japanese Imperial Family.&lt;/p&gt;&lt;/body&gt;//更好：&lt;body&gt;&lt;h1&gt;Famous Cities&lt;/1&gt;&lt;h2&gt;Tokyo&lt;/h2&gt;&lt;p&gt;Tokyo is the capital of Japan, the center of the Greater Tokyo Area,and the most populous metropolitan area in the world.It is the seat of the Japanese government and the Imperial Palace,and the home of the Japanese Imperial Family.&lt;/p&gt;&lt;/body&gt;//表格示例：&lt;table&gt;&lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Description&lt;/th&gt;&lt;tr&gt;&lt;tr&gt; &lt;td&gt;A&lt;/td&gt; &lt;td&gt;Description of A&lt;/td&gt;&lt;tr&gt;&lt;tr&gt; &lt;td&gt;B&lt;/td&gt; &lt;td&gt;Description of B&lt;/td&gt;&lt;tr&gt;&lt;/table&gt;//列表示例：&lt;ol&gt;&lt;li&gt;LondonA&lt;/li&gt;&lt;li&gt;Paris&lt;/li&gt;&lt;li&gt;Tokyo&lt;/li&gt;&lt;/ol&gt; 省略 和 ？在 HTML5 标准中，能够省略 标签和 标签。以下代码作为 HTML5 进行验证：12345678//示例&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;title&gt;Page Title&lt;/title&gt;&lt;/head&gt;&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt; 我们不推荐省略 &lt;html&gt; 和 &lt;body&gt; 标签。 元素是文本的根元素。它是规定页面语言的理想位置。12&lt;!DOCTYPE html&gt;&lt;html lang="en-US"&gt; 对于可访问应用程序（屏幕阅读器）和搜索引擎，声明语言很重要。 省略 或 c可令 DOM 和 XML 软件崩溃。 省略 会在老式浏览器（IE9）中产生错误。 省略 ？ 在 HTML5 标准中， 标签也能够被省略。默认地，浏览器会把 之前的所有元素添加到默认的 元素。通过省略 标签，您能够降低 HTML 的复杂性：示例:12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;title&gt;Page Title&lt;/title&gt;&lt;body&gt;&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 注释：对于 web 开发者，省略标签的做法是陌生的。建立规则需要时间。 元数据&lt;title&gt;元素在 HTML5 中是必需的。请尽可能制作有意义的标题。 1&lt;title&gt;HTML5 Syntax and Coding Style&lt;/title&gt; 为了确保恰当的解释，以及正确的搜索引擎索引，在文档中对语言和字符编码的定义越早越好：123456&lt;!DOCTYPE html&gt;&lt;html lang="en-US"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;HTML5 Syntax and Coding Style&lt;/title&gt;&lt;/head&gt; HTML 注释短注释应该在单行中书写，并在 &lt;!-- 之后增加一个空格，在 &lt;!-- 之前增加一个空格： 1&lt;!-- This is a comment --&gt; 长注释，跨越多行，应该通过 &lt;!-- 和 --&gt; 在独立的行中书写：1234&lt;!-- This is a long comment example. This is a long comment example. This is a long comment example.This is a long comment example. This is a long comment example. This is a long comment example.--&gt; 长注释更易观察，如果它们被缩进两个空格的话。 样式表请使用简单的语法来链接样式表（type 属性不是必需的）： 1&lt;link rel="stylesheet" href="styles.css"&gt; 短规则可以压缩为一行，就像这样： 1p.into &#123;font-family:"Verdana"; font-size:16em;&#125; 长规则应该分为多行： 123456body &#123; background-color: lightgrey; font-family: "Arial Black", Helvetica, sans-serif; font-size: 16em; color: black;&#125; 开括号与选择器位于同一行 在开括号之前用一个空格 使用两个字符的缩进 在每个属性与其值之间使用冒号加一个空格 在每个逗号或分号之后使用空格 在每个属性值对（包括最后一个）之后使用分号 只在值包含空格时使用引号来包围值 把闭括号放在新的一行，之前不用空格 避免每行超过 80 个字符 注释：在逗号或分号之后添加空格，是所有书写类型的通用规则。 在 HTML 中加载 JavaScript请使用简单的语法来加载外部脚本（type 属性不是必需的）：1&lt;script src="myscript.js"&gt; 通过 JavaScript 访问 HTML 元素使用“不整洁”的 HTML 样式的后果，是可能会导致 JavaScript 错误。 这两个 JavaScript 语句会产生不同的结果： 123var obj = getElementById("Demo")var obj = getElementById("demo") 如果可能，请在 HTML 中使用（与 JavaScript）相同的命名约定。 使用小写文件名大多数 web 服务器（Apache、Unix）对文件名的大小写敏感： 不能以 london.jpg 访问 London.jpg。 其他 web 服务器（微软，IIS）对大小写不敏感： 能够以 london.jpg 或 London.jpg 访问 London.jpg。 如果使用混合大小写，那么您必须保持高度的一致性。 如果您从对大小写不敏感的服务器转到一台对大小写敏感的服务器上，这些小错误将破坏您的网站。 为了避免这些问题，请始终使用小写文件名（如果可以的话）。 文件扩展名HTML 文件名应该使用扩展名 .html（而不是 .htm）。 CSS 文件应该使用扩展名 .css。 JavaScript 文件应该使用扩展名 .js。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端提交数据的那些方式]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[声明：本篇文章转自https://blog.csdn.net/dancen/article/details/37572101，相比其他浅显的文章，这篇更让我收获颇多，另外，文章已略作修改，更易于自己理解Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。另外，关于URL：Uniform Resource Location 全称是资源定位符 (暂时不做和URI的区分)用于请求获取具体路径上的资源HTTP中的GET，POST，PUT，DELETE，对应的资源操作是————查，改，增，删。GET一般用于获取/查询资源信息，POST一般用于更新资源信息。根据HTTP规范，GET 用于信息获取，而且应该是安全的和幂等的。1)所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。注意：这里安全的含义仅仅是指是非修改信息。2)幂等，意味着对同一 URL 的多个请求应该返回同样的结果。A. 概念：幂等（idempotent、idempotence)是一个数学或计算机学概念，常见于抽象代数中。B. 幂等有一下几种定义：-i. 对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)=abs(abs(a))。-ii. 对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。C. 看完上述解释后，应该可以理解GET幂等的含义了。但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回最新的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。根据HTTP规范，POST表示可能修改变服务器上的资源的请求。继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后，我们已经将数据库里的数据项进行更新（插入了一天新的评论)操作，站点的资源已经不同了，或者说资源被修改了。上面大概说了一下HTTP规范中GET和POST的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说：1) 很多人贪方便，更新资源时用了GET，举个栗子来讲就是我们在跳转某个链接时可能需要附带相应参数才能跳转到相应的页面(别试了，链接瞎写的，意思到了就行了)，而POST必须要到FORM（表单)，以及再上传文件时，我们必须表单里添加这样的属性enctype = &quot;multipart/form-data&quot;，相比知悉，简单与否，便知分晓。2)对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE（尴尬的PUT,DELETE)。3)另外一个是，早期的Web MVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的Web MVC框架基本上都只支持GET和POST两种HTTP方法，而不支持PUT和DELETE方法。A. 简单解释一下MVC：MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。以上3点典型地描述了老一套的风格（没有严格遵守HTTP规范)，随着架构的发展，现在出现REST(Representational State Transfer)，一套支持HTTP规范的新风格，这里不多说了，可以参考《RESTful Web Services》。说完原理性的问题，我们再从表面现像上面看看GET和POST的区别：1) GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中)，以?分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。POST把提交的数据则放置在是HTTP包的包体中。2) “GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！其实这样说是错误的，不准确的：1) 首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。&gt;注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。2) 理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。A.对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用Request.BinaryRead则没有这个限制。B.由这个延伸出去，对于IIS 6.0，微软出于安全考虑，加大了限制。我们还需要注意：i. IIS 6.0默认ASP POST数据量最大为200KB，每个表单域限制是100KB。ii. IIS 6.0默认上传文件的最大大小是4MB。iii. IIS 6.0默认最大请求头是16KB。iv. IIS 6.0之前没有这些限制。所以上面的80K，100K可能只是默认值而已(注：关于IIS4和IIS5的参数，我还没有确认)，但肯定是可以自己设置的。由于每个版本的IIS对这些参数的默认值都不一样，具体请参考相关的IIS配置文档。3) 在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。在JSP中，用request.getParameter(\&quot;XXXX\&quot;)来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦，比如：传一个test.jsp?name=hyddd&amp;password=hyddd，用request.getQueryString()得到的是：name=hyddd&amp;password=hyddd。在PHP中，可以用$_GET和$_POST分别获取GET和POST中的数据，而$_REQUEST则可以获取GET和POST两种请求中的数据。值得注意的是，JSP中使用request和PHP中使用$_REQUEST都会有隐患。4) POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为:A. 登录页面有可能被浏览器缓存B. 其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-Site Request Forgery(跨站请求伪造)攻击。总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单)中，Method默认为”GET“实质上，GET和POST只是发送机制不同，并不是一个取一个发！]]></content>
      <categories>
        <category>POST&amp;GET&amp;PUT&amp;DELETE</category>
      </categories>
      <tags>
        <tag>POST&amp;GET&amp;PUT&amp;DELETE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Restful 接口的二三事]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E-Restful-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B.html</url>
    <content type="text"><![CDATA[互联网的发展是是迅速的，然而，这也就意味着，在纷繁复杂的环境下，前后端要想更加有效率的配合，免不了需要一种成熟的API设计理念，如：RESTful API关于restful接口的设计，近期看了一些博文，在这里谈一下收获一、协议API与用户的通信协议，总是使用HTTPs协议。二、域名应该尽量将API部署在专用域名之下。https://api.example.com如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。https://example.org/api/三、版本（Versioning）应该将API的版本号放入URL。https://api.example.com/v1/另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。四、路径（Endpoint）路径又称”终点”（endpoint），表示API的具体网址。在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees五、HTTP动词对于资源的具体操作类型，由HTTP动词表示。常用的HTTP动词有下面五个（括号里是对应的SQL命令）。GET（SELECT）：从服务器取出资源（一项或多项）。POST（CREATE）：在服务器新建一个资源。PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。DELETE（DELETE）：从服务器删除资源。还有两个不常用的HTTP动词。HEAD：获取资源的元数据。OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。下面是一些例子。GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物六、过滤信息（Filtering）如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。下面是一些常见的参数。?limit=10：指定返回记录的数量?offset=10：指定返回记录的开始位置。?page=2&amp;per_page=100：指定第几页，以及每页的记录数。?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。?animal_type_id=1：指定筛选条件参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。七、状态码（Status Codes）服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - []：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - []：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - []：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。状态码的完全列表参见这里。八、错误处理（Error handling）如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。{error: “Invalid API key”}九、返回结果针对不同操作，服务器向用户返回的结果应该符合以下规范。GET /collection：返回资源对象的列表（数组）GET /collection/resource：返回单个资源对象POST /collection：返回新生成的资源对象PUT /collection/resource：返回完整的资源对象PATCH /collection/resource：返回完整的资源对象DELETE /collection/resource：返回一个空文档十、Hypermedia APIRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。{“link”: {“rel”: “collection https://www.example.com/zoos“,“href”: “https://api.example.com/zoos“,“title”: “List of zoos”,“type”: “application/vnd.yourformat+json”}}上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。{“current_user_url”: “https://api.github.com/user“,“authorizations_url”: “https://api.github.com/authorizations“,// …}从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。{“message”: “Requires authentication”,“documentation_url”: “https://developer.github.com/v3“}上面代码表示，服务器给出了提示信息，以及文档的网址。十一、其他（1）API的身份认证应该使用OAuth 2.0框架。（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。（完）]]></content>
      <categories>
        <category>Restful</category>
      </categories>
      <tags>
        <tag>Restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ES6-变量的解构与赋值]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EES6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E4%B8%8E%E8%B5%8B%E5%80%BC.html</url>
    <content type="text"><![CDATA[阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》原文链接：http://es6.ruanyifeng.com/?search=import&amp;x=0&amp;y=0#docs/destructuring关于ES6,很多浏览器都已经实现支持其大部分的语法，以及，在很多框架里，如Vue.js,以及一些基于Node.js的框架，都可以看到类似ES6语法的影子数组的解构赋值####基本用法ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。以前，为变量赋值，只能直接指定值。123let a = 1;let b = 2;let c = 3; ES6 允许写成下面这样。 1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。 12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。 对于 Set 结构，也可以使用数组的解构赋值。12let [x, y, z] = new Set(['a', 'b', 'c']);x // "a" 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 1234567891011function* fibs() &#123;let a = 0;let b = 1;while (true) &#123; yield a; [a, b] = [b, a + b];&#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。 默认值 解构赋值允许指定默认值。 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() &#123;console.log('aaa');&#125;let [x = f()] = [1]; 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。 123456let x;if ([1][0] === undefined) &#123;x = f();&#125; else &#123;x = [1][0];&#125; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。 对象的解构赋值 解构不仅可以用于数组，还可以用于对象。 123let &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，- 变量必须与属性同名，才能取到正确的值。 123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。 如果变量名与属性名不一致，必须写成下面这样。 1234567let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。 1let &#123; foo: foo, bar: bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // "aaa"foo // error: foo is not defined 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 与数组一样，解构也可以用于嵌套结构的对象。 12345678910let obj = &#123;p: [ 'Hello', &#123; y: 'World' &#125;]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World" 注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。 1234567891011let obj = &#123;p: [ 'Hello', &#123; y: 'World' &#125;]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"p // ["Hello", &#123;y: "World"&#125;] 下面是另一个例子。 12345678910111213const node = &#123;loc: &#123; start: &#123; line: 1, column: 5 &#125;&#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; 上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。 下面是嵌套赋值的例子。1234567let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true] 对象的解构也可以指定默认值。123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 默认值生效的条件是，对象的属性值严格等于undefined。 12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。 如果解构失败，变量的值等于undefined。 12let &#123;foo&#125; = &#123;bar: 'baz'&#125;;foo // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 12// 报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;; 上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。 12let _tmp = &#123;baz: 'baz'&#125;;_tmp.foo.bar // 报错 如果要将一个已经声明的变量用于解构赋值，必须非常小心。 12345// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。 123// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); 上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 123(&#123;&#125; = [true, false]);(&#123;&#125; = 'abc');(&#123;&#125; = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 1let &#123; log, sin, cos &#125; = Math; 上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。 字符串的解构赋值 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值 函数的参数也可以使用解构赋值。 12345function add([x, y])&#123;return x + y;&#125;add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 下面是另一个例子。 123456789101112[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ]函数参数的解构也可以使用默认值。function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 注意，下面的写法会得到不一样的结果 1234567891011121314function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0]上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。undefined就会触发函数参数的默认值。[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 圆括号问题 解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况 以下三种解构赋值不得使用圆括号。 （1）变量声明语句123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。 （2）函数参数123456函数参数也属于变量声明，因此不能带有圆括号。// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125; ####（3）赋值语句的模式123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 12// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 上面代码将一部分模式放在圆括号之中，导致报错。 可以使用圆括号的情况 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途 变量的解构赋值用途很多。 ####（1）交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516// 返回一个数组function example() &#123;return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123;return &#123; foo: 1, bar: 2&#125;;&#125;let &#123; foo, bar &#125; = example(); （3）函数参数的定义123456789- 解构赋值可以方便地将一组参数与变量名对应起来。 // 参数是一组有次序的值 function f([x, y, z]) &#123; ... &#125; f([1, 2, 3]); // 参数是一组无次序的值 function f(&#123;x, y, z&#125;) &#123; ... &#125; f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取 JSON 数据12345678910111213解构赋值对提取 JSON 对象中的数据，尤其有用。let jsonData = &#123;id: 42,status: "OK",data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309]上面代码可以快速提取 JSON 数据的值。 ####（5）函数参数的默认值 123456789101112 jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config &#125; = &#123;&#125;) &#123; // ... do stuff&#125;;指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。 （6）遍历 Map 结构 任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123;console.log(key + " is " + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 12345678910// 获取键名for (let [key] of map) &#123;// ...&#125;// 获取键值for (let [,value] of map) &#123;// ... } （7）输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map");]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>变量的解构与赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础———选择排序]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[日积跬步，以期千里。《算法基础·打开算法之门》小札概念首先声明array[i]是目前所看到的子数组中最小的元素，然后扫描数组的剩余部分，每当发现一个有一个元素小于当前最小的元素时，我们就更新最小元素的索引逻辑1.令i从0到n-1依次取值A. 将smallest赋值为 i.B. 令j从i+1到n依次取值：i. 如果A[j] &lt; A[smallest],那么将smallest赋值为j。C. 交换 A[i] 与 A[smallest]的值复杂度选择排序的时间复杂度取决于外层循环的索引i。时间复杂度O(n^2)空间复杂度O（1）js程序代码1234567891011121314151617181920function selectionSort(arr) &#123; var len = arr.length; var smallest, temp; console.time('选择排序耗时'); for (var i = 0; i &lt; len - 1; i++) &#123; smallest = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[smallest]) &#123; //寻找最小的数 smallest = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[smallest]; arr[smallest] = temp; &#125; console.timeEnd('选择排序耗时'); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(selectionSort(arr)); 其实选择排序适合小数据排序，具体这个小数据有多小呢，简单的测试了一下，在1000条以内的数据，选择排序更胜冒泡排序。]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础之二分查找]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</url>
    <content type="text"><![CDATA[最近在看《算法基础·打开算法之门》（毕竟程序猿的算法不能太差…）人总是健忘的，所以我决定将我收获的东西记录下来那么，首先，就是你了，最基础的二分查找！关于二分查找，可以拥有如下叙述:任意情况下，我们仅仅考虑某个子数组，也就是说，介于某两个索引之间的部分数组，将这两个索引依次记为p和r。初始时，p=1,r=n，因此开始时，子数组为整个完整数组，我们反复地将数组规模减半，直到一下任意一种情况发生：要么找到了要查找的元素，要么当前子数组为空（p&gt;r）。反复对子数组执行减半操作需要的时间花费是O(lgn)case-1逻辑：程序：binary-search(arr,n,x)输入：arr:一个数组n:数组中元素的个数x要查找的值输出满足条件的arr[i]的索引i，特殊值‘not found’（相对于数组的任意无效索引值）具体步骤1）将p赋值为1,r赋值为n2）只要p &lt; = r,执行如下操作：A.将q赋值为(p + r) / 2 ———— ps:向下取整B.如果A[q] = x,那么返回q。C.否则（A[q] ! = x）,如果A[q]&gt;x,那么将r赋值为为q-1D.否则（A[q] &lt; x），那么将p赋值为q+13）返回“not found”js代码实现12345678910111213141516171819//默认由小到大排列数据function binary-search(arr,n,x)&#123; var p = 0; var r = n-1; if(p &lt; = r)&#123; var q = Math.floor((p+r)/2); if(arr[q] == x)&#123; return q; &#125;else&#123; if(arr[q]&gt;x)&#123; r = q - 1; //真实上限索引要比x索引小，所以需要对数组上限重新取半赋值； &#125;else&#123; p = q + 1 //真实下限索引要比x索引大，所以需要对数组上限重新取半赋值； &#125; &#125; &#125;else&#123; return 'NOT FOUND !'; &#125;&#125; case-2 (递归的方式)逻辑：程序：recursive-binary-search(arr,p,r,x)输入输出 相关变量同上文 增加p ,r 为数组arr的开头结尾索引 具体步骤 1）如果p &gt; r,那么返回“not found” 2）否则(p &lt; = r),执行如下操作： A.将q赋值为(p + r) / 2 ———— ps:向下取整 B.如果A[q] = x,那么返回q。 C.否则（A[q] ! = x）,如果A[q] &gt; x,那么返回一个 recursive-binary-search(arr,p,q-1,x) D.否则（A[q] &lt; x），那么返回一个 recursive-binary-search(arr,q+1,r,x) js代码实现1234567891011121314151617//默认由小到大排列数据function recursive-binary-search(arr,p,r,x)&#123; if(p &gt; r)&#123; return 'NOT FOUND !'; &#125;else&#123; //p &lt; = r var q = Math.floor((p + r) / 2); if(arr[q] == x)&#123; return q; &#125;else&#123; if(arr[q] &gt; x)&#123; return recursive-binary-search(arr,p,q-1,x); //真实上限索引要比x索引小，所以需要对数组上限重新取半赋值； &#125;else&#123; return recursive-binary-search(arr,q+1,r,x); //真实下限索引要比x索引大，所以需要对数组上限重新取半赋值； &#125; &#125; &#125; &#125; 当然，以上的代码也许会有错误（好像没有…），因为只是单纯根据逻辑撸码，具体事件具体分析。]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决输入框长度maxLength的兼容性问题]]></title>
    <url>%2F%E8%A7%A3%E5%86%B3%E8%BE%93%E5%85%A5%E6%A1%86%E9%95%BF%E5%BA%A6maxLength%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[最近在忙着做些东西，差点荒废了我的博客，随便写点什么吧在input标签中，只需要设置maxlength=”*”即可，但是在textarea标签中，IE9及IE9以下浏览器是不支持的，IE10、IE11则支持，估计后续的版本应该都会支持12345&lt;textarea id="taContent" rows="3" maxlength="20" onchange="this.value=this.value.substring(0, 20)"onkeydown="this.value=this.value.substring(0, 20)" onkeyup="this.value=this.value.substring(0, 20)" &gt;&lt;/textarea&gt; 备注：onchange、onkeydown、onkeyup三者缺一不可。 如省略onchange，当你用负责功能，此时一直按着ctrl不松开，鼠标去点击其他地方（焦点移出textarea）时，不会自动取消超出部分； 如省略onkeydown，猛敲的时候会有很多个字符突然不见了； 如省略onkeyup，原想预计20的情况下，会变成21，并且最后一个字符是最后敲进去的。 Maxlength 也不可省略，加上maxlength 当碰到IE10及以上版本时，可以完美的实现限制输入框字数的功能。不想其他低版本的IE浏览器还可以出现一个字母后消失。 本方法参考自： http://www.thylx.net/newsdetail.aspx?id=37]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>maxLength</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改变浏览器位置]]></title>
    <url>%2F%E6%94%B9%E5%8F%98%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。实际上，就是改变浏览器的url，so，有哪些方法呢？1231) location.assign("http://www.wrox.com")2) window.location = "http://www.wrox.com"3) location.href = "http://www.wrox.com" 当然，2）、3）其实都是调用了assign()方法的，只不过是形式不一样而已， 另外，每次修改location的属性时，如hostname,path,port等时(hash除外)，页面都会以新的URL载入， 注：无论以何种方式修改URL。都会在历史记录中生成一条新的纪录 若要禁止这种行为（即生成一条新的纪录），可以使用replace()方法，该方法接受一个参数，即要导航到的URL。 12location.replace("http://www.wrox.com"); 结果就是，同样会导致浏览器的位置改变，但是不会在历史记录生成新的纪录 最后一种改变浏览器位置的方法：reload reload //重新加载，可能是从个缓存中加载 reload(true); //强制加载，即从服务器端加载 注意：reload()调用后，也有可能不会立即执行，它取决于网络资源或系统延迟等，所以最好将reload()放在代码的最后一行]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>loaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找到数组的最值]]></title>
    <url>%2F%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%80%BC.html</url>
    <content type="text"><![CDATA[吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。在一个数组中找到最值，书中给了我们这样的一个方法（以最大值为例）：123var Values = [1,2,3];var max = Math.max.apply(Math,Values);var max = Math.max.apply(null,Values); 那么：1）问题一，为什么是 Math.max.apply() ,而非 Math.max()?答： max()方法本身需要大于等于2个的纯数字参数比如： 123console.log(Math.max(10,20,30))//"30"console.log(Math.max(10,20))//"20" console.log(Math.max(a,b));//ReferenceError: a is not defined 很明显，Math.max() 的Values，只是一个变量，无法满足大于等于2，以及纯数字的两个条件，所以为满足要求（求数组里的最值），Math.max.apply()无疑是非常好的方法： 2）问题二，为什么是 Math.max.apply(),而非是 Math.max().apply()答：我们要明白两个知识点 【1】 max() 与 max 的区别，函数名本质上是一个指向存储函数代码的内存地址的指针，单纯的写函数名并不会而函数名后面加括号如： max() ，则是对函数的调用执行。 【2】 apply() 、 call() 是每个函数都包含的非继承的方法。作用是在 特定的作用域 中 调用函数。 前者可以接受两个参数，后者可以接受两个及两个以上的参数。二者的第一个参数都是设置函数体内的 This 指向，即 “ 特定的作用域 ”。只写一个参数的情况下，默认设置的是 This 指向。 而 调用函数，等价于函数名后面加括号的效果。3）问题三， Math.max.apply(null,Values) 与 Math.max.apply(Math,Values) 区别？答：没区别。 因为第一个参数是 特定的作用域 （也就是this指向），又因为，null，默认是前面的对象。而在本题中，前面的对象是Math，所以显而易见，二者结果并无区别。，]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>apply、call</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[charAt与 indexOf与lastIndexOf]]></title>
    <url>%2FcharAt%E4%B8%8E-indexOf%E4%B8%8ElastIndexOf.html</url>
    <content type="text"><![CDATA[吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。访问字符串中特定字符的方法是：charAt() &amp; charCodeAt() var stringValue = "hello world"; alert(stringValue.charAt(1));//"e" alert(stringValue.charCodeAt(1));//"101" 上述代码中1)前者charAt()输出的是指定位置的 字符2)后者charCodeAt()输出的是指定位置的字符串的编码从字符串中查找子字符串的方法是：indexOf() &amp; lastIndexOf() var stringValue = "hello world"; alert(stringValue.indexOf("o"));//"4" alert(stringValue.lastIndexOf("o"));//"7" 上述代码中无论是indexOf()还是lastIndexOf()，返回的子字符串位置都是基于正向查询 (始于0) 。由此可知，若子字符串在源字符串中只出现过一次，则两种方法返回相同的结果。若未找到该字符串，则都返回-1而区别在于：1）前者indexOf()方法，是从开头向后搜索字符串2）后者lastIndexOf()方法，是从末尾向开头搜索字符串]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>字符串位置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 ‘ + ’ 与 new Date]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E-%E2%80%99-%E2%80%98-%E4%B8%8E-new-Date.html</url>
    <content type="text"><![CDATA[在读《javascript高级程序设计（第三版）》时，遇到的一行代码var start = +new Date();那么，+new Date()是什么意思？虽然大概有些猜测,但，我还是决定查一查。Javascript中可以在某个元素前使用+号,这个操作是将该元素转换成Number类型，如果转换失败，会得到NAN.注：（适当的使用 运算符 可以简化 Number类型的转化过程）所以 +newDate将会调用Data.prototype上的valueOf,而且，查一查MDN，我们也可以知道，Data.prototype.valueOf()等价于Date.prototype.getTime().所以下列代码的效果是相同的：1234console.log(+new Date);console.log(new Date().getTime());console.log(new Date().valueOf());console.log(new Date()*1); 经过实际测试，以上所有代码都会返回当前时间的总毫秒数,（单纯的 new Date或new Date()会输出GMT时间， 如：Fri Mar 09 2018 22:17:43 GMT+0800 (中国标准时间)） 实际上，在上述代码中，不止+号，在代码后面加上*1或者/1达到相同的输出效果]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>逻辑运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ajax，大概需要了解哪些基础性的东西？]]></title>
    <url>%2F%E5%85%B3%E4%BA%8Eajax%EF%BC%8C%E5%A4%A7%E6%A6%82%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%80%A7%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%9F.html</url>
    <content type="text"><![CDATA[人总是健忘的，那么为什么不多动动手呢？比如说把知识记下来。我们总会或有或无的接触ajax技术，那么作为一名学习者，就有必要了解相关的知识ajax(客户端与服务器端异步的通信的技术)原理:相当于在用户和服务器之间加了—个中间层(AJAX引擎),通过创建一个XmlHttpRequest对象来向服务器发异步请求,通过回调在回调函数里进行dom操作.代码原理：1.第一步：创建XMLHttpRequest 对象xmlhttp=new XMLHttpRequest();（它有兼容性问题，在ie中用的是new ActiveXObject） 2.第二步：向服务器发送请求xmlhttp.open(&quot;GET/POST&quot;,url,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//POST时要加这句话 xmlhttp.send(); 3.第三步：执行回调，在回调函数中进行相应的dom操作xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)//判断状态码 { //就可以执行相应的dom操作 document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; } } readyState有5种值：0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status状态码常见的有：200 服务器成功返回 301 永久重定向 302 临时重定向 304 缓存 403 服务器拒绝访问 404 资源找不到 500 服务器错误 优与劣ajax的优点:&lt;1&gt;.无刷新更新数据。 &lt;2&gt;.异步与服务器通信。 &lt;3&gt;.前端和后端负载平衡。(减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担) &lt;4&gt;.基于标准被广泛支持。 &lt;5&gt;.界面与应用分离。 ajax的缺点:&lt;1&gt;.AJAX干掉了Back和History功能，即对浏览器机制的破坏。 &lt;2&gt;.AJAX的安全问题。 &lt;3&gt;.违背URL和资源定位的初衷。 &lt;4&gt;.客户端过肥，太多客户端代码造成开发上的成本。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对CommonJS规范的一些理解]]></title>
    <url>%2F%E5%AF%B9CommonJS%E8%A7%84%E8%8C%83%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3.html</url>
    <content type="text"><![CDATA[咸鱼了一个寒假，不能再这样了。。。学海无涯啊0.0概述Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。12345example.jsvar x = 5;var addX = function (value) &#123;return value + x;&#125;; 上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。 如果想在多个文件分享变量，必须定义为global对象的属性。 1global.warning = true; 上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。 CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 123456var x = 5;var addX = function (value) &#123;return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; 上面代码通过module.exports输出变量x和函数addX。 require方法用于加载模块。 123var example = require('./example.js');console.log(example.x); // 5console.log(example.addX(1)); // 6 require方法的详细解释参见《Require命令》一节。 CommonJS模块的特点如下: 1.所有代码都运行在模块作用域，不会污染全局作用域。2.模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了,以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。3.模块加载的顺序，按照其在代码中出现的顺序。 module对象 Node内部提供一个Module构建函数。所有模块都是Module的实例。 12345function Module(id, parent) &#123;this.id = id;this.exports = &#123;&#125;;this.parent = parent;// ... 每个模块内部，都有一个module对象，代表当前模块。它有以下属性。 module.id 模块的识别符，通常是带有绝对路径的模块文件名。module.filename 模块的文件名，带有绝对路径。module.loaded 返回一个布尔值，表示模块是否已经完成加载。module.parent 返回一个对象，表示调用该模块的模块。module.children 返回一个数组，表示该模块要用到的其他模 块。module.exports 表示模块对外输出的值。 下面是一个示例文件，最后一行输出module变量。 1234// example.jsvar jquery = require('jquery');exports.$ = jquery;console.log(module); 执行这个文件，命令行会输出如下信息。 12345678910111213141516171819&#123; id: '.',exports: &#123; '$': [Function] &#125;,parent: null,filename: '/path/to/example.js',loaded: false,children:[ &#123; id: '/path/to/node_modules/jquery/dist/jquery.js', exports: [Function], parent: [Circular], filename: '/path/to/node_modules/jquery/dist/jquery.js', loaded: true, children: [], paths: [Object] &#125; ],paths:[ '/home/user/deleted/node_modules', '/home/user/node_modules', '/home/node_modules', '/node_modules' ]&#125; 如果在命令行下调用某个模块，比如node something.js，那么module.parent就是null。如果是在脚本之中调用，比如require(‘./something.js’)，那么module.parent就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。 123456789if (!module.parent) &#123; // ran with `node something.js` app.listen(8088, function() &#123; console.log('app listening on port 8088'); &#125;) &#125; else &#123; // used with `require('/.something.js')` module.exports = app; &#125; module.exports属性 module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。 123456var EventEmitter = require('events').EventEmitter;module.exports = new EventEmitter();setTimeout(function() &#123;module.exports.emit('ready');&#125;, 1000); 上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。 1234var a = require('./a');a.on('ready', function() &#123;console.log('module a is ready');&#125;); exports变量 为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。 1var exports = module.exports; 造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。 1234567exports.area = function (r) &#123;return Math.PI * r * r;&#125;;exports.circumference = function (r) &#123;return 2 * Math.PI * r;&#125;; 注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。 1exports = function(x) &#123;console.log(x)&#125;; 上面这样的写法是无效的，因为exports不再指向module.exports了。 下面的写法也是无效的。 12345exports.hello = function() &#123;return 'hello';&#125;;module.exports = 'Hello world'; 上面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了。 这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。 1module.exports = function (x)&#123; console.log(x);&#125;; 如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。 AMD规范与CommonJS规范的兼容性 CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。 AMD规范使用define方法定义模块，下面就是一个例子： 123456789define(['package/lib'], function(lib)&#123;function foo()&#123; lib.log('hello world!');&#125;return &#123; foo: foo&#125;;&#125;); AMD规范允许输出的模块兼容CommonJS规范，这时define方法需要写成下面这样： 123456789101112define(function (require, exports, module)&#123;var someModule = require("someModule");var anotherModule = require("anotherModule");someModule.doTehAwesome();anotherModule.doMoarAwesome();exports.asplode = function ()&#123; someModule.doTehAwesome(); anotherModule.doMoarAwesome();&#125;;&#125;); require命令基本用法 Node使用CommonJS模块规范，内置的require命令用于加载模块文件。 require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。 12345678910// example.jsvar invisible = function () &#123;console.log("invisible");&#125;exports.message = "hi";exports.say = function () &#123;console.log(message);&#125; 运行下面的命令，可以输出exports对象。 123456var example = require('./example.js');example// &#123;// message: "hi",// say: [Function]// &#125; 如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定在module.exports变量上面。 123456789101112131415 module.exports = function () &#123; console.log("hello world") &#125; require('./example2.js')() ``` 上面代码中，require命令调用自身，等于是执行module.exports，因此会输出 hello world。#### 加载规则- require命令用于加载文件，后缀名默认为.js。 ```bash var foo = require('foo'); // 等同于 var foo = require('foo.js'); 根据参数的不同格式，require命令去不同路径寻找模块文件。 （1）如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(&#39;/home/marco/foo.js&#39;)将加载/home/marco/foo.js。 （2）如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(&#39;./circle&#39;)将加载当前脚本同一目录的circle.js。 （3）如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。 举例来说，脚本/home/user/projects/foo.js执行了require(&#39;bar.js&#39;)命令，Node会依次搜索以下文件。 /usr/local/lib/node/bar.js/home/user/projects/node_modules/bar.js/home/user/node_modules/bar.js/home/node_modules/bar.js/node_modules/bar.js 这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。 （4）如果参数字符串不以“./“或”/“开头，而且是一个路径， 比如require(&#39;example-module/path/to/file&#39;)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。 （5）如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。 （6）如果想得到require命令加载的确切文件名，使用require.resolve()方法。 目录的加载规则 通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录。在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。 123// package.json&#123; "name" : "some-library","main" : "./lib/some-library.js" &#125; require发现参数字符串指向一个目录以后，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件。如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件。 模块的缓存 第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性。 1234require('./example.js');require('./example.js').message = "hello";require('./example.js').message// "hello" 上面代码中，连续三次使用require命令，加载同一个模块。第二次加载的时候，为输出的对象添加了一个message属性。但是第三次加载的时候，这个message属性依然存在，这就证明require命令并没有重新加载模块文件，而是输出了缓存。 如果想要多次执行某个模块，可以让该模块输出一个函数，然后每次require这个模块的时候，重新执行一下输出的函数。 所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写。 1234567// 删除指定模块的缓存delete require.cache[moduleName];// 删除所有模块的缓存Object.keys(require.cache).forEach(function(key) &#123;delete require.cache[key];&#125;) 注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，require命令还是会重新加载该模块。 环境变量NODE_PATH Node执行一个脚本时，会先查看环境变量NODE_PATH。它是一组以冒号分隔的绝对路径。在其他位置找不到指定模块时，Node会去这些路径查找。 可以将NODE_PATH添加到.bashrc。 1export NODE_PATH="/usr/local/lib/node" 所以，如果遇到复杂的相对路径，比如下面这样。 1var myModule = require('../../../../lib/myModule'); 有两种解决方法，一是将该文件加入node_modules目录，二是修改NODE_PATH环境变量，package.json文件可以采用下面的写法。 1234567891011&#123;"name": "node_path","version": "1.0.0","description": "","main": "index.js","scripts": &#123; "start": "NODE_PATH=lib node index.js"&#125;,"author": "","license": "ISC"&#125; NODE_PATH是历史遗留下来的一个路径解决方案，通常不应该使用，而应该使用node_modules目录机制。 模块的循环加载 如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。 12345678910111213// a.jsexports.x = 'a1';console.log('a.js ', require('./b.js').x);exports.x = 'a2';// b.jsexports.x = 'b1';console.log('b.js ', require('./a.js').x);exports.x = 'b2';// main.jsconsole.log('main.js ', require('./a.js').x);console.log('main.js ', require('./b.js').x); 上面代码是三个JavaScript文件。其中，a.js加载了b.js，而b.js又加载a.js。这时，Node返回a.js的不完整版本，所以执行结果如下。 12345$ node main.jsb.js a1a.js b2main.js a2main.js b2 修改main.js，再次加载a.js和b.js。 12345// main.jsconsole.log('main.js ', require('./a.js').x);console.log('main.js ', require('./b.js').x);console.log('main.js ', require('./a.js').x);console.log('main.js ', require('./b.js').x); 执行上面代码，结果如下。 1234567$ node main.jsb.js a1a.js b2main.js a2main.js b2main.js a2main.js b2 上面代码中，第二次加载a.js和b.js时，会直接从缓存读取exports属性，所以a.js和b.js内部的console.log语句都不会执行了。 require.main require方法有一个main属性，可以用来判断模块是直接执行，还是被调用执行。 直接执行的时候（node module.js），require.main属性指向模块本身。 require.main === module // true 调用执行的时候（通过require加载该脚本执行），上面的表达式返回false。 模块的加载机制 CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。 下面是一个模块文件lib.js。 // lib.js var counter = 3; function incCounter() { counter++; } module.exports = { counter: counter, incCounter: incCounter, }; 上面代码输出内部变量counter和改写这个变量的内部方法incCounter。 然后，加载上面的模块。 // main.js var counter = require(&apos;./lib&apos;).counter; var incCounter = require(&apos;./lib&apos;).incCounter; console.log(counter); // 3 incCounter(); console.log(counter); // 3 上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。 require的内部处理流程 require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。 123456789Module._load = function(request, parent, isMain) &#123;// 1. 检查 Module._cache，是否缓存之中有指定模块// 2. 如果缓存之中没有，就创建一个新的Module实例// 3. 将它保存到缓存// 4. 使用 module.load() 加载指定的模块文件，// 读取文件内容之后，使用 module.compile() 执行文件代码// 5. 如果加载/解析过程报错，就从缓存删除该模块// 6. 返回该模块的 module.exports&#125;; 上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。 123456Module.prototype._compile = function(content, filename) &#123;// 1. 生成一个require函数，指向module.require// 2. 加载其他辅助方法到require// 3. 将文件内容放到一个函数之中，该函数可调用 require// 4. 执行该函数&#125;; 上面的第1步和第2步，require函数及其辅助方法主要如下。 12345require(): 加载外部模块require.resolve()：将模块名解析到一个绝对路径require.main：指向主模块require.cache：指向所有缓存的模块require.extensions：根据文件的后缀名，调用不同的执行函数 一旦require函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括require、module、exports，以及其他一些参数。 123(function (exports, require, module, __filename, __dirname) &#123;// YOUR CODE INJECTED HERE!&#125;); Module._compile方法是同步执行的，所以Module._load要等它执行完成，才会向用户返回module.exports的值。 本文引自阮一峰的文章受益匪浅，由是感激！链接：http://javascript.ruanyifeng.com/nodejs/module.html#]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>CommonJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ES6 const 篇]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EES6-const-%E7%AF%87.html</url>
    <content type="text"><![CDATA[阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》原文链接：http://es6.ruanyifeng.com/#docs/let学海无涯，愿与诸君共勉const 命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。123456var message = "Hello!";let age = 25;// 以下两行都会报错const message = "Goodbye!";const age = 30; 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: "foo" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。Node 里面，顶层对象是global，但其他环境都不支持。同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。1234567891011121314151617// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;; 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。 垫片库system.global模拟了这个提案，可以在所有环境拿到global。1234567891011121314// CommonJS 的写法require('system.global/shim')();// ES6 模块的写法import shim from 'system.global/shim'; shim();上面代码可以保证各种环境里面，global对象都是存在的。// CommonJS 的写法var global = require('system.global')();// ES6 模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ES6 : let 篇]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EES6-let-%E7%AF%87.html</url>
    <content type="text"><![CDATA[阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》原文链接：http://es6.ruanyifeng.com/#docs/let学海无涯，愿与诸君共勉基本用法块级作用域ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。12345678 &#123; let a = 10; var b = 1; &#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。for循环的计数器，就很合适使用let命令。 123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // "undefined" 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 有些“死区”比较隐蔽，不太容易发现。12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。123456// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined 上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 块级作用域为什么需要块级作用域？ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。1&#123;&#123;&#123;&#123;&#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。1234&#123;&#123;&#123;&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域与函数声明函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。1234567891011// 情况一if (true) &#123; function f() &#123;&#125;&#125;// 情况二try &#123; function f() &#123;&#125;&#125; catch(e) &#123; // ...&#125; 上面两种函数声明，根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。12345678910function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。123456789// ES5 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ 原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。 // 浏览器的 ES6 环境1234567891011function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。1234567891011// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; var f = undefined; if (false) &#123; function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。123456789101112131415// 函数声明语句&#123; let a = 'secret'; function f() &#123; return a; &#125;&#125;// 函数表达式&#123; let a = 'secret'; let f = function () &#123; return a; &#125;;&#125; 另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。12345678910// 不报错'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错'use strict';if (true) function f() &#123;&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>let</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于object.key与object[key]的区别]]></title>
    <url>%2F%E5%85%B3%E4%BA%8Eobject-key%E4%B8%8Eobject-key-%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[记录所需要的，摒弃多余的。本篇文章是对segmentfault的一个问答的总结。obeject.key与object[key]有什么区别?有什么区别，不试试怎么知道？测试代码（其实有很多栗子，随便举一个）： var obj = { name: &apos;tom&apos;, age: 22 }, someKey = &apos;age&apos;; console.log(obj.name); console.log(obj[&apos;name&apos;]); console.log(obj.someKey); console.log(obj[someKey]); 测试结果：（放图）通常来讲， obj[“key”] 与 obj.key 的作用差不多，但是，如果key不确定（key是变量）的情况下，或者key的写法比较特殊（比如包含空格什么的）则只能通过obj[ ]的方式去访问]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用语法]]></title>
    <url>%2FMarkdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[写博客，自然免不了接触Markdown,作为初学者，为了即用即查，我决定把相关命令记录下来，本文就是边学边写此处声明：本文是 参考他人的文章&amp;结合实践后，所写，另外，转载、复制随意，但请务必注明本文链接标题：写法:123456# h1级标题## h2级标题### h3级标题#### h4级标题##### h5级标题###### h6级标题 栗子： 这是一个h4级标题 注意： #与标题文字间要有空格 当-与#结合使用时，如果不想下一行受到干扰，可以使用Enter换行 分割线：连续三个&amp;三个以上的- 即可作出分割线 写法:1--- 栗子： 注意：建议写分割线时，与上一行留出一空行 超链接：写法1：1234[连接名称](网址 , 标题)[baidu](https://www.baidu.com, "baidu")[&lt;i class="icon-refresh"&gt;&lt;/i&gt; 点我刷新](/#) 栗子： baidu 点我刷新 写法2：12345[链接名][链接代号][链接代号]:详细地址[here][3][3]: http://www.baidu.com 栗子： here 写法3：1直接展示链接：&lt;http://www.baidu.com&gt; 栗子： 直接展示链接：http://www.baidu.com 键盘键用法：1&lt;kbd&gt;Ctrl+[&lt;/kbd&gt; and &lt;kbd&gt;Ctrl+]&lt;/kbd&gt; 栗子： Ctrl+[ and Ctrl+] code格式：反引号 用法：12Use the `printf()` function. ``There is a literal backtick (`) here.针对在代码区段内插入反引号的情况` 栗子： Use the printf() function. There is a literal backtick (`) here.针对在代码区段内插入反引号的情况 强调：用法：12*斜体强调***粗体强调** 栗子： 斜体强调 粗体强调 图片：用法：12![Alt text](../imgs/blogContentImgs/jhvh.jpg "这图我觉得扣得不错")如果图片链接失效的话，会显示 Alt text 栗子： 使用 icon 图标文字：用法：1&lt;i class="fa fa-github"&gt;&lt;/i&gt; 栗子： 段落： 以一个空行开始，以一个空行结束，中间的就是一个段落。 表格：用法：12345Item | Value-------- | ---Computer | $1600Phone | $12Pipe | $1 栗子： Item Value Computer $1600 Phone $12 Pipe $1 无序列表：使用 - 加一个空格 用法：123- 无需列表1- 无序列表2- 无序列表3 栗子： 无需列表1 无序列表2 无序列表3 有序列表：使用 数字 加一个英文句点 用法：123451. 有序列表2. 有序列表3. 有序列表4. 有序列表5. 有序列表 栗子： 有序列表 有序列表 有序列表 有序列表 有序列表 换行缩进形成代码区块：用法：这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。 栗子：这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。 块引用用法：12345678&gt;给引用的文本开始位置都加一个 '&gt;'，&gt;便可组成一个块引用。在块引用中，可以结合&gt;其他markdown元素一块使用，比如列表。&gt;**强调**也可以只在第一行加大于号，其他位置不加。&gt;- 块引用里使用列表，需要和上面的内容隔开一个空行&gt;- 记得加空格哦。 栗子： 给引用的文本开始位置都加一个 ‘&gt;’，便可组成一个块引用。在块引用中，可以结合其他markdown元素一块使用，比如列表。强调也可以只在第一行加大于号，其他位置不加。 块引用里使用列表，需要和上面的内容隔开一个空行 记得加空格哦。 本文参考链接：[掌握这几种 Markdown 语法你就够了]https://laravel-china.org/topics/621/you-will-be-able-to-master-these-markdown-grammars[中文文案排版指北]:https://github.com/sparanoid/chinese-copywriting-guidelines]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现jQuery的addClass, removeClass, hasClass函数功能]]></title>
    <url>%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0jQuery%E7%9A%84addClass%2C%20removeClass%2C%20hasClass%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD.html</url>
    <content type="text"><![CDATA[- [1] addClass123456function addClass(obj, cls)&#123; var obj_class = obj.className;//获取 class 内容. var blank = (obj_class != &apos;&apos;) ? &apos; &apos; : &apos;&apos;;//判断获取到的 class 是否为空, 如果不为空在前面加个&apos;空格&apos;. var added = obj_class + blank + cls;//组合原来的 class 和需要添加的 class. obj.className = added;//替换原来的 class.&#125; - [2] removeClass 1234567function removeClass(obj, cls)&#123; var obj_class = &apos; &apos;+obj.className+&apos; &apos;;//获取 class 内容, 并在首尾各加一个空格. ex) &apos;abc bcd&apos; -&gt; &apos; abc bcd &apos; obj_class = obj_class.replace(/(\s+)/gi, &apos; &apos;),//将多余的空字符替换成一个空格. ex) &apos; abc bcd &apos; -&gt; &apos; abc bcd &apos; var removed = obj_class.replace(&apos; &apos;+cls+&apos; &apos;, &apos; &apos;);//在原来的 class 替换掉首尾加了空格的 class. ex) &apos; abc bcd &apos; -&gt; &apos;bcd &apos; removed = removed.replace(/(^\s+)|(\s+$)/g, &apos;&apos;);//去掉首尾空格. ex) &apos;bcd &apos; -&gt; &apos;bcd&apos; obj.className = removed;//替换原来的 class.&#125; - [3] hasClass 1234567891011function hasClass(obj, cls)&#123; var obj_class = obj.className;//获取 class 内容. var obj_class_lst = obj_class.split(/\s+/);//通过split空字符将cls转换成数组. var x = 0; for(x in obj_class_lst) &#123; if(obj_class_lst[x] == cls) &#123;//循环数组, 判断是否包含cls return true; &#125; &#125; return false;&#125; ==原文链接 ++link++== 或者 12345678910111213141516171819202122232425262728293031323334/** * 判断样式是否存在 */function hasClass(obj, cls) &#123; return obj.className.match(new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;));&#125;/** * 为指定的dom元素添加样式 */function addClass(obj, cls) &#123; if (!this.hasClass(obj, cls)) obj.className += &quot; &quot; + cls;&#125;/** * 删除指定dom元素的样式 */function removeClass(obj, cls) &#123; if (hasClass(obj, cls)) &#123; var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;); obj.className = obj.className.replace(reg, &apos; &apos;); &#125;&#125;/** * 如果存在(不存在)，就删除(添加)一个样式 */function toggleClass(obj, cls) &#123; if (hasClass(obj, cls)) &#123; removeClass(obj, cls); &#125; else &#123; addClass(obj, cls); &#125;&#125; ==原文链接 ++link++==]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css解决背景透明的兼容性问题]]></title>
    <url>%2Fcss%E8%A7%A3%E5%86%B3%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[全浏览器兼容背景半透明的问题的么几个解决方案：1.使用半透明png图片平铺2.使用opcacity属性3.使用rgba和IE的opacity滤镜属性结合RGBA颜色rgba颜色的四个属性分别表示 red红色、green绿色、blue蓝色、alpha透明度。通过这几个数值能够轻松实现背景透明。代码如下：123456.backTtansparent&#123; /* 用于不支持RGBa的浏览器 */ background: rgb(0, 0, 0); /* RGBa, 透明度0.6 */ background: rgba(0, 0, 0, 0.6); &#125; 这样透明只对背景生效，对于非 ie 浏览器是非常完美的解决方案。不幸的是 ie8 及以下不支持 rgba 属性，并且经测试 ie9 会把 rgba 解析为全透明。 IE的filter 通过background: transparent注释可解决 ie9 解析rgba全透明问题。通过ie 的 filter 属性便可让 ie 支持背景透明。代码如下： 1234567.backTtansparent&#123; background: transparent/9; /* For IE 5.5 - 7*/ filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000); /* For IE 8*/ -ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;; &#125; 能够看到filter中的8位16进制的半透明颜色#99000000为argb颜色，既#AARRGGBB，前两位是透明度，后面分别是红绿蓝。 如果我们希望透明度为 0.6，则需要将 0.6 乘以 255,再转化为 16 进制。最简单的方法是利用 JavaScript，在浏览器的调试面板里输入： 12Math.floor(0.6 * 255).toString(16); 回车后可以看到结果为99。这样透明度0.6的黑色的argb颜色即为#99000000。代码整合 1234567background: rgb(0, 0, 0); /* RGBa with 0.6 opacity */ background: rgba(0, 0, 0, 0.6); /* For IE 5.5 - 7*/ filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000); /* For IE 8*/ -ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;;]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>css兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 设置「阅读全文」1.在文章中使用 手动进行截断，Hexo 提供的方式 推荐2.在文章的 front-matter 中添加 description，并提供文章摘录3.自动形成摘要，在 主题配置文件 中添加： auto_excerpt: enable: true length: 150默认截取的长度为 150 字符，可以根据需要自行设定 1$ hexo deploy]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
</search>
