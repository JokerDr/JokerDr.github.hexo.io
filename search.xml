<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法基础之二分查找]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</url>
    <content type="text"><![CDATA[最近在看《算法基础·打开算法之门》（毕竟程序猿的算法不能太差…）人总是健忘的，所以我决定将我收获的东西记录下来那么，首先，就是你了，最基础的二分查找！关于二分查找，可以拥有如下叙述:任意情况下，我们仅仅考虑某个子数组，也就是说，介于某两个索引之间的部分数组，将这两个索引依次记为p和r。初始时，p=1,r=n，因此开始时，子数组为整个完整数组，我们反复地将数组规模减半，直到一下任意一种情况发生：要么找到了要查找的元素，要么当前子数组为空（p&gt;r）。反复对子数组执行减半操作需要的时间花费是O(lgn)case-1逻辑：程序：binary-search(arr,n,x)输入：arr:一个数组n:数组中元素的个数x要查找的值输出满足条件的arr[i]的索引i，特殊值‘not found’（相对于数组的任意无效索引值）具体步骤1）将p赋值为1,r赋值为n2）只要p &lt; = r,执行如下操作：A.将q赋值为(p + r) / 2 ———— ps:向下取整B.如果A[q] = x,那么返回q。C.否则（A[q] ! = x）,如果A[q]&gt;x,那么将r赋值为为q-1D.否则（A[q] &lt; x），那么将p赋值为q+13）返回“not found”js代码实现12345678910111213141516171819//默认由小到大排列数据function binary-search(arr,n,x)&#123; var p = 0; var r = n-1; if(p &lt; = r)&#123; var q = Math.floor((p+r)/2); if(arr[q] == x)&#123; return q; &#125;else&#123; if(arr[q]&gt;x)&#123; r = q - 1; //真实上限索引要比x索引小，所以需要对数组上限重新取半赋值； &#125;else&#123; p = q + 1 //真实下限索引要比x索引大，所以需要对数组上限重新取半赋值； &#125; &#125; &#125;else&#123; return 'NOT FOUND !'; &#125;&#125; case-2 (递归的方式)逻辑：程序：recursive-binary-search(arr,p,r,x)输入输出 相关变量同上文 增加p ,r 为数组arr的开头结尾索引 具体步骤 1）如果p &gt; r,那么返回“not found” 2）否则(p &lt; = r),执行如下操作： A.将q赋值为(p + r) / 2 ———— ps:向下取整 B.如果A[q] = x,那么返回q。 C.否则（A[q] ! = x）,如果A[q] &gt; x,那么返回一个 recursive-binary-search(arr,p,q-1,x) D.否则（A[q] &lt; x），那么返回一个 recursive-binary-search(arr,q+1,r,x) js代码实现1234567891011121314151617//默认由小到大排列数据function recursive-binary-search(arr,p,r,x)&#123; if(p &gt; r)&#123; return 'NOT FOUND !'; &#125;else&#123; //p &lt; = r var q = Math.floor((p + r) / 2); if(arr[q] == x)&#123; return q; &#125;else&#123; if(arr[q] &gt; x)&#123; return recursive-binary-search(arr,p,q-1,x); //真实上限索引要比x索引小，所以需要对数组上限重新取半赋值； &#125;else&#123; return recursive-binary-search(arr,q+1,r,x); //真实下限索引要比x索引大，所以需要对数组上限重新取半赋值； &#125; &#125; &#125; &#125; 当然，以上的代码也许会有错误（好像没有…），因为只是单纯根据逻辑撸码，具体事件具体分析。]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决输入框长度maxLength的兼容性问题]]></title>
    <url>%2F%E8%A7%A3%E5%86%B3%E8%BE%93%E5%85%A5%E6%A1%86%E9%95%BF%E5%BA%A6maxLength%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[最近在忙着做些东西，差点荒废了我的博客，随便写点什么吧在input标签中，只需要设置maxlength=”*”即可，但是在textarea标签中，IE9及IE9以下浏览器是不支持的，IE10、IE11则支持，估计后续的版本应该都会支持12345&lt;textarea id="taContent" rows="3" maxlength="20" onchange="this.value=this.value.substring(0, 20)"onkeydown="this.value=this.value.substring(0, 20)" onkeyup="this.value=this.value.substring(0, 20)" &gt;&lt;/textarea&gt; 备注：onchange、onkeydown、onkeyup三者缺一不可。 如省略onchange，当你用负责功能，此时一直按着ctrl不松开，鼠标去点击其他地方（焦点移出textarea）时，不会自动取消超出部分； 如省略onkeydown，猛敲的时候会有很多个字符突然不见了； 如省略onkeyup，原想预计20的情况下，会变成21，并且最后一个字符是最后敲进去的。 Maxlength 也不可省略，加上maxlength 当碰到IE10及以上版本时，可以完美的实现限制输入框字数的功能。不想其他低版本的IE浏览器还可以出现一个字母后消失。 本方法参考自： http://www.thylx.net/newsdetail.aspx?id=37]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>maxLength</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改变浏览器位置]]></title>
    <url>%2F%E6%94%B9%E5%8F%98%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。实际上，就是改变浏览器的url，so，有哪些方法呢？1231) location.assign("http://www.wrox.com")2) window.location = "http://www.wrox.com"3) location.href = "http://www.wrox.com" 当然，2）、3）其实都是调用了assign()方法的，只不过是形式不一样而已， 另外，每次修改location的属性时，如hostname,path,port等时(hash除外)，页面都会以新的URL载入， 注：无论以何种方式修改URL。都会在历史记录中生成一条新的纪录 若要禁止这种行为（即生成一条新的纪录），可以使用replace()方法，该方法接受一个参数，即要导航到的URL。 12location.replace("http://www.wrox.com"); 结果就是，同样会导致浏览器的位置改变，但是不会在历史记录生成新的纪录 最后一种改变浏览器位置的方法：reload reload //重新加载，可能是从个缓存中加载 reload(true); //强制加载，即从服务器端加载 注意：reload()调用后，也有可能不会立即执行，它取决于网络资源或系统延迟等，所以最好将reload()放在代码的最后一行]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>loaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找到数组的最值]]></title>
    <url>%2F%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%80%BC.html</url>
    <content type="text"><![CDATA[吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。在一个数组中找到最值，书中给了我们这样的一个方法（以最大值为例）：123var Values = [1,2,3];var max = Math.max.apply(Math,Values);var max = Math.max.apply(null,Values); 那么：1）问题一，为什么是 Math.max.apply() ,而非 Math.max()?答： max()方法本身需要大于等于2个的纯数字参数比如： 123console.log(Math.max(10,20,30))//"30"console.log(Math.max(10,20))//"20" console.log(Math.max(a,b));//ReferenceError: a is not defined 很明显，Math.max() 的Values，只是一个变量，无法满足大于等于2，以及纯数字的两个条件，所以为满足要求（求数组里的最值），Math.max.apply()无疑是非常好的方法： 2）问题二，为什么是 Math.max.apply(),而非是 Math.max().apply()答：我们要明白两个知识点 【1】 max() 与 max 的区别，函数名本质上是一个指向存储函数代码的内存地址的指针，单纯的写函数名并不会而函数名后面加括号如： max() ，则是对函数的调用执行。 【2】 apply() 、 call() 是每个函数都包含的非继承的方法。作用是在 特定的作用域 中 调用函数。 前者可以接受两个参数，后者可以接受两个及两个以上的参数。二者的第一个参数都是设置函数体内的 This 指向，即 “ 特定的作用域 ”。只写一个参数的情况下，默认设置的是 This 指向。 而 调用函数，等价于函数名后面加括号的效果。3）问题三， Math.max.apply(null,Values) 与 Math.max.apply(Math,Values) 区别？答：没区别。 因为第一个参数是 特定的作用域 （也就是this指向），又因为，null，默认是前面的对象。而在本题中，前面的对象是Math，所以显而易见，二者结果并无区别。，]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>apply、call</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[charAt与 indexOf与lastIndexOf]]></title>
    <url>%2FcharAt%E4%B8%8E-indexOf%E4%B8%8ElastIndexOf.html</url>
    <content type="text"><![CDATA[吾日三省吾身，读《javascript高级程序设计（第三版）》随笔。访问字符串中特定字符的方法是：charAt() &amp; charCodeAt() var stringValue = "hello world"; alert(stringValue.charAt(1));//"e" alert(stringValue.charCodeAt(1));//"101" 上述代码中1)前者charAt()输出的是指定位置的 字符2)后者charCodeAt()输出的是指定位置的字符串的编码从字符串中查找子字符串的方法是：indexOf() &amp; lastIndexOf() var stringValue = "hello world"; alert(stringValue.indexOf("o"));//"4" alert(stringValue.lastIndexOf("o"));//"7" 上述代码中无论是indexOf()还是lastIndexOf()，返回的子字符串位置都是基于正向查询 (始于0) 。由此可知，若子字符串在源字符串中只出现过一次，则两种方法返回相同的结果。若未找到该字符串，则都返回-1而区别在于：1）前者indexOf()方法，是从开头向后搜索字符串2）后者lastIndexOf()方法，是从末尾向开头搜索字符串]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>字符串位置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 ‘ + ’ 与 new Date]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E-%E2%80%99-%E2%80%98-%E4%B8%8E-new-Date.html</url>
    <content type="text"><![CDATA[在读《javascript高级程序设计（第三版）》时，遇到的一行代码var start = +new Date();那么，+new Date()是什么意思？虽然大概有些猜测,但，我还是决定查一查。Javascript中可以在某个元素前使用+号,这个操作是将该元素转换成Number类型，如果转换失败，会得到NAN.注：（适当的使用 运算符 可以简化 Number类型的转化过程）所以 +newDate将会调用Data.prototype上的valueOf,而且，查一查MDN，我们也可以知道，Data.prototype.valueOf()等价于Date.prototype.getTime().所以下列代码的效果是相同的：1234console.log(+new Date);console.log(new Date().getTime());console.log(new Date().valueOf());console.log(new Date()*1); 经过实际测试，以上所有代码都会返回当前时间的总毫秒数,（单纯的 new Date或new Date()会输出GMT时间， 如：Fri Mar 09 2018 22:17:43 GMT+0800 (中国标准时间)） 实际上，在上述代码中，不止+号，在代码后面加上*1或者/1达到相同的输出效果]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>逻辑运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ajax，大概需要了解哪些基础性的东西？]]></title>
    <url>%2F%E5%85%B3%E4%BA%8Eajax%EF%BC%8C%E5%A4%A7%E6%A6%82%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%80%A7%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%9F.html</url>
    <content type="text"><![CDATA[人总是健忘的，那么为什么不多动动手呢？比如说把知识记下来。我们总会或有或无的接触ajax技术，那么作为一名学习者，就有必要了解相关的知识ajax(客户端与服务器端异步的通信的技术)原理:相当于在用户和服务器之间加了—个中间层(AJAX引擎),通过创建一个XmlHttpRequest对象来向服务器发异步请求,通过回调在回调函数里进行dom操作.代码原理：1.第一步：创建XMLHttpRequest 对象xmlhttp=new XMLHttpRequest();（它有兼容性问题，在ie中用的是new ActiveXObject） 2.第二步：向服务器发送请求xmlhttp.open(&quot;GET/POST&quot;,url,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//POST时要加这句话 xmlhttp.send(); 3.第三步：执行回调，在回调函数中进行相应的dom操作xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)//判断状态码 { //就可以执行相应的dom操作 document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; } } readyState有5种值：0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status状态码常见的有：200 服务器成功返回 301 永久重定向 302 临时重定向 304 缓存 403 服务器拒绝访问 404 资源找不到 500 服务器错误 优与劣ajax的优点:&lt;1&gt;.无刷新更新数据。 &lt;2&gt;.异步与服务器通信。 &lt;3&gt;.前端和后端负载平衡。(减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担) &lt;4&gt;.基于标准被广泛支持。 &lt;5&gt;.界面与应用分离。 ajax的缺点:&lt;1&gt;.AJAX干掉了Back和History功能，即对浏览器机制的破坏。 &lt;2&gt;.AJAX的安全问题。 &lt;3&gt;.违背URL和资源定位的初衷。 &lt;4&gt;.客户端过肥，太多客户端代码造成开发上的成本。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对CommonJS规范的一些理解]]></title>
    <url>%2F%E5%AF%B9CommonJS%E8%A7%84%E8%8C%83%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3.html</url>
    <content type="text"><![CDATA[咸鱼了一个寒假，不能再这样了。。。学海无涯啊0.0概述Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。12345example.jsvar x = 5;var addX = function (value) &#123;return value + x;&#125;; 上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。 如果想在多个文件分享变量，必须定义为global对象的属性。 1global.warning = true; 上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。 CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 123456var x = 5;var addX = function (value) &#123;return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; 上面代码通过module.exports输出变量x和函数addX。 require方法用于加载模块。 123var example = require('./example.js');console.log(example.x); // 5console.log(example.addX(1)); // 6 require方法的详细解释参见《Require命令》一节。 CommonJS模块的特点如下: 1.所有代码都运行在模块作用域，不会污染全局作用域。2.模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了,以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。3.模块加载的顺序，按照其在代码中出现的顺序。 module对象 Node内部提供一个Module构建函数。所有模块都是Module的实例。 12345function Module(id, parent) &#123;this.id = id;this.exports = &#123;&#125;;this.parent = parent;// ... 每个模块内部，都有一个module对象，代表当前模块。它有以下属性。 module.id 模块的识别符，通常是带有绝对路径的模块文件名。module.filename 模块的文件名，带有绝对路径。module.loaded 返回一个布尔值，表示模块是否已经完成加载。module.parent 返回一个对象，表示调用该模块的模块。module.children 返回一个数组，表示该模块要用到的其他模 块。module.exports 表示模块对外输出的值。 下面是一个示例文件，最后一行输出module变量。 1234// example.jsvar jquery = require('jquery');exports.$ = jquery;console.log(module); 执行这个文件，命令行会输出如下信息。 12345678910111213141516171819&#123; id: '.',exports: &#123; '$': [Function] &#125;,parent: null,filename: '/path/to/example.js',loaded: false,children:[ &#123; id: '/path/to/node_modules/jquery/dist/jquery.js', exports: [Function], parent: [Circular], filename: '/path/to/node_modules/jquery/dist/jquery.js', loaded: true, children: [], paths: [Object] &#125; ],paths:[ '/home/user/deleted/node_modules', '/home/user/node_modules', '/home/node_modules', '/node_modules' ]&#125; 如果在命令行下调用某个模块，比如node something.js，那么module.parent就是null。如果是在脚本之中调用，比如require(‘./something.js’)，那么module.parent就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。 123456789if (!module.parent) &#123; // ran with `node something.js` app.listen(8088, function() &#123; console.log('app listening on port 8088'); &#125;) &#125; else &#123; // used with `require('/.something.js')` module.exports = app; &#125; module.exports属性 module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。 123456var EventEmitter = require('events').EventEmitter;module.exports = new EventEmitter();setTimeout(function() &#123;module.exports.emit('ready');&#125;, 1000); 上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。 1234var a = require('./a');a.on('ready', function() &#123;console.log('module a is ready');&#125;); exports变量 为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。 1var exports = module.exports; 造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。 1234567exports.area = function (r) &#123;return Math.PI * r * r;&#125;;exports.circumference = function (r) &#123;return 2 * Math.PI * r;&#125;; 注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。 1exports = function(x) &#123;console.log(x)&#125;; 上面这样的写法是无效的，因为exports不再指向module.exports了。 下面的写法也是无效的。 12345exports.hello = function() &#123;return 'hello';&#125;;module.exports = 'Hello world'; 上面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了。 这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。 1module.exports = function (x)&#123; console.log(x);&#125;; 如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。 AMD规范与CommonJS规范的兼容性 CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。 AMD规范使用define方法定义模块，下面就是一个例子： 123456789define(['package/lib'], function(lib)&#123;function foo()&#123; lib.log('hello world!');&#125;return &#123; foo: foo&#125;;&#125;); AMD规范允许输出的模块兼容CommonJS规范，这时define方法需要写成下面这样： 123456789101112define(function (require, exports, module)&#123;var someModule = require("someModule");var anotherModule = require("anotherModule");someModule.doTehAwesome();anotherModule.doMoarAwesome();exports.asplode = function ()&#123; someModule.doTehAwesome(); anotherModule.doMoarAwesome();&#125;;&#125;); require命令基本用法 Node使用CommonJS模块规范，内置的require命令用于加载模块文件。 require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。 12345678910// example.jsvar invisible = function () &#123;console.log("invisible");&#125;exports.message = "hi";exports.say = function () &#123;console.log(message);&#125; 运行下面的命令，可以输出exports对象。 123456var example = require('./example.js');example// &#123;// message: "hi",// say: [Function]// &#125; 如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定在module.exports变量上面。 123456789101112131415 module.exports = function () &#123; console.log("hello world") &#125; require('./example2.js')() ``` 上面代码中，require命令调用自身，等于是执行module.exports，因此会输出 hello world。#### 加载规则- require命令用于加载文件，后缀名默认为.js。 ```bash var foo = require('foo'); // 等同于 var foo = require('foo.js'); 根据参数的不同格式，require命令去不同路径寻找模块文件。 （1）如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(&#39;/home/marco/foo.js&#39;)将加载/home/marco/foo.js。 （2）如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(&#39;./circle&#39;)将加载当前脚本同一目录的circle.js。 （3）如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。 举例来说，脚本/home/user/projects/foo.js执行了require(&#39;bar.js&#39;)命令，Node会依次搜索以下文件。 /usr/local/lib/node/bar.js/home/user/projects/node_modules/bar.js/home/user/node_modules/bar.js/home/node_modules/bar.js/node_modules/bar.js 这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。 （4）如果参数字符串不以“./“或”/“开头，而且是一个路径， 比如require(&#39;example-module/path/to/file&#39;)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。 （5）如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。 （6）如果想得到require命令加载的确切文件名，使用require.resolve()方法。 目录的加载规则 通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录。在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。 123// package.json&#123; "name" : "some-library","main" : "./lib/some-library.js" &#125; require发现参数字符串指向一个目录以后，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件。如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件。 模块的缓存 第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性。 1234require('./example.js');require('./example.js').message = "hello";require('./example.js').message// "hello" 上面代码中，连续三次使用require命令，加载同一个模块。第二次加载的时候，为输出的对象添加了一个message属性。但是第三次加载的时候，这个message属性依然存在，这就证明require命令并没有重新加载模块文件，而是输出了缓存。 如果想要多次执行某个模块，可以让该模块输出一个函数，然后每次require这个模块的时候，重新执行一下输出的函数。 所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写。 1234567// 删除指定模块的缓存delete require.cache[moduleName];// 删除所有模块的缓存Object.keys(require.cache).forEach(function(key) &#123;delete require.cache[key];&#125;) 注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，require命令还是会重新加载该模块。 环境变量NODE_PATH Node执行一个脚本时，会先查看环境变量NODE_PATH。它是一组以冒号分隔的绝对路径。在其他位置找不到指定模块时，Node会去这些路径查找。 可以将NODE_PATH添加到.bashrc。 1export NODE_PATH="/usr/local/lib/node" 所以，如果遇到复杂的相对路径，比如下面这样。 1var myModule = require('../../../../lib/myModule'); 有两种解决方法，一是将该文件加入node_modules目录，二是修改NODE_PATH环境变量，package.json文件可以采用下面的写法。 1234567891011&#123;"name": "node_path","version": "1.0.0","description": "","main": "index.js","scripts": &#123; "start": "NODE_PATH=lib node index.js"&#125;,"author": "","license": "ISC"&#125; NODE_PATH是历史遗留下来的一个路径解决方案，通常不应该使用，而应该使用node_modules目录机制。 模块的循环加载 如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。 12345678910111213// a.jsexports.x = 'a1';console.log('a.js ', require('./b.js').x);exports.x = 'a2';// b.jsexports.x = 'b1';console.log('b.js ', require('./a.js').x);exports.x = 'b2';// main.jsconsole.log('main.js ', require('./a.js').x);console.log('main.js ', require('./b.js').x); 上面代码是三个JavaScript文件。其中，a.js加载了b.js，而b.js又加载a.js。这时，Node返回a.js的不完整版本，所以执行结果如下。 12345$ node main.jsb.js a1a.js b2main.js a2main.js b2 修改main.js，再次加载a.js和b.js。 12345// main.jsconsole.log('main.js ', require('./a.js').x);console.log('main.js ', require('./b.js').x);console.log('main.js ', require('./a.js').x);console.log('main.js ', require('./b.js').x); 执行上面代码，结果如下。 1234567$ node main.jsb.js a1a.js b2main.js a2main.js b2main.js a2main.js b2 上面代码中，第二次加载a.js和b.js时，会直接从缓存读取exports属性，所以a.js和b.js内部的console.log语句都不会执行了。 require.main require方法有一个main属性，可以用来判断模块是直接执行，还是被调用执行。 直接执行的时候（node module.js），require.main属性指向模块本身。 require.main === module // true 调用执行的时候（通过require加载该脚本执行），上面的表达式返回false。 模块的加载机制 CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。 下面是一个模块文件lib.js。 // lib.js var counter = 3; function incCounter() { counter++; } module.exports = { counter: counter, incCounter: incCounter, }; 上面代码输出内部变量counter和改写这个变量的内部方法incCounter。 然后，加载上面的模块。 // main.js var counter = require(&apos;./lib&apos;).counter; var incCounter = require(&apos;./lib&apos;).incCounter; console.log(counter); // 3 incCounter(); console.log(counter); // 3 上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。 require的内部处理流程 require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。 123456789Module._load = function(request, parent, isMain) &#123;// 1. 检查 Module._cache，是否缓存之中有指定模块// 2. 如果缓存之中没有，就创建一个新的Module实例// 3. 将它保存到缓存// 4. 使用 module.load() 加载指定的模块文件，// 读取文件内容之后，使用 module.compile() 执行文件代码// 5. 如果加载/解析过程报错，就从缓存删除该模块// 6. 返回该模块的 module.exports&#125;; 上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。 123456Module.prototype._compile = function(content, filename) &#123;// 1. 生成一个require函数，指向module.require// 2. 加载其他辅助方法到require// 3. 将文件内容放到一个函数之中，该函数可调用 require// 4. 执行该函数&#125;; 上面的第1步和第2步，require函数及其辅助方法主要如下。 12345require(): 加载外部模块require.resolve()：将模块名解析到一个绝对路径require.main：指向主模块require.cache：指向所有缓存的模块require.extensions：根据文件的后缀名，调用不同的执行函数 一旦require函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括require、module、exports，以及其他一些参数。 123(function (exports, require, module, __filename, __dirname) &#123;// YOUR CODE INJECTED HERE!&#125;); Module._compile方法是同步执行的，所以Module._load要等它执行完成，才会向用户返回module.exports的值。 本文引自阮一峰的文章受益匪浅，由是感激！链接：http://javascript.ruanyifeng.com/nodejs/module.html#]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>CommonJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ES6 const 篇]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EES6-const-%E7%AF%87.html</url>
    <content type="text"><![CDATA[阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》原文链接：http://es6.ruanyifeng.com/#docs/let学海无涯，愿与诸君共勉const 命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。123456var message = "Hello!";let age = 25;// 以下两行都会报错const message = "Goodbye!";const age = 30; 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: "foo" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。Node 里面，顶层对象是global，但其他环境都不支持。同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。1234567891011121314151617// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;; 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。 垫片库system.global模拟了这个提案，可以在所有环境拿到global。1234567891011121314// CommonJS 的写法require('system.global/shim')();// ES6 模块的写法import shim from 'system.global/shim'; shim();上面代码可以保证各种环境里面，global对象都是存在的。// CommonJS 的写法var global = require('system.global')();// ES6 模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ES6 : let 篇]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EES6-let-%E7%AF%87.html</url>
    <content type="text"><![CDATA[阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》原文链接：http://es6.ruanyifeng.com/#docs/let学海无涯，愿与诸君共勉基本用法块级作用域ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。12345678 &#123; let a = 10; var b = 1; &#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。for循环的计数器，就很合适使用let命令。 123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // "undefined" 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 有些“死区”比较隐蔽，不太容易发现。12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。123456// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined 上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 块级作用域为什么需要块级作用域？ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。1&#123;&#123;&#123;&#123;&#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。1234&#123;&#123;&#123;&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域与函数声明函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。1234567891011// 情况一if (true) &#123; function f() &#123;&#125;&#125;// 情况二try &#123; function f() &#123;&#125;&#125; catch(e) &#123; // ...&#125; 上面两种函数声明，根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。12345678910function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。123456789// ES5 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ 原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。 // 浏览器的 ES6 环境1234567891011function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。1234567891011// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; var f = undefined; if (false) &#123; function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。123456789101112131415// 函数声明语句&#123; let a = 'secret'; function f() &#123; return a; &#125;&#125;// 函数表达式&#123; let a = 'secret'; let f = function () &#123; return a; &#125;;&#125; 另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。12345678910// 不报错'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错'use strict';if (true) function f() &#123;&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>let</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于object.key与object[key]的区别]]></title>
    <url>%2F%E5%85%B3%E4%BA%8Eobject-key%E4%B8%8Eobject-key-%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[记录所需要的，摒弃多余的。本篇文章是对segmentfault的一个问答的总结。obeject.key与object[key]有什么区别?有什么区别，不试试怎么知道？测试代码（其实有很多栗子，随便举一个）： var obj = { name: &apos;tom&apos;, age: 22 }, someKey = &apos;age&apos;; console.log(obj.name); console.log(obj[&apos;name&apos;]); console.log(obj.someKey); console.log(obj[someKey]); 测试结果：（放图）通常来讲， obj[“key”] 与 obj.key 的作用差不多，但是，如果key不确定（key是变量）的情况下，或者key的写法比较特殊（比如包含空格什么的）则只能通过obj[ ]的方式去访问]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用语法]]></title>
    <url>%2FMarkdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[写博客，自然免不了接触Markdown,作为初学者，为了即用即查，我决定把相关命令记录下来，本文就是边学边写此处声明：本文是 参考他人的文章&amp;结合实践后，所写，另外，转载、复制随意，但请务必注明本文链接标题：写法:123456# h1级标题## h2级标题### h3级标题#### h4级标题##### h5级标题###### h6级标题 栗子： 这是一个h4级标题 注意： #与标题文字间要有空格 当-与#结合使用时，如果不想下一行受到干扰，可以使用Enter换行 分割线：连续三个&amp;三个以上的- 即可作出分割线 写法:1--- 栗子： 注意：建议写分割线时，与上一行留出一空行 超链接：写法1：1234[连接名称](网址 , 标题)[baidu](https://www.baidu.com, "baidu")[&lt;i class="icon-refresh"&gt;&lt;/i&gt; 点我刷新](/#) 栗子： baidu 点我刷新 写法2：12345[链接名][链接代号][链接代号]:详细地址[here][3][3]: http://www.baidu.com 栗子： here 写法3：1直接展示链接：&lt;http://www.baidu.com&gt; 栗子： 直接展示链接：http://www.baidu.com 键盘键用法：1&lt;kbd&gt;Ctrl+[&lt;/kbd&gt; and &lt;kbd&gt;Ctrl+]&lt;/kbd&gt; 栗子： Ctrl+[ and Ctrl+] code格式：反引号 用法：12Use the `printf()` function. ``There is a literal backtick (`) here.针对在代码区段内插入反引号的情况` 栗子： Use the printf() function. There is a literal backtick (`) here.针对在代码区段内插入反引号的情况 强调：用法：12*斜体强调***粗体强调** 栗子： 斜体强调 粗体强调 图片：用法：12![Alt text](../imgs/blogContentImgs/jhvh.jpg "这图我觉得扣得不错")如果图片链接失效的话，会显示 Alt text 栗子： 使用 icon 图标文字：用法：1&lt;i class="fa fa-github"&gt;&lt;/i&gt; 栗子： 段落： 以一个空行开始，以一个空行结束，中间的就是一个段落。 表格：用法：12345Item | Value-------- | ---Computer | $1600Phone | $12Pipe | $1 栗子： Item Value Computer $1600 Phone $12 Pipe $1 无序列表：使用 - 加一个空格 用法：123- 无需列表1- 无序列表2- 无序列表3 栗子： 无需列表1 无序列表2 无序列表3 有序列表：使用 数字 加一个英文句点 用法：123451. 有序列表2. 有序列表3. 有序列表4. 有序列表5. 有序列表 栗子： 有序列表 有序列表 有序列表 有序列表 有序列表 换行缩进形成代码区块：用法：这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。 栗子：这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。 块引用用法：12345678&gt;给引用的文本开始位置都加一个 '&gt;'，&gt;便可组成一个块引用。在块引用中，可以结合&gt;其他markdown元素一块使用，比如列表。&gt;**强调**也可以只在第一行加大于号，其他位置不加。&gt;- 块引用里使用列表，需要和上面的内容隔开一个空行&gt;- 记得加空格哦。 栗子： 给引用的文本开始位置都加一个 ‘&gt;’，便可组成一个块引用。在块引用中，可以结合其他markdown元素一块使用，比如列表。强调也可以只在第一行加大于号，其他位置不加。 块引用里使用列表，需要和上面的内容隔开一个空行 记得加空格哦。 本文参考链接：[掌握这几种 Markdown 语法你就够了]https://laravel-china.org/topics/621/you-will-be-able-to-master-these-markdown-grammars[中文文案排版指北]:https://github.com/sparanoid/chinese-copywriting-guidelines]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现jQuery的addClass, removeClass, hasClass函数功能]]></title>
    <url>%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0jQuery%E7%9A%84addClass%2C%20removeClass%2C%20hasClass%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD.html</url>
    <content type="text"><![CDATA[- [1] addClass123456function addClass(obj, cls)&#123; var obj_class = obj.className;//获取 class 内容. var blank = (obj_class != &apos;&apos;) ? &apos; &apos; : &apos;&apos;;//判断获取到的 class 是否为空, 如果不为空在前面加个&apos;空格&apos;. var added = obj_class + blank + cls;//组合原来的 class 和需要添加的 class. obj.className = added;//替换原来的 class.&#125; - [2] removeClass 1234567function removeClass(obj, cls)&#123; var obj_class = &apos; &apos;+obj.className+&apos; &apos;;//获取 class 内容, 并在首尾各加一个空格. ex) &apos;abc bcd&apos; -&gt; &apos; abc bcd &apos; obj_class = obj_class.replace(/(\s+)/gi, &apos; &apos;),//将多余的空字符替换成一个空格. ex) &apos; abc bcd &apos; -&gt; &apos; abc bcd &apos; var removed = obj_class.replace(&apos; &apos;+cls+&apos; &apos;, &apos; &apos;);//在原来的 class 替换掉首尾加了空格的 class. ex) &apos; abc bcd &apos; -&gt; &apos;bcd &apos; removed = removed.replace(/(^\s+)|(\s+$)/g, &apos;&apos;);//去掉首尾空格. ex) &apos;bcd &apos; -&gt; &apos;bcd&apos; obj.className = removed;//替换原来的 class.&#125; - [3] hasClass 1234567891011function hasClass(obj, cls)&#123; var obj_class = obj.className;//获取 class 内容. var obj_class_lst = obj_class.split(/\s+/);//通过split空字符将cls转换成数组. var x = 0; for(x in obj_class_lst) &#123; if(obj_class_lst[x] == cls) &#123;//循环数组, 判断是否包含cls return true; &#125; &#125; return false;&#125; ==原文链接 ++link++== 或者 12345678910111213141516171819202122232425262728293031323334/** * 判断样式是否存在 */function hasClass(obj, cls) &#123; return obj.className.match(new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;));&#125;/** * 为指定的dom元素添加样式 */function addClass(obj, cls) &#123; if (!this.hasClass(obj, cls)) obj.className += &quot; &quot; + cls;&#125;/** * 删除指定dom元素的样式 */function removeClass(obj, cls) &#123; if (hasClass(obj, cls)) &#123; var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;); obj.className = obj.className.replace(reg, &apos; &apos;); &#125;&#125;/** * 如果存在(不存在)，就删除(添加)一个样式 */function toggleClass(obj, cls) &#123; if (hasClass(obj, cls)) &#123; removeClass(obj, cls); &#125; else &#123; addClass(obj, cls); &#125;&#125; ==原文链接 ++link++==]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css解决背景透明的兼容性问题]]></title>
    <url>%2Fcss%E8%A7%A3%E5%86%B3%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[全浏览器兼容背景半透明的问题的么几个解决方案：1.使用半透明png图片平铺2.使用opcacity属性3.使用rgba和IE的opacity滤镜属性结合RGBA颜色rgba颜色的四个属性分别表示 red红色、green绿色、blue蓝色、alpha透明度。通过这几个数值能够轻松实现背景透明。代码如下：123456.backTtansparent&#123; /* 用于不支持RGBa的浏览器 */ background: rgb(0, 0, 0); /* RGBa, 透明度0.6 */ background: rgba(0, 0, 0, 0.6); &#125; 这样透明只对背景生效，对于非 ie 浏览器是非常完美的解决方案。不幸的是 ie8 及以下不支持 rgba 属性，并且经测试 ie9 会把 rgba 解析为全透明。 IE的filter 通过background: transparent注释可解决 ie9 解析rgba全透明问题。通过ie 的 filter 属性便可让 ie 支持背景透明。代码如下： 1234567.backTtansparent&#123; background: transparent/9; /* For IE 5.5 - 7*/ filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000); /* For IE 8*/ -ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;; &#125; 能够看到filter中的8位16进制的半透明颜色#99000000为argb颜色，既#AARRGGBB，前两位是透明度，后面分别是红绿蓝。 如果我们希望透明度为 0.6，则需要将 0.6 乘以 255,再转化为 16 进制。最简单的方法是利用 JavaScript，在浏览器的调试面板里输入： 12Math.floor(0.6 * 255).toString(16); 回车后可以看到结果为99。这样透明度0.6的黑色的argb颜色即为#99000000。代码整合 1234567background: rgb(0, 0, 0); /* RGBa with 0.6 opacity */ background: rgba(0, 0, 0, 0.6); /* For IE 5.5 - 7*/ filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000); /* For IE 8*/ -ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;;]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>css兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 设置「阅读全文」1.在文章中使用 手动进行截断，Hexo 提供的方式 推荐2.在文章的 front-matter 中添加 description，并提供文章摘录3.自动形成摘要，在 主题配置文件 中添加： auto_excerpt: enable: true length: 150默认截取的长度为 150 字符，可以根据需要自行设定 1$ hexo deploy]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
</search>
