<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于ES6 const 篇]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EES6-const-%E7%AF%87.html</url>
    <content type="text"><![CDATA[阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》原文链接：http://es6.ruanyifeng.com/#docs/let学海无涯，愿与诸君共勉const 命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。123456var message = "Hello!";let age = 25;// 以下两行都会报错const message = "Goodbye!";const age = 30; 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: "foo" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。Node 里面，顶层对象是global，但其他环境都不支持。同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。1234567891011121314151617// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;; 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。 垫片库system.global模拟了这个提案，可以在所有环境拿到global。1234567891011121314// CommonJS 的写法require('system.global/shim')();// ES6 模块的写法import shim from 'system.global/shim'; shim();上面代码可以保证各种环境里面，global对象都是存在的。// CommonJS 的写法var global = require('system.global')();// ES6 模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ES6 : let 篇]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EES6-let-%E7%AF%87.html</url>
    <content type="text"><![CDATA[阅读声明：本文摘取自阮一峰先生的著作《ECMAScript 6 入门》原文链接：http://es6.ruanyifeng.com/#docs/let学海无涯，愿与诸君共勉基本用法块级作用域ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。12345678 &#123; let a = 10; var b = 1; &#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。for循环的计数器，就很合适使用let命令。 123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // "undefined" 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 有些“死区”比较隐蔽，不太容易发现。12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。123456// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined 上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 块级作用域为什么需要块级作用域？ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。1&#123;&#123;&#123;&#123;&#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。1234&#123;&#123;&#123;&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域与函数声明函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。1234567891011// 情况一if (true) &#123; function f() &#123;&#125;&#125;// 情况二try &#123; function f() &#123;&#125;&#125; catch(e) &#123; // ...&#125; 上面两种函数声明，根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。12345678910function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。123456789// ES5 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ 原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。 // 浏览器的 ES6 环境1234567891011function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。1234567891011// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; var f = undefined; if (false) &#123; function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。123456789101112131415// 函数声明语句&#123; let a = 'secret'; function f() &#123; return a; &#125;&#125;// 函数表达式&#123; let a = 'secret'; let f = function () &#123; return a; &#125;;&#125; 另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。12345678910// 不报错'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错'use strict';if (true) function f() &#123;&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>let</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于object.key与object[key]的区别]]></title>
    <url>%2F%E5%85%B3%E4%BA%8Eobject-key%E4%B8%8Eobject-key-%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[记录所需要的，摒弃多余的。本篇文章是对segmentfault的一个问答的总结。obeject.key与object[key]有什么区别?有什么区别，不试试怎么知道？测试代码（其实有很多栗子，随便举一个）： var obj = { name: &apos;tom&apos;, age: 22 }, someKey = &apos;age&apos;; console.log(obj.name); console.log(obj[&apos;name&apos;]); console.log(obj.someKey); console.log(obj[someKey]); 测试结果：（放图）通常来讲， obj[“key”] 与 obj.key 的作用差不多，但是，如果key不确定（key是变量）的情况下，或者key的写法比较特殊（比如包含空格什么的）则只能通过obj[ ]的方式去访问]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用语法]]></title>
    <url>%2FMarkdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[写博客，自然免不了接触Markdown,作为初学者，为了即用即查，我决定把相关命令记录下来，本文就是边学边写此处声明：本文是 参考他人的文章&amp;结合实践后，所写，另外，转载、复制随意，但请务必注明本文链接标题：写法:123456# h1级标题## h2级标题### h3级标题#### h4级标题##### h5级标题###### h6级标题 栗子： 这是一个h4级标题 注意： #与标题文字间要有空格 当-与#结合使用时，如果不想下一行受到干扰，可以使用Enter换行 分割线：连续三个&amp;三个以上的- 即可作出分割线 写法:1--- 栗子： 注意：建议写分割线时，与上一行留出一空行 超链接：写法1：1234[连接名称](网址 , 标题)[baidu](https://www.baidu.com, "baidu")[&lt;i class="icon-refresh"&gt;&lt;/i&gt; 点我刷新](/#) 栗子： baidu 点我刷新 写法2：12345[链接名][链接代号][链接代号]:详细地址[here][3][3]: http://www.baidu.com 栗子： here 写法3：1直接展示链接：&lt;http://www.baidu.com&gt; 栗子： 直接展示链接：http://www.baidu.com 键盘键用法：1&lt;kbd&gt;Ctrl+[&lt;/kbd&gt; and &lt;kbd&gt;Ctrl+]&lt;/kbd&gt; 栗子： Ctrl+[ and Ctrl+] code格式：反引号 用法：12Use the `printf()` function. ``There is a literal backtick (`) here.针对在代码区段内插入反引号的情况` 栗子： Use the printf() function. There is a literal backtick (`) here.针对在代码区段内插入反引号的情况 强调：用法：12*斜体强调***粗体强调** 栗子： 斜体强调 粗体强调 图片：用法：12![Alt text](../imgs/blogContentImgs/jhvh.jpg "这图我觉得扣得不错")如果图片链接失效的话，会显示 Alt text 栗子： 使用 icon 图标文字：用法：1&lt;i class="fa fa-github"&gt;&lt;/i&gt; 栗子： 段落： 以一个空行开始，以一个空行结束，中间的就是一个段落。 表格：用法：12345Item | Value-------- | ---Computer | $1600Phone | $12Pipe | $1 栗子： Item Value Computer $1600 Phone $12 Pipe $1 无序列表：使用 - 加一个空格 用法：123- 无需列表1- 无序列表2- 无序列表3 栗子： 无需列表1 无序列表2 无序列表3 有序列表：使用 数字 加一个英文句点 用法：123451. 有序列表2. 有序列表3. 有序列表4. 有序列表5. 有序列表 栗子： 有序列表 有序列表 有序列表 有序列表 有序列表 换行缩进形成代码区块：用法：这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。 栗子：这里先换行，然后缩进4个空格，之后的内容便可以原样显示了，适合用于显示代码内容。直到文本结束或最后一个存在缩进的行为止。 块引用用法：12345678&gt;给引用的文本开始位置都加一个 '&gt;'，&gt;便可组成一个块引用。在块引用中，可以结合&gt;其他markdown元素一块使用，比如列表。&gt;**强调**也可以只在第一行加大于号，其他位置不加。&gt;- 块引用里使用列表，需要和上面的内容隔开一个空行&gt;- 记得加空格哦。 栗子： 给引用的文本开始位置都加一个 ‘&gt;’，便可组成一个块引用。在块引用中，可以结合其他markdown元素一块使用，比如列表。强调也可以只在第一行加大于号，其他位置不加。 块引用里使用列表，需要和上面的内容隔开一个空行 记得加空格哦。 本文参考链接：[掌握这几种 Markdown 语法你就够了]https://laravel-china.org/topics/621/you-will-be-able-to-master-these-markdown-grammars[中文文案排版指北]:https://github.com/sparanoid/chinese-copywriting-guidelines]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现jQuery的addClass, removeClass, hasClass函数功能]]></title>
    <url>%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0jQuery%E7%9A%84addClass%2C%20removeClass%2C%20hasClass%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD.html</url>
    <content type="text"><![CDATA[- [1] addClass123456function addClass(obj, cls)&#123; var obj_class = obj.className;//获取 class 内容. var blank = (obj_class != &apos;&apos;) ? &apos; &apos; : &apos;&apos;;//判断获取到的 class 是否为空, 如果不为空在前面加个&apos;空格&apos;. var added = obj_class + blank + cls;//组合原来的 class 和需要添加的 class. obj.className = added;//替换原来的 class.&#125; - [2] removeClass 1234567function removeClass(obj, cls)&#123; var obj_class = &apos; &apos;+obj.className+&apos; &apos;;//获取 class 内容, 并在首尾各加一个空格. ex) &apos;abc bcd&apos; -&gt; &apos; abc bcd &apos; obj_class = obj_class.replace(/(\s+)/gi, &apos; &apos;),//将多余的空字符替换成一个空格. ex) &apos; abc bcd &apos; -&gt; &apos; abc bcd &apos; var removed = obj_class.replace(&apos; &apos;+cls+&apos; &apos;, &apos; &apos;);//在原来的 class 替换掉首尾加了空格的 class. ex) &apos; abc bcd &apos; -&gt; &apos;bcd &apos; removed = removed.replace(/(^\s+)|(\s+$)/g, &apos;&apos;);//去掉首尾空格. ex) &apos;bcd &apos; -&gt; &apos;bcd&apos; obj.className = removed;//替换原来的 class.&#125; - [3] hasClass 1234567891011function hasClass(obj, cls)&#123; var obj_class = obj.className;//获取 class 内容. var obj_class_lst = obj_class.split(/\s+/);//通过split空字符将cls转换成数组. var x = 0; for(x in obj_class_lst) &#123; if(obj_class_lst[x] == cls) &#123;//循环数组, 判断是否包含cls return true; &#125; &#125; return false;&#125; ==原文链接 ++link++== 或者 12345678910111213141516171819202122232425262728293031323334/** * 判断样式是否存在 */function hasClass(obj, cls) &#123; return obj.className.match(new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;));&#125;/** * 为指定的dom元素添加样式 */function addClass(obj, cls) &#123; if (!this.hasClass(obj, cls)) obj.className += &quot; &quot; + cls;&#125;/** * 删除指定dom元素的样式 */function removeClass(obj, cls) &#123; if (hasClass(obj, cls)) &#123; var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;); obj.className = obj.className.replace(reg, &apos; &apos;); &#125;&#125;/** * 如果存在(不存在)，就删除(添加)一个样式 */function toggleClass(obj, cls) &#123; if (hasClass(obj, cls)) &#123; removeClass(obj, cls); &#125; else &#123; addClass(obj, cls); &#125;&#125; ==原文链接 ++link++==]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css解决背景透明的兼容性问题]]></title>
    <url>%2Fcss%E8%A7%A3%E5%86%B3%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[全浏览器兼容背景半透明的问题的么几个解决方案：1.使用半透明png图片平铺2.使用opcacity属性3.使用rgba和IE的opacity滤镜属性结合RGBA颜色rgba颜色的四个属性分别表示 red红色、green绿色、blue蓝色、alpha透明度。通过这几个数值能够轻松实现背景透明。代码如下：123456.backTtansparent&#123; /* 用于不支持RGBa的浏览器 */ background: rgb(0, 0, 0); /* RGBa, 透明度0.6 */ background: rgba(0, 0, 0, 0.6); &#125; 这样透明只对背景生效，对于非 ie 浏览器是非常完美的解决方案。不幸的是 ie8 及以下不支持 rgba 属性，并且经测试 ie9 会把 rgba 解析为全透明。 IE的filter 通过background: transparent注释可解决 ie9 解析rgba全透明问题。通过ie 的 filter 属性便可让 ie 支持背景透明。代码如下： 1234567.backTtansparent&#123; background: transparent/9; /* For IE 5.5 - 7*/ filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000); /* For IE 8*/ -ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;; &#125; 能够看到filter中的8位16进制的半透明颜色#99000000为argb颜色，既#AARRGGBB，前两位是透明度，后面分别是红绿蓝。 如果我们希望透明度为 0.6，则需要将 0.6 乘以 255,再转化为 16 进制。最简单的方法是利用 JavaScript，在浏览器的调试面板里输入： 12Math.floor(0.6 * 255).toString(16); 回车后可以看到结果为99。这样透明度0.6的黑色的argb颜色即为#99000000。代码整合 1234567background: rgb(0, 0, 0); /* RGBa with 0.6 opacity */ background: rgba(0, 0, 0, 0.6); /* For IE 5.5 - 7*/ filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000); /* For IE 8*/ -ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;;]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>css兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 设置「阅读全文」1.在文章中使用 手动进行截断，Hexo 提供的方式 推荐2.在文章的 front-matter 中添加 description，并提供文章摘录3.自动形成摘要，在 主题配置文件 中添加： auto_excerpt: enable: true length: 150默认截取的长度为 150 字符，可以根据需要自行设定 1$ hexo deploy]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
</search>
